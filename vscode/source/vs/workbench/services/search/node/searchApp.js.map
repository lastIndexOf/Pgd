{"version":3,"sources":["vs/workbench/services/search/node/fake","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/assert.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/collections.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/errors.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/arrays.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/functional.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/iterator.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/lifecycle.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/linkedList.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/event.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/cancellation.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/async.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/network.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/platform.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/process.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/path.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/stopwatch.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/strings.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/comparers.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/extpath.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/types.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/objects.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/uri.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/amd.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/map.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/filters.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/glob.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/normalization.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/resources.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/uuid.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/console.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/decoder.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/flow.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/stream.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/encoding.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/extfs.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/quickopen/common/quickOpenScorer.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/errorMessage.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/processes.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.cp.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/files/node/files.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/instantiation/common/instantiation.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/log/common/log.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/registry/common/platform.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/common/views.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/common/search.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/ripgrepSearchUtils.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/searchIpc.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/textSearchManager.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/ripgrepFileSearch.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/fileSearch.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/textSearchAdapter.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/rawSearchService.ts","vs/workbench/services/search/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/search/node/searchApp.ts"],"names":["__m","__M","deps","result","i","len","length","exports","ok","value","message","Error","hasOwnProperty","Object","prototype","values","from","key","call","push","size","count","first","forEach","callback","groupBy","data","groupFn","create","element","target","fromMap","original","isPromiseCanceledError","error","name","canceledName","ErrorHandler","[object Object]","this","listeners","unexpectedErrorHandler","e","setTimeout","stack","listener","_removeListener","splice","indexOf","newUnexpectedErrorHandler","emit","errorHandler","setUnexpectedErrorHandler","onUnexpectedError","onUnexpectedExternalError","transformErrorForSerialization","$isError","stacktrace","canceled","illegalArgument","illegalState","readonly","disposed","what","getErrorMessage","err","split","String","findFirstInSorted","array","p","low","high","mid","Math","floor","mergeSort","compare","_sort","a","lo","hi","aux","leftIdx","rightIdx","_merge","sortedDiff","before","after","pushSplice","start","deleteCount","toInsert","latest","beforeIdx","afterIdx","slice","beforeElement","afterElement","n","topStep","m","pop","j","firstIndex","fn","tail","tail2","arr","equals","one","other","itemEquals","b","binarySearch","comparator","comp","currentGroup","undefined","delta","splices","removed","added","top","sort","topAsync","batch","token","Promise","resolve","reject","__awaiter","o","min","isCancellationRequested","errors_1","then","coalesce","filter","coalesceInPlace","to","move","isFalsyOrEmpty","obj","Array","isArray","isNonEmptyArray","distinct","keyFn","position","seen","elem","uniqueFilter","notFoundValue","index","commonPrefixLength","flatten","concat","range","arg","fill","num","indexer","merger","t","reduce","r","insert","arrayInsert","insertIndex","insertArr","shuffle","_seed","rand","seed","x","sin","random","temp","pushToStart","unshift","pushToEnd","find","predicate","mapArrayOrNot","items","map","once","_this","didCall","apply","arguments","FIN","done","Iterator","iterator","next","_empty","empty","fromArray","elements","collect","getSequenceIterator","ArrayIterator","end","current","ArrayNavigator","super","max","MappedIterator","MappedNavigator","navigator","previous","parent","last","dispose","rest","d","isDisposable","thing","combinedDisposable","disposables","toDisposable","Disposable","_toDispose","_lifecycle_disposable_isDisposed","toDispose","console","warn","None","freeze","ReferenceCollection","references","reference","counter","object","createReferencedObject","functional_1","destroyReferencedObject","ImmortalReference","Node","LinkedList","_size","_first","_last","_insert","atTheEnd","newNode","oldLast","prev","oldFirst","_remove","bind","res","node","candidate","anchor","iterator_1","Event","event","thisArgs","didFire","snapshot","each","merge","initial","output","emitter","Emitter","fire","latch","cache","firstCall","shouldEmit","_disposable","signal","any","events","lifecycle_1","debounce","delay","leading","leakWarningThreshold","subscription","handle","numDebouncedCalls","cur","clearTimeout","_output","stopwatch","Date","getTime","_","buffer","nextTick","_buffer","flush","echo","ChainableEvent","chain","fromNodeEventEmitter","eventName","id","args","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromPromise","promise","toPromise","c","_globalLeakWarningThreshold","setGlobalLeakWarningThreshold","oldValue","LeakageMonitor","customThreshold","toString","_warnCountdown","_stacks","clear","listenerCount","threshold","Map","join","get","set","topStack","topCount","options","_disposed","_options","_leakageMon","_event","_listeners","linkedList_1","firstListener","isEmpty","remove","onFirstListenerDidAdd","onListenerDidAdd","removeMonitor","check","_noop","_deliveryQueue","iter","shift","AsyncEmitter","eventFn","_asyncDeliveryQueue","thenables","all","EventMultiplexer","hasListeners","hook","unhook","idx","EventBufferer","buffers","Relay","listening","inputEvent","inputEventListener","input","shortcutEvent","context","CancellationToken","isCancellationToken","Cancelled","MutableToken","onCancellationRequested","event_1","_isCancelled","_emitter","CancellationTokenSource","_token","cancel","isThenable","createCancelablePromise","source","cancellation_1","thenable","errors","onfinally","finally","timeout","millis","sequence","promiseFactories","thenHandler","results","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","Sequencer","promiseTask","Delayer","defaultDelay","completionPromise","doResolve","task","cancelTimeout","doReject","ThrottledDelayer","delayer","throttler","trigger","isTriggered","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","timer","ignoreErrors","shouldStop","defaultValue","loop","factory","Limiter","maxDegreeOfParalellism","outstandingPromises","runningPromises","_onFinished","onFinished","consume","iLimitedTask","consumed","Queue","ResourceQueue","queues","resource","TimeoutTimer","runner","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","isScheduled","doRun","RunOnceWorker","units","unit","schedule","nfcall","ninvoke","thisArg","requestIdleCallback","cancelIdleCallback","dummyIdle","didTimeout","timeRemaining","runWhenIdle","IdleValue","executor","_executor","_value","_error","_didRun","_handle","Schemas","inMemory","vscode","internal","walkThrough","walkThroughSnippet","http","https","file","mailto","untitled","command","LANGUAGE_DEFAULT","_isWindows","_isMacintosh","_isNative","_locale","_language","_translationsConfigFile","isElectronRenderer","process","versions","electron","type","platform","rawNlsConfig","env","nlsConfig","JSON","parse","resolved","availableLanguages","locale","userAgent","language","Platform","PlatformToString","isRealWindows","isWindows","isMacintosh","isLinux","isNative","isWeb","isRootUser","getuid","translationsConfigFile","_globals","self","global","globals","_setImmediate","setImmediate","OperatingSystem","OS","safeProcess","cwd","platform_1","validateString","ErrorInvalidArgType","isPathSeparator","code","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","isPosixPathSeparator","isWindowsDeviceRoot","CHAR_UPPERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_A","CHAR_LOWERCASE_Z","normalizeString","path","allowAboveRoot","separator","lastSegmentLength","lastSlash","dots","charCodeAt","CHAR_DOT","lastSlashIndex","lastIndexOf","_format","sep","pathObject","dir","root","base","ext","expected","actual","determiner","replace","msg","win32","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","toLowerCase","rootEnd","device","isAbsolute","firstPart","paths","joined","needsReplace","slashCount","firstLen","normalize","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","resolvedPath","matchedSlash","offset","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","delimiter","posix","trailingSeparator","toNamespacedPath","hasRoot","relative","dirname","basename","extname","format","hasPerformanceNow","performance","now","StopWatch","highResolution","_highResolution","_startTime","_now","_stopTime","escapeRegExpCharacters","ltrim","haystack","needle","needleLen","substring","rtrim","haystackLen","isLowerAsciiLetter","isUpperAsciiLetter","isAsciiLetter","doEqualsIgnoreCase","stopAt","codeA","codeB","diff","abs","fromCharCode","substrEquals","aStart","aEnd","bStart","bEnd","isFullWidthCharacter","charCode","startsWithUTF8BOM","str","isFalsyOrWhitespace","trim","pad","l","char","reverse","_formatRegexp","match","group","parseInt","isNaN","escape","html","convertSimple2RegExpPattern","pattern","stripWildcards","startsWith","endsWith","createRegExp","searchString","isRegex","wholeWord","test","charAt","modifiers","matchCase","multiline","unicode","RegExp","regExpLeadsToEndlessLoop","regexp","exec","lastIndex","regExpContainsBackreference","regexpValue","regExpFlags","ignoreCase","firstNonWhitespaceIndex","chCode","getLeadingWhitespace","lastNonWhitespaceIndex","startIndex","compareIgnoreCase","equalsIgnoreCase","startsWithIgnoreCase","candidateLength","commonSuffixLength","aLastIndex","bLastIndex","overlap","isHighSurrogate","isLowSurrogate","CONTAINS_RTL","containsRTL","CONTAINS_EMOJI","containsEmoji","IS_BASIC_ASCII","isBasicASCII","containsFullWidthCharacter","lcut","text","re","EL","COLOR_START","COLOR_END","removeAnsiEscapeCodes","removeAccents","regex","UTF8_BOM_CHARACTER","stripUTF8BOM","substr","safeBtoa","btoa","encodeURIComponent","repeat","s","fuzzyContains","query","queryLen","targetLower","containsUppercaseCharacter","ignoreEscapedChars","uppercaseFirstLetter","toUpperCase","getNLines","compareFileNames","caseSensitive","intlFileNameCollator","getValue","collator","collatorIsNumeric","noIntlCompareFileNames","oneName","oneExtension","extractNameAndExtension","otherName","otherExtension","compareFileExtensions","noIntlCompareFileExtensions","FileNameMatch","comparePathComponents","compareByPrefix","lookFor","elementAName","elementBName","elementAPrefixMatch","strings","elementBPrefixMatch","setFileNameComparer","comparePaths","oneParts","path_1","otherParts","lastOne","lastOther","endOne","endOther","compareAnything","prefixCompare","elementASuffixMatch","localeCompare","isWindowsDriveLetter","char0","toSlashes","osPath","getRoot","firstLetter","pos","isUNC","INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","isValidBasename","isEqual","pathA","pathB","identityEquals","strings_1","isEqualOrParent","sepOffset","_typeof","number","constructor","isString","string","isObject","isUndefined","isUndefinedOrNull","isFunction","function","validateConstraint","constraint","_a","isStringArray","every","isNumber","Number","isBoolean","isEmptyObject","areFunctions","objects","validateConstraints","constraints","ctor","isNativeClass","getAllPropertyNames","proto","getPrototypeOf","getOwnPropertyNames","withNullAsUndefined","withUndefinedAsNull","deepClone","keys","_cloneAndChange","changer","types_1","changed","r1","has","add","r2","i2","_hasOwnProperty","delete","mixin","destination","overwrite","oneKeys","otherKeys","deepFreeze","prop","isFrozen","cloneAndChange","Set","assign","sources","createKeywordMatcher","caseInsensitive","hash","arrayToHash","word","safeStringify","stringify","getOrDefault","k","baseValue","targetValue","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","escaped","encodeTable","_makeFsPath","uri","authority","scheme","_asFormatted","skipEncoding","encoder","fragment","_slash","userinfo","_schemePattern","_singleSlashStart","_doubleSlashStart","_throwOnMissingSchema","setUriThrowOnMissingScheme","old","_regexp","URI","fsPath","with","schemeOrData","_strict","trace","_schemeFix","_referenceResolution","_validateUri","change","_URI","decodeURIComponent","components","_fsPath","_formatted","external","$mid","58","47","63","35","91","93","64","33","36","38","39","40","41","42","43","44","59","61","32","getPathFromAmdModule","requirefn","relativePath","uri_1","toUrl","forEachable","getOrSet","mapToString","entries","setToString","mapToSerializable","serializable","serializableToMap","StringIterator","_pos","PathIterator","_from","_to","justSeps","ch","aPos","aLen","thisPos","cmp","TernarySearchTreeNode","left","right","TernarySearchTree","segments","_iter","_root","reset","segment","val","hasNext","oldElement","_nodeIterator","_forEach","ResourceMap","toKey","clb","resourceMap","Touch","LinkedMap","_map","_head","_tail","touch","addItemLast","addItemFirst","removeItem","callbackfn","newSize","currentSize","LRUCache","limit","ratio","_limit","_ratio","checkTrim","trimOld","round","or","wordToMatchAgainst","_matchesPrefix","matches","matchesContiguousSubString","matchesSubString","_matchesSubString","isLower","isUpper","isWhitespace","isAlphanumeric","head","nextAnchor","camelCaseWord","_matchesCamelCase","nextUpperIndex","matchesCamelCase","upper","lower","whitespace","isCamelCasePattern","analysis","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","analyzeCamelCaseWord","isCamelCaseWord","isUpperCaseWord","_matchesWords","contiguous","nextWordIndex","nextWord","createMatches","score","_maxLen","initTable","table","row","thisRow","printTable","patternLen","wordLen","isSeparatorAtPos","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","fuzzyScore","patternLow","patternPos","wordPos","firstMatchCanBeWeak","isPatternInWord","patternStartPos","wordStartPos","_scores","diag","_table","_arrows","_debug","log","_matchesCount","_topScore","_patternStartPos","_firstMatchCanBeWeak","_findAllMatches2","_topMatch2","total","lastMatched","simpleMatchCount","arrow","pow","fuzzyScoreWithPermutations","lowPattern","lowWord","aggressive","tries","movingPatternPos","newPattern","swap1","swap2","nextTypoPermutation","matchesStrictPrefix","matchesPrefix","matchesWords","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","map_1","matchesFuzzy","enableSeparateSubstringMatching","matchesFuzzy2","anyScore","_patternPos","_wordPos","Arrow","FuzzyScore","Default","isDefault","fuzzyScoreGracefulAggressive","fuzzyScoreGraceful","starsToRegExp","starCount","NO_PATH_REGEX","PATH_REGEX","splitGlobAware","splitChar","inBraces","inBrackets","curVal","parseRegExp","regEx","GLOB_SPLIT","GLOBSTAR","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","parsePattern","arg1","NULL","patternKey","trimForExclusions","parsedPattern","CACHE","wrapRelativePattern","T1","T2","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","T3_2","T3","parsedPatterns","aggregateBasenameMatches","withBasenames","arrays","allPaths","trivia3","T4","trivia4and5","T5","regExp","toRegExp","arg2","extpath","matchPathEnds","nativePath","ALL_FORWARD_SLASHES","nativePathEnd","FALSE","isRelativePattern","resultPattern","expression","when","hasSibling","clausePattern","matched","async_1","requiresSiblings","parseExpressionPattern","some","resultExpression","parsedExpression","listToMap","list","rp","basenamePatterns","aggregate","aggregatedPatterns","getEmptyExpression","hasSiblingPromiseFn","siblingsFn","siblings","hasSiblingFn","parseToAsync","getBasenameTerms","patternOrExpression","getPathTerms","form","normalizedCache","canNormalize","cached","nonAsciiCharactersPattern","nfcCache","normalizeNFC","nfdCache","normalizeNFD","hasToIgnoreCase","network_1","parentCandidate","originalFSPath","isEqualAuthority","a1","a2","uriPath","hasTrailingPathSeparator","fsp","getComparisonKey","basenameOrAuthority","second","p1","p2","joinPath","pathFragment","joinedPath","normalizePath","normalizedPath","isAbsolutePath","removeTrailingPathSeparator","resolvePath","distinctParents","resourceAccessor","candidateResource","otherItem","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","property","mime","ResourceGlobMatcher","globalExpression","rootExpressions","expressionsByRoot","forPaths","glob_1","rootExpression","findSubstr","v4","V4UUID","isUUID","_UUIDPattern","ValueUUID","_randomHex","_oneOf","_timeHighBits","_chars","generateUuid","asHex","entry","parsedArguments","stackArgument","__$stack","getFirstFrame","arg0","topFrame","findFirstFrame","line","column","newlineIndex","color","isRemoteConsoleLog","severity","label","isOneStringArg","consoleArgs","LineDecoder","encoding","stringDecoder","sd","StringDecoder","remaining","write","lastChar","param","assert","looper","sequences","sequenceResult","sequenceFunction","Sequence","parallel","didErrorOccur","doneCount","readExactlyByFile","totalBytes","fs","open","fd","resultBuffer","bytesRead","close","closeError","readChunk","read","Buffer","allocUnsafe","readToMatchingString","matchingString","chunkBytes","maximumBytesToRead","newLineIndex","decodeStream","iconv","toNodeEncoding","enc","UTF8_with_bom","UTF8","detectEncodingByBOMFromBuffer","b0","readUInt8","b1","UTF16be","UTF16le","b2","guessEncodingByBuffer","resolve_1","reject_1","require","jschardet","Constants","MINIMUM_THRESHOLD","guessed","detect","IGNORE_ENCODINGS","toIconvLiteEncoding","encodingName","normalizedEncodingName","JSCHARDET_TO_ICONV_ENCODINGS","detectEncodingFromBuffer","autoGuessEncoding","seemsBinary","couldBeUTF16LE","couldBeUTF16BE","containsZeroByte","ZERO_BYTE_DETECTION_BUFFER_MAX_LEN","isEndian","isZeroByte","readInt8","guessedEncoding","toDecodeStream","readable","minBytesRequiredForDetection","guessEncoding","AUTO_GUESS_BUFFER_MAX_LEN","NO_GUESS_BUFFER_MAX_LEN","overwriteEncoding","detected","pipe","stream_1","Writable","_bytesBuffered","chunk","isBuffer","_decodeStream","_decodeStreamConstruction","_startDecodeStream","stream","bomLength","decode","encode","content","encodingExists","encodeStream","detectEncodingByBOM","ibm866","big5","toCanonicalName","windowsTerminalEncodings","437","850","852","855","857","860","861","863","865","866","869","936","1252","resolveTerminalEncoding","verbose","rawEncodingPromise","cliEncodingEnv","child_process_1","stdout","stderr","windowsTerminalEncodingKeys","rawEncoding","iconvEncoding","readdirSync","normalization_1","readdir","children","copy","copiedSourcesIn","copiedSources","stat","isDirectory","mode","reader","createReadStream","writer","createWriteStream","finished","finish","chmod","doCopyFile","proceed","files","mkdirp","mkdir","mkdirErr","statErr","rmRecursive","exists","lstat","isSymbolicLink","unlink","rmdir","firstError","childrenLeft","child","delSync","lstatSync","rmdirSync","unlinkSync","writeFileAndFlush","ensureOptions","encoding_1","charset","addBOM","canFlush","writeFile","flag","openError","writeError","fdatasync","syncError","doWriteFileAndFlush","isBrowser","isOpen","destroy","flags","autoClose","descriptor","doWriteFileStreamAndFlush","ensuredOptions","realcaseSync","found","prefix","ix","flow","statLink","del","tmpFolder","pathInTemp","uuid","rename","mv","updateMtime","futimes","atime","writeFileAndFlushSync","writeFileSync","openSync","fdatasyncSync","closeSync","realpathSync","accessSync","constants","R_OK","realpath","access","watch","onChange","onError","watcher","raw","removeAllListeners","sanitizeFilePath","createSizeBuffer","writeUInt32BE","readSizeBuffer","readUInt32BE","serialize","BufferPresets","Undefined","el","deserialize","DataType","getDelayedChannel","cancellationToken","relay","listen","RequestType","ResponseType","State","BufferReader","bytes","BufferWriter","alloc","ChannelServer","protocol","ctx","channels","activeRequests","protocolListener","onMessage","onRawMessage","sendResponse","channelName","channel","response","send","header","body","sendBuffer","onPromise","onEventListen","disposeActiveRequest","request","cancellationTokenSource","disposable","ChannelClient","state","Uninitialized","handlers","lastRequestId","_onDidInitialize","onDidInitialize","onBuffer","that","requestPromise","requestEvent","uninitializedPromise","whenInitialized","sendRequest","cancellationTokenListener","onResponse","Idle","IPCServer","onDidClientConnect","_connections","_onDidChangeConnections","onDidChangeConnections","onDidClientDisconnect","onFirstMessage","channelServer","channelClient","registerChannel","connection","connections","router","routeCall","getChannel","routeEvent","IPCClient","getNextTickChannel","didTick","StaticRouter","hub","route","queryLower","fuzzy","NO_SCORE","targetLength","queryLength","scores","queryIndex","queryIndexOffset","queryIndexPreviousOffset","queryIndexGtNull","queryCharAtIndex","queryLowerCharAtIndex","targetIndex","targetIndexGtNull","currentIndex","diagIndex","leftScore","diagScore","matchesSequenceLength","separatorBonus","scoreSeparatorAtPos","filters_1","computeCharScore","NO_MATCH","positions","doScore","scoreItem","accessor","NO_ITEM_SCORE","getItemLabel","description","getItemDescription","cacheHash","itemScore","PATH_IDENTITY_SCORE","labelMatch","descriptionMatch","containsPathSeparator","prefixLabelMatch","LABEL_PREFIX_SCORE","camelcaseLabelMatch","LABEL_CAMELCASE_SCORE","labelScore","labelPositions","lowercase","LABEL_SCORE_THRESHOLD","descriptionPrefix","descriptionPrefixLength","descriptionAndLabel","labelDescriptionScore","labelDescriptionPositions","h","doScoreItem","getItemPath","offsets","computeLabelAndDescriptionMatchDistance","matchStart","matchEnd","itemDescription","fallbackCompare","itemA","itemB","labelA","labelB","descriptionA","descriptionB","labelDescriptionALength","labelDescriptionBLength","comparers_1","prepareQuery","compareItemsByScore","fallbackComparer","itemScoreA","itemScoreB","scoreA","scoreB","comparedByMatchLength","matchesA","matchesB","matchStartA","matchLengthA","matchStartB","matchLengthB","compareByMatchLength","itemAMatchDistance","itemBMatchDistance","define","nls","exceptionToErrorMessage","exception","localize","detectSystemErrorMessage","errno","syscall","toErrorMessage","types","detail","terminateProcess","stdio","cp","execFileSync","pid","success","status","getWindowsCode","cmd","amd_1","spawnSync","kill","getWindowsShell","AbstractProcess","arg3","arg4","shell","executable","isShellCommand","childProcess","terminateRequested","newEnv","WellKnowCommands","pp","useExec","cc","ee","killed","handleExec","Objects","windowsVerbatimArguments","detached","quotedCommand","quotedArg","commandLine","quoted","ensureQuotes","spawn","childProcessPromise","pidResolve","Types","terminated","handleClose","cmdCode","handleSpawn","cmdShell","ant","cmake","eslint","gradle","grunt","gulp","jake","jenkins","jshint","make","maven","msbuild","msc","nmake","npm","rake","tsc","xbuild","LineProcess","lineDecoder","decoder_1","sync","stdoutLineDecoder","stderrLineDecoder","createQueuedSender","msgQueue","useQueue","msgQueueCopy","findExecutable","PATH","pathEntry","fullPath","existsSync","withExtension","Server","ipc_1","Client","modulePath","_onDidProcessExit","onDidProcessExit","disposeDelayer","_client","getCachedChannel","disposeClient","client","forkOpts","objects_1","VSCODE_PARENT_PID","freshExecArgv","execArgv","debug","debugBrk","fork","onMessageEmitter","console_1","serverName","sender","processes_1","connected","onExit","MAX_FILE_SIZE","arch","MAX_HEAP_SIZE","storeServiceDependency","optional","_util","DI_TARGET","DI_DEPENDENCIES","createDecorator","serviceId","serviceIds","getServiceDependencies","IInstantiationService","serviceIdentifier","toISOString","ILogService","instantiation_1","LogLevel","DEFAULT_LOG_LEVEL","Info","AbstractLogService","level","_onDidChangeLogLevel","_register","onDidChangeLogLevel","ConsoleLogMainService","logLevel","setLevel","useColors","getLevel","Trace","Debug","Warning","Critical","ConsoleLogService","MultiplexLogService","logServices","logService","info","critical","DelegatedLogService","NullLogService","getLogLevel","environmentService","Off","RegistryImpl","Assert","Registry","TEST_VIEW_CONTAINER_ID","Extensions","ViewContainersRegistry","ViewsRegistry","ViewContainer","hideIfEmpty","extensionId","ViewContainersRegistryImpl","_onDidRegister","onDidRegister","_onDidDeregister","onDidDeregister","viewContainers","existing","viewContainer","_onViewsRegistered","onViewsRegistered","_onViewsDeregistered","onViewsDeregistered","_onDidChangeContainer","onDidChangeContainer","_viewContainers","_views","views","addViews","viewDescriptors","removeViews","viewsToMove","container","loc","viewDescriptor","v","viewId","nls_1","viewsToDeregister","remaningViews","view","IViewsService","TreeItemCollapsibleState","VIEWLET_ID","PANEL_ID","VIEW_ID","VIEW_CONTAINER","as","views_1","registerViewContainer","ISearchService","SearchProviderType","QueryType","resultIsMatch","preview","FileMatch","TextSearchMatch","previewOptions","ranges","matchLines","leadingChars","charsPerLine","previewStart","startColumn","previewText","endColInPreview","endLineNumber","startLineNumber","endColumn","OneLineRange","firstMatchLine","arrays_1","SearchRange","lineNumber","getExcludes","configuration","includeSearchExcludes","fileExcludes","exclude","searchExcludes","search","allExcludes","pathIncludedInQuery","queryProps","excludePattern","glob","includePattern","usingSearchPaths","folderQueries","fq","searchPath","folder","SearchErrorCode","SearchError","deserializeSearchError","errorMsg","details","serializeSearchError","searchError","isSerializedSearchComplete","isSerializedSearchSuccess","isSerializedFileMatch","SerializableFileMatch","numMatches","resolvePatternsForProvider","globalPattern","folderPattern","merged","QueryGlobTester","config","folderQuery","_excludeExpression","_parsedExcludeExpression","includeExpression","_parsedIncludeExpression","testPath","excluded","included","hasSiblingClauses","rangeToSearchRange","search_1","character","searchRangeToRange","Range","anchorGlob","createTextSearchResult","searchRange","internalResult","internalPreviewRange","Position","_2","startLine","startCol","endLine","endCol","positionOrRange","OutputChannel","__decorate","__param","log_1","SearchChannel","service","fileSearch","textSearch","clearCache","SearchChannelClient","cacheKey","extensionResultIsMatch","TextSearchManager","provider","_extfs","extfs","resultCount","onProgress","tokenSource","collector","TextSearchResultsCollector","isCanceled","searchInFolder","folderIdx","isLimitHit","resultSize","maxResults","trimResultToSize","newResultSize","onResult","someFolderHitLImit","limitHit","stats","errMsg","errorMessage_1","rangesArr","matchesArr","queryTester","testingPs","progress","report","validateProviderResult","includedInQuery","searchOptions","getSearchOptionsForFolder","provideTextSearchResults","patternInfo","isCaseSensitive","isRegExp","isWordMatch","isMultiline","patternInfoToQuery","contentPattern","includes","excludes","useIgnoreFiles","disregardIgnoreFiles","useGlobalIgnoreFiles","disregardGlobalIgnoreFiles","followSymlinks","ignoreSymlinks","fileEncoding","maxFileSize","afterContext","beforeContext","usePCRE2","_onResult","_currentFileMatch","_batchedCollector","BatchedCollector","sendItems","_currentFolderIdx","resources","_currentUri","pushToCollector","extensionResultToFrontendResult","addItem","maxBatchSize","cb","totalNumberCompleted","batchSize","addItemToBatch","addItemsToBatch","onUpdate","START_BATCH_AFTER_COUNT","timeoutHandle","TIMEOUT","spawnRipgrepCmd","rgArgs","foldersToIncludeGlobs","globArg","inclusion","ripgrepSearchUtils_1","normalized","rgGlobs","foldersToRgExcludeGlobs","globArgs","exclusion","siblingClauses","getRgArgs","rgDiskPath","globalExclude","excludesToSkip","absoluteGlobs","globExprsToRgGlobs","globalInclude","trimTrailingSlash","getAbsoluteGlob","fixDriveC","vscode_ripgrep_1","rgPath","rgErrorMsgForDisplay","lines","firstLine","killCmds","FileWalker","filePattern","walkedPaths","directoriesWalked","filesWalked","normalizedFilePatternLowercase","globalExcludePattern","folderExcludePatterns","folderExcludeExpression","fqPath","rootFolderQuery","rootFolder","otherRootFolder","extpath_1","AbsoluteAndRelativeParsedExpression","extraFiles","fileWalkSW","stopwatch_1","extraFilePath","matchFile","cmdSW","rootFolderDone","cmdTraversal","errorMessage","stop","fun","isMac","killCmd","leftover","tree","initDirectoryTree","noSiblingsClauses","ripgrep","ripgrepFileSearch_1","rgCmd","cmdResultCount","collectStdout","relativeFiles","normalization","addDirectoryEntries","matchDirectoryTree","pathTerms","onData","gotData","forwardData","collectData","stderrText","decodeData","decoder","string_decoder_1","rootEntries","pathToEntries","matchDirectory","sub","cmdTime","elapsed","fileWalkTime","relativeParentPath","currentRelativePath","currentAbsolutePath","statLinkIfNeeded","realPathIfNeeded","doWalk","maxFilesize","isFilePatternMatch","Engine","extraFileResources","walker","walk","getStats","init","expr","absoluteGlobExpr","relativeGlobExpr","absoluteParsedExpr","relativeParsedExpr","_path","basenameTerms","regexParseError","unknownEncoding","globParseError","invalidLiteral","bytesOrTextToString","spreadGlobComponents","unicodeEscapesToPCRE2","reg","fixRegexEndingPattern","fixRegexNewline","fixRegexCRMatchingWhitespaceClass","fixRegexCRMatchingNonWordClass","fixNewline","RipgrepTextSearchEngine","outputChannel","appendLine","doubleStarIncludes","otherIncludes","collections_1","include","uniqueOthers","otherIncude","rgGlob","searchPatternAfterDoubleDashes","regexpStr","fixedRegexpQuery","escapedArgs","rgProc","rgProcessError","gotResult","ripgrepParser","RipgrepParser","isDone","handleData","events_1","EventEmitter","remainder","hitLimit","numResults","handleDecodedData","dataStr","decodedData","newlineIdx","prevIdx","handleLine","outputLine","parsedLine","matchPath","createTextSearchMatch","contextPath","createTextSearchContext","line_number","isBOMStripped","fullText","fullTextBytes","prevMatchEnd","prevMatchEndCol","prevMatchEndLine","submatches","matchText","inBetweenChars","numLines","lastNewlineIdx","lastLineLength","getNumLinesAndLastNewlineLength","fileMatchToSerialized","sum","TextSearchEngineAdapter","pretendOutputChannel","textSearchManager","textSearchManager_1","ripgrepTextSearchEngine_1","reviveQuery","rawQuery","reviveFolderQuery","revive","rawFolderQuery","SearchService","caches","doFileSearchWithEngine","fileSearch_1","ripgrepTextSearch","progressCallback","files_1","textSearchAdapter_1","EngineClass","BATCH_SIZE","fileProgressCallback","rawMatchToSearchItem","sortByScore","sortedSearch","trySortedSearchFromCache","engine","doSortedSearch","rawMatches","serializedMatches","rawMatch","sendProgress","doSearch","complete","detailStats","fromCache","sortingTime","allResultsPromise","getOrCreateCache","cacheRow","resultsToSearchCache","preventCancellation","scorerCache","sortSW","sortResults","sortedResults","workspaceFolderCount","Cache","getResultsFromCache","cacheStats","quickOpenScorer_1","MAX_VALUE","matchA","matchB","FileMatchItemAccessor","progressCb","searchValue","cacheLookupSW","hasPathSep","cachedRow","previousSearch","cacheLookupTime","cacheFilterSW","cachedEntries","normalizedSearchValueLowercase","cacheWasResolved","cacheFilterTime","cacheEntryCount","onFinally","server","ipc_cp_1","rawSearchService_1","searchIpc_1"],"mappings":"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","file":"searchApp.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n */\nexport function ok(value?: any, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are strings.\n */\nexport interface IStringDictionary<V> {\n\t[name: string]: V;\n}\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are numbers.\n */\nexport interface INumberDictionary<V> {\n\t[idx: number]: V;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Returns an array which contains all values that reside\n * in the given set.\n */\nexport function values<T>(from: IStringDictionary<T> | INumberDictionary<T>): T[] {\n\tconst result: T[] = [];\n\tfor (let key in from) {\n\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\tresult.push((from as any)[key]);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function size<T>(from: IStringDictionary<T> | INumberDictionary<T>): number {\n\tlet count = 0;\n\tfor (let key in from) {\n\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn count;\n}\n\nexport function first<T>(from: IStringDictionary<T> | INumberDictionary<T>): T | undefined {\n\tfor (let key in from) {\n\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\treturn from[key];\n\t\t}\n\t}\n\treturn undefined;\n}\n\n/**\n * Iterates over each entry in the provided set. The iterator allows\n * to remove elements and will stop when the callback returns {{false}}.\n */\nexport function forEach<T>(from: IStringDictionary<T> | INumberDictionary<T>, callback: (entry: { key: any; value: T; }, remove: () => void) => any): void {\n\tfor (let key in from) {\n\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\tconst result = callback({ key: key, value: (from as any)[key] }, function () {\n\t\t\t\tdelete (from as any)[key];\n\t\t\t});\n\t\t\tif (result === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nexport function groupBy<T>(data: T[], groupFn: (element: T) => string): IStringDictionary<T[]> {\n\tconst result: IStringDictionary<T[]> = Object.create(null);\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result[key];\n\t\tif (!target) {\n\t\t\ttarget = result[key] = [];\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function fromMap<T>(original: Map<string, T>): IStringDictionary<T> {\n\tconst result: IStringDictionary<T> = Object.create(null);\n\tif (original) {\n\t\toriginal.forEach((value, key) => {\n\t\t\tresult[key] = value;\n\t\t});\n\t}\n\treturn result;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\tpublic addListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tpublic setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tpublic getUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tpublic onUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tpublic onUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tlet { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): any;\n\tgetTypeName(): string;\n\tgetFunction(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string;\n\tgetLineNumber(): number;\n\tgetColumnNumber(): number;\n\tgetEvalOrigin(): string;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error: any): boolean {\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function disposed(what: string): Error {\n\tconst result = new Error(`${what} has been disposed`);\n\tresult.name = 'DISPOSED';\n\treturn result;\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { canceled } from 'vs/base/common/errors';\nimport { ISplice } from 'vs/base/common/sequence';\n\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail<T>(array: ArrayLike<T>, n: number = 0): T {\n\treturn array[array.length - (1 + n)];\n}\n\nexport function tail2<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\tlet low = 0,\n\t\thigh = array.length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = comparator(array[mid], key);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted<T>(array: ReadonlyArray<T>, p: (x: T) => boolean): number {\n\tlet low = 0, high = array.length;\n\tif (high === 0) {\n\t\treturn 0; // no children\n\t}\n\twhile (low < high) {\n\t\tconst mid = Math.floor((low + high) / 2);\n\t\tif (p(array[mid])) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn low;\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n/**\n * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`\n * so only use this when actually needing stable sort.\n */\nexport function mergeSort<T>(data: T[], compare: Compare<T>): T[] {\n\t_sort(data, compare, 0, data.length - 1, []);\n\treturn data;\n}\n\nfunction _merge<T>(a: T[], compare: Compare<T>, lo: number, mid: number, hi: number, aux: T[]): void {\n\tlet leftIdx = lo, rightIdx = mid + 1;\n\tfor (let i = lo; i <= hi; i++) {\n\t\taux[i] = a[i];\n\t}\n\tfor (let i = lo; i <= hi; i++) {\n\t\tif (leftIdx > mid) {\n\t\t\t// left side consumed\n\t\t\ta[i] = aux[rightIdx++];\n\t\t} else if (rightIdx > hi) {\n\t\t\t// right side consumed\n\t\t\ta[i] = aux[leftIdx++];\n\t\t} else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {\n\t\t\t// right element is less -> comes first\n\t\t\ta[i] = aux[rightIdx++];\n\t\t} else {\n\t\t\t// left element comes first (less or equal)\n\t\t\ta[i] = aux[leftIdx++];\n\t\t}\n\t}\n}\n\nfunction _sort<T>(a: T[], compare: Compare<T>, lo: number, hi: number, aux: T[]) {\n\tif (hi <= lo) {\n\t\treturn;\n\t}\n\tconst mid = lo + ((hi - lo) / 2) | 0;\n\t_sort(a, compare, lo, mid, aux);\n\t_sort(a, compare, mid + 1, hi, aux);\n\tif (compare(a[mid], a[mid + 1]) <= 0) {\n\t\t// left and right are sorted and if the last-left element is less\n\t\t// or equals than the first-right element there is nothing else\n\t\t// to do\n\t\treturn;\n\t}\n\t_merge(a, compare, lo, mid, hi, aux);\n}\n\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of mergeSort(data.slice(0), compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[], added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // nextTick() would starve I/O.\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow canceled();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstInSorted(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns a new array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: Array<T | undefined | null>): T[] {\n\tif (!array) {\n\t\treturn array;\n\t}\n\treturn <T[]>array.filter(e => !!e);\n}\n\n/**\n * Remove all falsey values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): void {\n\tif (!array) {\n\t\treturn;\n\t}\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * Moves the element in the array for the provided positions.\n */\nexport function move(array: any[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: any): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: ReadonlyArray<T> | undefined | null): obj is Array<T> {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn?: (t: T) => string): T[] {\n\tif (!keyFn) {\n\t\treturn array.filter((element, position) => {\n\t\t\treturn array.indexOf(element) === position;\n\t\t});\n\t}\n\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\treturn array.filter((elem) => {\n\t\tconst key = keyFn(elem);\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T>(keyFn: (t: T) => string): (t: T) => boolean {\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\t\treturn true;\n\t};\n}\n\nexport function firstIndex<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean): number {\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst element = array[i];\n\n\t\tif (fn(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean, notFoundValue: T): T;\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean): T | null;\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean, notFoundValue: T | null): T | null;\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean, notFoundValue: T | null = null): T | null {\n\tconst index = firstIndex(array, fn);\n\treturn index < 0 ? notFoundValue : array[index];\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function flatten<T>(arr: T[][]): T[] {\n\treturn (<T[]>[]).concat(...arr);\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function fill<T>(num: number, value: T, arr: T[] = []): T[] {\n\tfor (let i = 0; i < num; i++) {\n\t\tarr[i] = value;\n\t}\n\n\treturn arr;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, merger?: (t: T, r: R) => R): { [key: string]: R; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, merger: (t: T, r: R) => R = t => t as any): { [key: string]: R; } {\n\treturn array.reduce((r, t) => {\n\t\tconst key = indexer(t);\n\t\tr[key] = merger(t, r[key]);\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => {\n\t\tconst index = array.indexOf(element);\n\t\tif (index > -1) {\n\t\t\tarray.splice(index, 1);\n\t\t}\n\t};\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function find<T>(arr: ArrayLike<T>, predicate: (value: T, index: number, arr: ArrayLike<T>) => any): T | undefined {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst element = arr[i];\n\t\tif (predicate(element, i, arr)) {\n\t\t\treturn element;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function once<T extends Function>(this: any, fn: T): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: any;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tresult = fn.apply(_this, arguments);\n\n\t\treturn result;\n\t} as any as T;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IteratorDefinedResult<T> {\n\treadonly done: false;\n\treadonly value: T;\n}\nexport interface IteratorUndefinedResult {\n\treadonly done: true;\n\treadonly value: undefined;\n}\nexport const FIN: IteratorUndefinedResult = { done: true, value: undefined };\nexport type IteratorResult<T> = IteratorDefinedResult<T> | IteratorUndefinedResult;\n\nexport interface Iterator<T> {\n\tnext(): IteratorResult<T>;\n}\n\nexport module Iterator {\n\tconst _empty: Iterator<any> = {\n\t\tnext() {\n\t\t\treturn FIN;\n\t\t}\n\t};\n\n\texport function empty<T>(): Iterator<T> {\n\t\treturn _empty;\n\t}\n\n\texport function fromArray<T>(array: T[], index = 0, length = array.length): Iterator<T> {\n\t\treturn {\n\t\t\tnext(): IteratorResult<T> {\n\t\t\t\tif (index >= length) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\treturn { done: false, value: array[index++] };\n\t\t\t}\n\t\t};\n\t}\n\n\texport function from<T>(elements: Iterator<T> | T[] | undefined): Iterator<T> {\n\t\tif (!elements) {\n\t\t\treturn Iterator.empty();\n\t\t} else if (Array.isArray(elements)) {\n\t\t\treturn Iterator.fromArray(elements);\n\t\t} else {\n\t\t\treturn elements;\n\t\t}\n\t}\n\n\texport function map<T, R>(iterator: Iterator<T>, fn: (t: T) => R): Iterator<R> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tconst element = iterator.next();\n\t\t\t\tif (element.done) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t} else {\n\t\t\t\t\treturn { done: false, value: fn(element.value) };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function filter<T>(iterator: Iterator<T>, fn: (t: T) => boolean): Iterator<T> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst element = iterator.next();\n\t\t\t\t\tif (element.done) {\n\t\t\t\t\t\treturn FIN;\n\t\t\t\t\t}\n\t\t\t\t\tif (fn(element.value)) {\n\t\t\t\t\t\treturn { done: false, value: element.value };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function forEach<T>(iterator: Iterator<T>, fn: (t: T) => void): void {\n\t\tfor (let next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\tfn(next.value);\n\t\t}\n\t}\n\n\texport function collect<T>(iterator: Iterator<T>): T[] {\n\t\tconst result: T[] = [];\n\t\tforEach(iterator, value => result.push(value));\n\t\treturn result;\n\t}\n}\n\nexport type ISequence<T> = Iterator<T> | T[];\n\nexport function getSequenceIterator<T>(arg: Iterator<T> | T[]): Iterator<T> {\n\tif (Array.isArray(arg)) {\n\t\treturn Iterator.fromArray(arg);\n\t} else {\n\t\treturn arg;\n\t}\n}\n\nexport interface INextIterator<T> {\n\tnext(): T | null;\n}\n\nexport class ArrayIterator<T> implements INextIterator<T> {\n\n\tprivate items: T[];\n\tprotected start: number;\n\tprotected end: number;\n\tprotected index: number;\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tthis.items = items;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.index = index;\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic next(): T | null {\n\t\tthis.index = Math.min(this.index + 1, this.end);\n\t\treturn this.current();\n\t}\n\n\tprotected current(): T | null {\n\t\tif (this.index === this.start - 1 || this.index === this.end) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.items[this.index];\n\t}\n}\n\nexport class ArrayNavigator<T> extends ArrayIterator<T> implements INavigator<T> {\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tsuper(items, start, end, index);\n\t}\n\n\tpublic current(): T | null {\n\t\treturn super.current();\n\t}\n\n\tpublic previous(): T | null {\n\t\tthis.index = Math.max(this.index - 1, this.start - 1);\n\t\treturn this.current();\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic last(): T | null {\n\t\tthis.index = this.end - 1;\n\t\treturn this.current();\n\t}\n\n\tpublic parent(): T | null {\n\t\treturn null;\n\t}\n}\n\nexport class MappedIterator<T, R> implements INextIterator<R> {\n\n\tconstructor(protected iterator: INextIterator<T>, protected fn: (item: T | null) => R) {\n\t\t// noop\n\t}\n\n\tnext() { return this.fn(this.iterator.next()); }\n}\n\nexport interface INavigator<T> extends INextIterator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tparent(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport class MappedNavigator<T, R> extends MappedIterator<T, R> implements INavigator<R> {\n\n\tconstructor(protected navigator: INavigator<T>, fn: (item: T) => R) {\n\t\tsuper(navigator, fn);\n\t}\n\n\tcurrent() { return this.fn(this.navigator.current()); }\n\tprevious() { return this.fn(this.navigator.previous()); }\n\tparent() { return this.fn(this.navigator.parent()); }\n\tfirst() { return this.fn(this.navigator.first()); }\n\tlast() { return this.fn(this.navigator.last()); }\n\tnext() { return this.fn(this.navigator.next()); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable><any>thing).dispose === 'function'\n\t\t&& (<IDisposable><any>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(...disposables: Array<T | undefined>): T[];\nexport function dispose<T extends IDisposable>(disposables: T[]): T[];\nexport function dispose<T extends IDisposable>(first: T | T[], ...rest: T[]): T | T[] | undefined {\n\tif (Array.isArray(first)) {\n\t\tfirst.forEach(d => d && d.dispose());\n\t\treturn [];\n\t} else if (rest.length === 0) {\n\t\tif (first) {\n\t\t\tfirst.dispose();\n\t\t\treturn first;\n\t\t}\n\t\treturn undefined;\n\t} else {\n\t\tdispose(first);\n\t\tdispose(rest);\n\t\treturn [];\n\t}\n}\n\nexport function combinedDisposable(disposables: IDisposable[]): IDisposable {\n\treturn { dispose: () => dispose(disposables) };\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn { dispose() { fn(); } };\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected _toDispose: IDisposable[] = [];\n\tprotected get toDispose(): IDisposable[] { return this._toDispose; }\n\n\tprivate _lifecycle_disposable_isDisposed = false;\n\n\tpublic dispose(): void {\n\t\tthis._lifecycle_disposable_isDisposed = true;\n\t\tthis._toDispose = dispose(this._toDispose);\n\t}\n\n\tprotected _register<T extends IDisposable>(t: T): T {\n\t\tif (this._lifecycle_disposable_isDisposed) {\n\t\t\tconsole.warn('Registering disposable on object that has already been disposed.');\n\t\t\tt.dispose();\n\t\t} else {\n\t\t\tthis._toDispose.push(t);\n\t\t}\n\n\t\treturn t;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate references: { [key: string]: { readonly object: T; counter: number; } } = Object.create(null);\n\n\tconstructor() { }\n\n\tacquire(key: string): IReference<T> {\n\t\tlet reference = this.references[key];\n\n\t\tif (!reference) {\n\t\t\treference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tdelete this.references[key];\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterator, IteratorResult, FIN } from 'vs/base/common/iterator';\n\nclass Node<E> {\n\telement: E;\n\tnext: Node<E> | undefined;\n\tprev: Node<E> | undefined;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> | undefined;\n\tprivate _last: Node<E> | undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._first;\n\t}\n\n\tclear(): void {\n\t\tthis._first = undefined;\n\t\tthis._last = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (!this._first) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last!;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\t\treturn this._remove.bind(this, newNode);\n\t}\n\n\n\tshift(): E | undefined {\n\t\tif (!this._first) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (!this._last) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tlet candidate: Node<E> | undefined = this._first;\n\t\twhile (candidate instanceof Node) {\n\t\t\tif (candidate !== node) {\n\t\t\t\tcandidate = candidate.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (candidate.prev && candidate.next) {\n\t\t\t\t// middle\n\t\t\t\tconst anchor = candidate.prev;\n\t\t\t\tanchor.next = candidate.next;\n\t\t\t\tcandidate.next.prev = anchor;\n\n\t\t\t} else if (!candidate.prev && !candidate.next) {\n\t\t\t\t// only node\n\t\t\t\tthis._first = undefined;\n\t\t\t\tthis._last = undefined;\n\n\t\t\t} else if (!candidate.next) {\n\t\t\t\t// last\n\t\t\t\tthis._last = this._last!.prev!;\n\t\t\t\tthis._last.next = undefined;\n\n\t\t\t} else if (!candidate.prev) {\n\t\t\t\t// first\n\t\t\t\tthis._first = this._first!.next!;\n\t\t\t\tthis._first.prev = undefined;\n\t\t\t}\n\n\t\t\t// done\n\t\t\tthis._size -= 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\titerator(): Iterator<E> {\n\t\tlet element: { done: false; value: E; };\n\t\tlet node = this._first;\n\t\treturn {\n\t\t\tnext(): IteratorResult<E> {\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\tif (!element) {\n\t\t\t\t\telement = { done: false, value: node.element };\n\t\t\t\t} else {\n\t\t\t\t\telement.value = node.element;\n\t\t\t\t}\n\t\t\t\tnode = node.next;\n\t\t\t\treturn element;\n\t\t\t}\n\t\t};\n\t}\n\n\ttoArray(): E[] {\n\t\tconst result: E[] = [];\n\t\tfor (let node = this._first; node instanceof Node; node = node.next) {\n\t\t\tresult.push(node.element);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { combinedDisposable, Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n}\n\nexport namespace Event {\n\tconst _disposable = { dispose() { } };\n\texport const None: Event<any> = function () { return _disposable; };\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event and a `map` function, returns another event which maps each element\n\t * throught the mapping function.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n\t}\n\n\t/**\n\t * Given an event and an `each` function, returns another identical event and calls\n\t * the `each` function per each element.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n\t}\n\n\t/**\n\t * Given an event and a `filter` function, returns another event which emits those\n\t * elements for which the `filter` function returns `true`.\n\t */\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * Given an event and a `merge` function, returns another event which maps each element\n\t * and the cummulative result throught the `merge` function. Similar to `map`, but with memory.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Given a chain of event processing functions (filter, map, etc), each\n\t * function will be invoked per event & per listener. Snapshotting an event\n\t * chain allows each function to be invoked just once per event.\n\t */\n\texport function snapshot<T>(event: Event<T>): Event<T> {\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces the provided event, given a `merge` function.\n\t *\n\t * @param event The input event.\n\t * @param merge The reducing function.\n\t * @param delay The debouncing delay in millis.\n\t * @param leading Whether the event should fire in the leading phase of the timeout.\n\t * @param leakWarningThreshold The leak warning threshold override.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst emitter = new Emitter<O>({\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only once and as soon as\n\t * the input event emits. The event data is the number of millis it took for the\n\t * event to fire.\n\t */\n\texport function stopwatch<T>(event: Event<T>): Event<number> {\n\t\tconst start = new Date().getTime();\n\t\treturn map(once(event), _ => new Date().getTime() - start);\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only when the event\n\t * element changes.\n\t */\n\texport function latch<T>(event: Event<T>): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || value !== cache;\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t});\n\t}\n\n\t/**\n\t * Buffers the provided event until a first listener comes\n\t * along, at which point fire all the events at once and\n\t * pipe the event from then on.\n\t *\n\t * ```typescript\n\t * const emitter = new Emitter<number>();\n\t * const event = emitter.event;\n\t * const bufferedEvent = buffer(event);\n\t *\n\t * emitter.fire(1);\n\t * emitter.fire(2);\n\t * emitter.fire(3);\n\t * // nothing...\n\t *\n\t * const listener = bufferedEvent(num => console.log(num));\n\t * // 1, 2, 3\n\t *\n\t * emitter.fire(4);\n\t * // 4\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, nextTick = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.forEach(e => emitter.fire(e));\n\t\t\t}\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (nextTick) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Similar to `buffer` but it buffers indefinitely and repeats\n\t * the buffered events to every new listener.\n\t */\n\texport function echo<T>(event: Event<T>, nextTick = false, buffer: T[] = []): Event<T> {\n\t\tbuffer = buffer.slice();\n\n\t\tevent(e => {\n\t\t\tbuffer.push(e);\n\t\t\temitter.fire(e);\n\t\t});\n\n\t\tconst flush = (listener: (e: T) => any, thisArgs?: any) => buffer.forEach(e => listener.call(thisArgs, e));\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonListenerDidAdd(emitter: Emitter<T>, listener: (e: T) => any, thisArgs?: any) {\n\t\t\t\tif (nextTick) {\n\t\t\t\t\tsetTimeout(() => flush(listener, thisArgs));\n\t\t\t\t} else {\n\t\t\t\t\tflush(listener, thisArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> {\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): this;\n\t\tremoveListener(event: string | symbol, listener: Function): this;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function fromPromise<T = any>(promise: Promise<T>): Event<undefined> {\n\t\tconst emitter = new Emitter<undefined>();\n\t\tlet shouldEmit = false;\n\n\t\tpromise\n\t\t\t.then(undefined, () => null)\n\t\t\t.then(() => {\n\t\t\t\tif (!shouldEmit) {\n\t\t\t\t\tsetTimeout(() => emitter.fire(undefined), 0);\n\t\t\t\t} else {\n\t\t\t\t\temitter.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\tshouldEmit = true;\n\t\treturn emitter.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(c => once(event)(c));\n\t}\n}\n\ntype Listener<T> = [(e: T) => void, any] | ((e: T) => void);\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n\t\tconst count = (this._stacks.get(stack) || 0);\n\t\tthis._stacks.set(stack, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string;\n\t\t\tlet topCount: number = 0;\n\t\t\tthis._stacks.forEach((count, stack) => {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack) || 0);\n\t\t\tthis._stacks!.set(stack, count - 1);\n\t\t};\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static readonly _noop = function () { };\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue: [Listener<T>, T][];\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0\n\t\t\t? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n\t\t\t: undefined;\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tconst remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options && this._options.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, listener, thisArgs);\n\t\t\t\t}\n\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tlet removeMonitor: (() => void) | undefined;\n\t\t\t\tif (this._leakageMon) {\n\t\t\t\t\tremoveMonitor = this._leakageMon.check(this._listeners.size);\n\t\t\t\t}\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (removeMonitor) {\n\t\t\t\t\t\t\tremoveMonitor();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tremove();\n\t\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = [];\n\t\t\t}\n\n\t\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\t\tthis._deliveryQueue.push([e.value, event]);\n\t\t\t}\n\n\t\t\twhile (this._deliveryQueue.length > 0) {\n\t\t\t\tconst [listener, event] = this._deliveryQueue.shift()!;\n\t\t\t\ttry {\n\t\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif (this._listeners) {\n\t\t\tthis._listeners = undefined;\n\t\t}\n\t\tif (this._deliveryQueue) {\n\t\t\tthis._deliveryQueue.length = 0;\n\t\t}\n\t\tif (this._leakageMon) {\n\t\t\tthis._leakageMon.dispose();\n\t\t}\n\t\tthis._disposed = true;\n\t}\n}\n\nexport interface IWaitUntil {\n\twaitUntil(thenable: Promise<any>): void;\n}\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue: [Listener<T>, T, Promise<any>[]][];\n\n\tasync fireAsync(eventFn: (thenables: Promise<any>[], listener: Function) => T): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\t// put all [listener,event]-pairs into delivery queue\n\t\t// then emit all event. an inner/nested event might be\n\t\t// the driver of this\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = [];\n\t\t}\n\n\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\tconst thenables: Promise<void>[] = [];\n\t\t\tthis._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);\n\t\t}\n\n\t\twhile (this._asyncDeliveryQueue.length > 0) {\n\t\t\tconst [listener, event, thenables] = this._asyncDeliveryQueue.shift()!;\n\t\t\ttry {\n\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t} else {\n\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\t\t\tawait Promise.all(thenables);\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null; }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\treadonly isCancellationRequested: boolean;\n\t/**\n\t * An event emitted when cancellation is requested\n\t * @event\n\t */\n\treadonly onCancellationRequested: Event<any>;\n}\n\nconst shortcutEvent = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n} as Event<any>);\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: any): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token: CancellationToken;\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn new class implements CancelablePromise<T> {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: (err: any) => void;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tconst task = this.task!;\n\t\t\t\tthis.task = null;\n\n\t\t\t\treturn task();\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tthis.doResolve!(null);\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject(errors.canceled());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tpublic get onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue {\n\tprivate queues: { [path: string]: Queue<void> };\n\n\tconstructor() {\n\t\tthis.queues = Object.create(null);\n\t}\n\n\tpublic queueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues[key]) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tdelete this.queues[key];\n\t\t\t});\n\n\t\t\tthis.queues[key] = queue;\n\t\t}\n\n\t\treturn this.queues[key];\n\t}\n}\n\nexport class TimeoutTimer extends Disposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tsuper();\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer extends Disposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport function nfcall(fn: Function, ...args: any[]): Promise<any>;\nexport function nfcall<T>(fn: Function, ...args: any[]): Promise<T>;\nexport function nfcall(fn: Function, ...args: any[]): any {\n\treturn new Promise((c, e) => fn(...args, (err: any, result: any) => err ? e(err) : c(result)));\n}\n\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): Promise<any>;\nexport function ninvoke<T>(thisArg: any, fn: Function, ...args: any[]): Promise<T>;\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): any {\n\treturn new Promise((resolve, reject) => fn.call(thisArg, ...args, (err: any, result: any) => err ? reject(err) : resolve(result)));\n}\n\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): DOMHighResTimeStamp;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean;\n\tprivate _value: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory: string = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode: string = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal: string = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough: string = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet: string = 'walkThroughSnippet';\n\n\texport const http: string = 'http';\n\n\texport const https: string = 'https';\n\n\texport const file: string = 'file';\n\n\texport const mailto: string = 'mailto';\n\n\texport const untitled: string = 'untitled';\n\n\texport const data: string = 'data';\n\n\texport const command: string = 'command';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\n// let _isLinux = false;\nlet _isNative = false;\n// let _isWeb = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\n\ninterface NLSConfig {\n\tlocale: string;\n\tavailableLanguages: { [key: string]: string; };\n\t_translationsConfigFile: string;\n}\n\nexport interface IProcessEnvironment {\n\t[key: string]: string;\n}\n\ninterface INodeProcess {\n\tplatform: string;\n\tenv: IProcessEnvironment;\n\tgetuid(): number;\n\tnextTick: Function;\n\tversions?: {\n\t\telectron?: string;\n\t};\n\ttype?: string;\n}\ndeclare const process: INodeProcess;\ndeclare const global: any;\n\ninterface INavigator {\n\tuserAgent: string;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\ndeclare const self: any;\n\nconst isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');\n\n// OS detection\nif (typeof navigator === 'object' && !isElectronRenderer) {\n\tconst userAgent = navigator.userAgent;\n\t_isWindows = userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = userAgent.indexOf('Macintosh') >= 0;\n\t// _isLinux = userAgent.indexOf('Linux') >= 0;\n\t// _isWeb = true;\n\t_locale = navigator.language;\n\t_language = _locale;\n} else if (typeof process === 'object') {\n\t_isWindows = (process.platform === 'win32');\n\t_isMacintosh = (process.platform === 'darwin');\n\t// _isLinux = (process.platform === 'linux');\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\tconst resolved = nlsConfig.availableLanguages['*'];\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t// VSCode's default language is 'en'\n\t\t\t_language = resolved ? resolved : LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport function PlatformToString(platform: Platform) {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\n// let _platform: Platform = Platform.Web;\n// if (_isNative) {\n// \tif (_isMacintosh) {\n// \t\t_platform = Platform.Mac;\n// \t} else if (_isWindows) {\n// \t\t_platform = Platform.Windows;\n// \t} else if (_isLinux) {\n// \t\t_platform = Platform.Linux;\n// \t}\n// }\n\nexport const isRealWindows = _isWindows;\nexport const isWindows = false; // _isWindows;\nexport const isMacintosh = true; // _isMacintosh;\nexport const isLinux = false; // _isLinux;\nexport const isNative = false; // _isNative;\nexport const isWeb = false; // _isWeb;\nexport const platform = 1; // _platform;\n\nexport function isRootUser(): boolean {\n\treturn _isNative && !_isWindows && (process.getuid() === 0);\n}\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * The translatios that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nconst _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {} as any);\nexport const globals: any = _globals;\n\nlet _setImmediate: ((callback: (...args: any[]) => void) => number) | null = null;\nexport function setImmediate(callback: (...args: any[]) => void): number {\n\tif (_setImmediate === null) {\n\t\tif (globals.setImmediate) {\n\t\t\t_setImmediate = globals.setImmediate.bind(globals);\n\t\t} else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n\t\t\t_setImmediate = process.nextTick.bind(process);\n\t\t} else {\n\t\t\t_setImmediate = globals.setTimeout.bind(globals);\n\t\t}\n\t}\n\treturn _setImmediate!(callback);\n}\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate } from 'vs/base/common/platform';\n\ninterface IProcess {\n\tplatform: string;\n\tenv: object;\n\n\tcwd(): string;\n\tnextTick(callback: (...args: any[]) => void): number;\n}\n\ndeclare const process: IProcess;\nconst safeProcess: IProcess = (typeof process === 'undefined') ? {\n\tcwd(): string { return '/'; },\n\tenv: Object.create(null),\n\tget platform(): string { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\tnextTick(callback: (...args: any[]) => void): number { return setImmediate(callback); }\n} : process;\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: string) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tlet msg;\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tmsg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\t}\n}\n\nfunction validateString(value: string, name) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (lastSlash !== i - 1 && dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length === 2 || res.length === 1) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tif (res.length > 0) {\n\t\t\t\t\t\tres += `${separator}..`;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = '..';\n\t\t\t\t\t}\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += separator + path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep, pathObject) {\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t((pathObject.name || '') + (pathObject.ext || ''));\n\tif (!dir) {\n\t\treturn base;\n\t}\n\tif (dir === pathObject.root) {\n\t\treturn dir + base;\n\t}\n\treturn dir + sep + base;\n}\n\ninterface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\ninterface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t} else if (!resolvedDevice) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env['=' + resolvedDevice] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 3).toLowerCase() !==\n\t\t\t\t\tresolvedDevice.toLowerCase() + '\\\\') {\n\t\t\t\t\tpath = resolvedDevice + '\\\\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len > 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// Possible UNC root\n\n\t\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\t\tisAbsolute = true;\n\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\t\tlet j = 2;\n\t\t\t\t\t\tlet last = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEnd = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t\t// Possible device root\n\n\t\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\t\trootEnd = 2;\n\t\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator\n\t\t\t\trootEnd = 1;\n\t\t\t\tisAbsolute = true;\n\t\t\t}\n\n\t\t\tif (device.length > 0 &&\n\t\t\t\tresolvedDevice.length > 0 &&\n\t\t\t\tdevice.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length === 0 && device.length > 0) {\n\t\t\t\tresolvedDevice = device;\n\t\t\t}\n\t\t\tif (!resolvedAbsolute) {\n\t\t\t\tresolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length > 0 && resolvedAbsolute) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n\t\t\t'.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t\t// path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t\t// is nothing left to process\n\n\t\t\t\t\t\t\t\treturn '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid unnecessary\n\t\t\t// work\n\t\t\treturn '\\\\';\n\t\t}\n\n\t\tlet tail;\n\t\tif (rootEnd < len) {\n\t\t\ttail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\',\n\t\t\t\tisPathSeparator);\n\t\t} else {\n\t\t\ttail = '';\n\t\t}\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\tif (isAbsolute) {\n\t\t\t\tif (tail.length > 0) {\n\t\t\t\t\treturn '\\\\' + tail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t} else if (tail.length > 0) {\n\t\t\t\treturn tail;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (isAbsolute) {\n\t\t\tif (tail.length > 0) {\n\t\t\t\treturn device + '\\\\' + tail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn device + '\\\\';\n\t\t\t}\n\t\t} else if (tail.length > 0) {\n\t\t\treturn device + tail;\n\t\t} else {\n\t\t\treturn device;\n\t\t}\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\tif (isPathSeparator(code)) {\n\t\t\treturn true;\n\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t// Possible device root\n\n\t\t\tif (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '\\\\' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1) {\n\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t\t++slashCount;\n\t\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\tfor (; slashCount < joined.length; ++slashCount) {\n\t\t\t\tif (!isPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = '\\\\' + joined.slice(slashCount);\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\tfor (; fromEnd - 1 > fromStart; --fromEnd) {\n\t\t\tif (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\tfor (; toEnd - 1 > toStart; --toEnd) {\n\t\t\tif (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length && lastCommonSep === -1) {\n\t\t\treturn toOrig;\n\t\t}\n\n\t\tlet out = '';\n\t\tif (lastCommonSep === -1) {\n\t\t\tlastCommonSep = 0;\n\t\t}\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '\\\\..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + toOrig.slice(toStart + lastCommonSep, toEnd);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn toOrig.slice(toStart, toEnd);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length >= 3) {\n\t\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\t\treturn '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\t\t\treturn '\\\\\\\\?\\\\' + resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = offset = 1;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = offset = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\trootEnd = offset = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn path;\n\t\t}\n\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = rootEnd;\n\t\t\t}\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2) {\n\t\t\tconst drive = path.charCodeAt(0);\n\t\t\tif (isWindowsDeviceRoot(drive)) {\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tstart = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('\\\\', pathObject);\n\t},\n\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = 1;\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\tif (len === 3) {\n\t\t\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\tret.root = ret.dir = path;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t}\n\t\t} else {\n\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\tret.base = path.slice(startPart, end);\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = process.cwd();\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = path + '/' + resolvedPath;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\tif (resolvedPath.length > 0) {\n\t\t\t\treturn '/' + resolvedPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t} else if (resolvedPath.length > 0) {\n\t\t\treturn resolvedPath;\n\t\t} else {\n\t\t\treturn '.';\n\t\t}\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0 && !isAbsolute) {\n\t\t\tpath = '.';\n\t\t}\n\t\tif (path.length > 0 && trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\tif (isAbsolute) {\n\t\t\treturn '/' + path;\n\t\t}\n\t\treturn path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = arguments[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '/' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 1;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 1;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toEnd = to.length;\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t} else if (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t\t// For example: from='/foo'; to='/'\n\t\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '/..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + to.slice(toStart + lastCommonSep);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn to.slice(toStart);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('/', pathObject);\n\t},\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\t\tret.base = ret.name = path.slice(1, end);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\tret.name = path.slice(1, startDot);\n\t\t\t\tret.base = path.slice(1, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t}\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { globals } from 'vs/base/common/platform';\n\nconst hasPerformanceNow = (globals.performance && typeof globals.performance.now === 'function');\n\nexport class StopWatch {\n\n\tprivate _highResolution: boolean;\n\tprivate _startTime: number;\n\tprivate _stopTime: number;\n\n\tpublic static create(highResolution: boolean = true): StopWatch {\n\t\treturn new StopWatch(highResolution);\n\t}\n\n\tconstructor(highResolution: boolean) {\n\t\tthis._highResolution = hasPerformanceNow && highResolution;\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic stop(): void {\n\t\tthis._stopTime = this._now();\n\t}\n\n\tpublic elapsed(): number {\n\t\tif (this._stopTime !== -1) {\n\t\t\treturn this._stopTime - this._startTime;\n\t\t}\n\t\treturn this._now() - this._startTime;\n\t}\n\n\tprivate _now(): number {\n\t\treturn this._highResolution ? globals.performance.now() : new Date().getTime();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * The empty string.\n */\nexport const empty = '';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\n/**\n * @returns the provided number with the given number of preceding zeros.\n */\nexport function pad(n: number, l: number, char: string = '0'): string {\n\tconst str = '' + n;\n\tconst r = [str];\n\n\tfor (let i = str.length; i < l; i++) {\n\t\tr.push(char);\n\t}\n\n\treturn r.reverse().join('');\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\n/**\n * Determines if haystack starts with needle.\n */\nexport function startsWith(haystack: string, needle: string): boolean {\n\tif (haystack.length < needle.length) {\n\t\treturn false;\n\t}\n\n\tif (haystack === needle) {\n\t\treturn true;\n\t}\n\n\tfor (let i = 0; i < needle.length; i++) {\n\t\tif (haystack[i] !== needle[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack: string, needle: string): boolean {\n\tconst diff = haystack.length - needle.length;\n\tif (diff > 0) {\n\t\treturn haystack.indexOf(needle, diff) === diff;\n\t} else if (diff === 0) {\n\t\treturn haystack === needle;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && <any>regexp.lastIndex === 0);\n}\n\nexport function regExpContainsBackreference(regexpValue: string): boolean {\n\treturn !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\n\nexport function regExpFlags(regexp: RegExp): string {\n\treturn (regexp.global ? 'g' : '')\n\t\t+ (regexp.ignoreCase ? 'i' : '')\n\t\t+ (regexp.multiline ? 'm' : '')\n\t\t+ ((regexp as any).unicode ? 'u' : '');\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\tconst len = Math.min(a.length, b.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tlet codeA = a.charCodeAt(i);\n\t\tlet codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeA)) {\n\t\t\tcodeA += 32;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeB)) {\n\t\t\tcodeB += 32;\n\t\t}\n\n\t\tconst diff = codeA - codeB;\n\n\t\tif (diff === 0) {\n\t\t\t// equal -> ignoreCase\n\t\t\tcontinue;\n\n\t\t} else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n\t\t\t//\n\t\t\treturn diff;\n\n\t\t} else {\n\t\t\treturn compare(a.toLowerCase(), b.toLowerCase());\n\t\t}\n\t}\n\n\tif (a.length < b.length) {\n\t\treturn -1;\n\t} else if (a.length > b.length) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nfunction isAsciiLetter(code: number): boolean {\n\treturn isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\tconst len1 = a ? a.length : 0;\n\tconst len2 = b ? b.length : 0;\n\n\tif (len1 !== len2) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(a, b);\n}\n\nfunction doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {\n\tif (typeof a !== 'string' || typeof b !== 'string') {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < stopAt; i++) {\n\t\tconst codeA = a.charCodeAt(i);\n\t\tconst codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// a-z A-Z\n\t\tif (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n\t\t\tconst diff = Math.abs(codeA - codeB);\n\t\t\tif (diff !== 0 && diff !== 32) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Any other charcode\n\t\telse {\n\t\t\tif (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nfunction substrEquals(a: string, aStart: number, aEnd: number, b: string, bStart: number, bEnd: number): boolean {\n\twhile (aStart < aEnd && bStart < bEnd) {\n\t\tif (a[aStart] !== b[bStart]) {\n\t\t\treturn false;\n\t\t}\n\t\taStart += 1;\n\t\tbStart += 1;\n\t}\n\treturn true;\n}\n\n/**\n * Return the overlap between the suffix of `a` and the prefix of `b`.\n * For instance `overlap(\"foobar\", \"arr, I'm a pirate\") === 2`.\n */\nexport function overlap(a: string, b: string): number {\n\tconst aEnd = a.length;\n\tlet bEnd = b.length;\n\tlet aStart = aEnd - bEnd;\n\n\tif (aStart === 0) {\n\t\treturn a === b ? aEnd : 0;\n\t} else if (aStart < 0) {\n\t\tbEnd += aStart;\n\t\taStart = 0;\n\t}\n\n\twhile (aStart < aEnd && bEnd > 0) {\n\t\tif (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {\n\t\t\treturn bEnd;\n\t\t}\n\t\tbEnd -= 1;\n\t\taStart += 1;\n\t}\n\treturn 0;\n}\n\n// --- unicode\n// http://en.wikipedia.org/wiki/Surrogate_pair\n// Returns the code point starting at a specified index in a string\n// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n// Code points U+10000 to U+10FFFF are represented on two consecutive characters\n//export function getUnicodePoint(str:string, index:number, len:number):number {\n//\tconst chrCode = str.charCodeAt(index);\n//\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n//\t\tconst nextChrCode = str.charCodeAt(index + 1);\n//\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n//\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n//\t\t}\n//\t}\n//\treturn chrCode;\n//}\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\treturn CONTAINS_RTL.test(str);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nconst CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEF8]|\\uD83E[\\uDD00-\\uDDE6])/;\n\nexport function containsEmoji(str: string): boolean {\n\treturn CONTAINS_EMOJI.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport function containsFullWidthCharacter(str: string): boolean {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tif (isFullWidthCharacter(str.charCodeAt(i))) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80  2EFF   CJK Radicals Supplement\n\t//          2F00  2FDF   Kangxi Radicals\n\t//          2FF0  2FFF   Ideographic Description Characters\n\t//          3000  303F   CJK Symbols and Punctuation\n\t//          3040  309F   Hiragana\n\t//          30A0  30FF   Katakana\n\t//          3100  312F   Bopomofo\n\t//          3130  318F   Hangul Compatibility Jamo\n\t//          3190  319F   Kanbun\n\t//          31A0  31BF   Bopomofo Extended\n\t//          31F0  31FF   Katakana Phonetic Extensions\n\t//          3200  32FF   Enclosed CJK Letters and Months\n\t//          3300  33FF   CJK Compatibility\n\t//          3400  4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0  4DFF   Yijing Hexagram Symbols\n\t//          4E00  9FFF   CJK Unified Ideographs\n\t//          A000  A48F   Yi Syllables\n\t//          A490  A4CF   Yi Radicals\n\t//          AC00  D7AF   Hangul Syllables\n\t// [IGNORE] D800  DB7F   High Surrogates\n\t// [IGNORE] DB80  DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00  DFFF   Low Surrogates\n\t// [IGNORE] E000  F8FF   Private Use Area\n\t//          F900  FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00  FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50  FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00  FE0F   Variation Selectors\n\t// [IGNORE] FE20  FE2F   Combining Half Marks\n\t// [IGNORE] FE30  FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50  FE6F   Small Form Variants\n\t// [IGNORE] FE70  FEFF   Arabic Presentation Forms-B\n\t//          FF00  FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0  FFFF   Specials\n\tcharCode = +charCode; // @perf\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nexport function lcut(text: string, n: number) {\n\tif (text.length < n) {\n\t\treturn text;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(text)) {\n\t\tif (text.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\treturn text.substring(i).replace(/^\\s/, empty);\n}\n\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nconst EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nconst COLOR_START = /\\x1b\\[\\d+m/g; // Color\nconst COLOR_END = /\\x1b\\[0?m/g; // Color\n\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(EL, '');\n\t\tstr = str.replace(COLOR_START, '');\n\t\tstr = str.replace(COLOR_END, '');\n\t}\n\n\treturn str;\n}\n\nexport const removeAccents: (str: string) => string = (function () {\n\tif (typeof (String.prototype as any).normalize !== 'function') {\n\t\t//  no ES6 features...\n\t\treturn function (str: string) { return str; };\n\t} else {\n\t\t// transform into NFD form and remove accents\n\t\t// see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n\t\tconst regex = /[\\u0300-\\u036f]/g;\n\t\treturn function (str: string) {\n\t\t\treturn (str as any).normalize('NFD').replace(regex, empty);\n\t\t};\n\t}\n})();\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\nexport function safeBtoa(str: string): string {\n\treturn btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n}\n\nexport function repeat(s: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\treturn idx >= 0 ?\n\t\tstr.substr(0, idx) :\n\t\tstr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport { sep } from 'vs/base/common/path';\nimport { IdleValue } from 'vs/base/common/async';\n\nlet intlFileNameCollator: IdleValue<{ collator: Intl.Collator, collatorIsNumeric: boolean }>;\n\nexport function setFileNameComparer(collator: IdleValue<{ collator: Intl.Collator, collatorIsNumeric: boolean }>): void {\n\tintlFileNameCollator = collator;\n}\n\nexport function compareFileNames(one: string | null, other: string | null, caseSensitive = false): number {\n\tif (intlFileNameCollator) {\n\t\tconst a = one || '';\n\t\tconst b = other || '';\n\t\tconst result = intlFileNameCollator.getValue().collator.compare(a, b);\n\n\t\t// Using the numeric option in the collator will\n\t\t// make compare(`foo1`, `foo01`) === 0. We must disambiguate.\n\t\tif (intlFileNameCollator.getValue().collatorIsNumeric && result === 0 && a !== b) {\n\t\t\treturn a < b ? -1 : 1;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treturn noIntlCompareFileNames(one, other, caseSensitive);\n}\n\nconst FileNameMatch = /^(.*?)(\\.([^.]*))?$/;\n\nexport function noIntlCompareFileNames(one: string | null, other: string | null, caseSensitive = false): number {\n\tif (!caseSensitive) {\n\t\tone = one && one.toLowerCase();\n\t\tother = other && other.toLowerCase();\n\t}\n\n\tconst [oneName, oneExtension] = extractNameAndExtension(one);\n\tconst [otherName, otherExtension] = extractNameAndExtension(other);\n\n\tif (oneName !== otherName) {\n\t\treturn oneName < otherName ? -1 : 1;\n\t}\n\n\tif (oneExtension === otherExtension) {\n\t\treturn 0;\n\t}\n\n\treturn oneExtension < otherExtension ? -1 : 1;\n}\n\nexport function compareFileExtensions(one: string | null, other: string | null): number {\n\tif (intlFileNameCollator) {\n\t\tconst [oneName, oneExtension] = extractNameAndExtension(one);\n\t\tconst [otherName, otherExtension] = extractNameAndExtension(other);\n\n\t\tlet result = intlFileNameCollator.getValue().collator.compare(oneExtension, otherExtension);\n\n\t\tif (result === 0) {\n\t\t\t// Using the numeric option in the collator will\n\t\t\t// make compare(`foo1`, `foo01`) === 0. We must disambiguate.\n\t\t\tif (intlFileNameCollator.getValue().collatorIsNumeric && oneExtension !== otherExtension) {\n\t\t\t\treturn oneExtension < otherExtension ? -1 : 1;\n\t\t\t}\n\n\t\t\t// Extensions are equal, compare filenames\n\t\t\tresult = intlFileNameCollator.getValue().collator.compare(oneName, otherName);\n\n\t\t\tif (intlFileNameCollator.getValue().collatorIsNumeric && result === 0 && oneName !== otherName) {\n\t\t\t\treturn oneName < otherName ? -1 : 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treturn noIntlCompareFileExtensions(one, other);\n}\n\nfunction noIntlCompareFileExtensions(one: string | null, other: string | null): number {\n\tconst [oneName, oneExtension] = extractNameAndExtension(one && one.toLowerCase());\n\tconst [otherName, otherExtension] = extractNameAndExtension(other && other.toLowerCase());\n\n\tif (oneExtension !== otherExtension) {\n\t\treturn oneExtension < otherExtension ? -1 : 1;\n\t}\n\n\tif (oneName === otherName) {\n\t\treturn 0;\n\t}\n\n\treturn oneName < otherName ? -1 : 1;\n}\n\nfunction extractNameAndExtension(str?: string | null): [string, string] {\n\tconst match = str ? FileNameMatch.exec(str) as Array<string> : ([] as Array<string>);\n\n\treturn [(match && match[1]) || '', (match && match[3]) || ''];\n}\n\nfunction comparePathComponents(one: string, other: string, caseSensitive = false): number {\n\tif (!caseSensitive) {\n\t\tone = one && one.toLowerCase();\n\t\tother = other && other.toLowerCase();\n\t}\n\n\tif (one === other) {\n\t\treturn 0;\n\t}\n\n\treturn one < other ? -1 : 1;\n}\n\nexport function comparePaths(one: string, other: string, caseSensitive = false): number {\n\tconst oneParts = one.split(sep);\n\tconst otherParts = other.split(sep);\n\n\tconst lastOne = oneParts.length - 1;\n\tconst lastOther = otherParts.length - 1;\n\tlet endOne: boolean, endOther: boolean;\n\n\tfor (let i = 0; ; i++) {\n\t\tendOne = lastOne === i;\n\t\tendOther = lastOther === i;\n\n\t\tif (endOne && endOther) {\n\t\t\treturn compareFileNames(oneParts[i], otherParts[i], caseSensitive);\n\t\t} else if (endOne) {\n\t\t\treturn -1;\n\t\t} else if (endOther) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);\n\n\t\tif (result !== 0) {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport function compareAnything(one: string, other: string, lookFor: string): number {\n\tconst elementAName = one.toLowerCase();\n\tconst elementBName = other.toLowerCase();\n\n\t// Sort prefix matches over non prefix matches\n\tconst prefixCompare = compareByPrefix(one, other, lookFor);\n\tif (prefixCompare) {\n\t\treturn prefixCompare;\n\t}\n\n\t// Sort suffix matches over non suffix matches\n\tconst elementASuffixMatch = strings.endsWith(elementAName, lookFor);\n\tconst elementBSuffixMatch = strings.endsWith(elementBName, lookFor);\n\tif (elementASuffixMatch !== elementBSuffixMatch) {\n\t\treturn elementASuffixMatch ? -1 : 1;\n\t}\n\n\t// Understand file names\n\tconst r = compareFileNames(elementAName, elementBName);\n\tif (r !== 0) {\n\t\treturn r;\n\t}\n\n\t// Compare by name\n\treturn elementAName.localeCompare(elementBName);\n}\n\nexport function compareByPrefix(one: string, other: string, lookFor: string): number {\n\tconst elementAName = one.toLowerCase();\n\tconst elementBName = other.toLowerCase();\n\n\t// Sort prefix matches over non prefix matches\n\tconst elementAPrefixMatch = strings.startsWith(elementAName, lookFor);\n\tconst elementBPrefixMatch = strings.startsWith(elementBName, lookFor);\n\tif (elementAPrefixMatch !== elementBPrefixMatch) {\n\t\treturn elementAPrefixMatch ? -1 : 1;\n\t}\n\n\t// Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n\telse if (elementAPrefixMatch && elementBPrefixMatch) {\n\t\tif (elementAName.length < elementBName.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (elementAName.length > elementBName.length) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix } from 'vs/base/common/path';\n\nfunction isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst INVALID_FILE_CHARS = isWindows ? /[\\\\/:\\*\\?\"<>\\|]/g : /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])$/i;\nexport function isValidBasename(name: string | null | undefined): boolean {\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tINVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development\n\tif (INVALID_FILE_CHARS.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindows && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindows && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 lenth\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(path: string, candidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (path === candidate) {\n\t\treturn true;\n\t}\n\n\tif (!path || !candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(path, candidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (candidate.length === path.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = candidate.length;\n\t\tif (candidate.charAt(candidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn path.charAt(sepOffset) === separator;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== separator) {\n\t\tcandidate += separator;\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst _typeof = {\n\tnumber: 'number',\n\tstring: 'string',\n\tundefined: 'undefined',\n\tobject: 'object',\n\tfunction: 'function'\n};\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\nexport function isArray(array: any): array is any[] {\n\tif (Array.isArray) {\n\t\treturn Array.isArray(array);\n\t}\n\n\tif (array && typeof (array.length) === _typeof.number && array.constructor === Array) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: any): str is string {\n\tif (typeof (str) === _typeof.string || str instanceof String) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: any): value is string[] {\n\treturn isArray(value) && (<any[]>value).every(elem => isString(elem));\n}\n\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: any): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === _typeof.object\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: any): obj is number {\n\tif ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: any): obj is boolean {\n\treturn obj === true || obj === false;\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: any): obj is undefined {\n\treturn typeof (obj) === _typeof.undefined;\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: any): obj is undefined | null {\n\treturn isUndefined(obj) || obj === null;\n}\n\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: any): obj is any {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (let key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: any): obj is Function {\n\treturn typeof obj === _typeof.function;\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: any[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: any[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: any, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch{\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Creates a new object of the provided class and will call the constructor with\n * any additional argument supplied.\n */\nexport function create(ctor: Function, ...args: any[]): any {\n\tif (isNativeClass(ctor)) {\n\t\treturn new (ctor as any)(...args);\n\t} else {\n\t\tconst obj = Object.create(ctor.prototype);\n\t\tctor.apply(obj, args);\n\t\treturn obj;\n\t}\n}\n\n// https://stackoverflow.com/a/32235645/1499159\nfunction isNativeClass(thing): boolean {\n\treturn typeof thing === 'function'\n\t\t&& thing.hasOwnProperty('prototype')\n\t\t&& !thing.hasOwnProperty('arguments');\n}\n\nexport function getAllPropertyNames(obj: object): string[] {\n\tlet res: string[] = [];\n\tlet proto = Object.getPrototypeOf(obj);\n\twhile (Object.prototype !== proto) {\n\t\tres = res.concat(Object.getOwnPropertyNames(proto));\n\t\tproto = Object.getPrototypeOf(proto);\n\t}\n\treturn res;\n}\n\n/**\n * Converts null to undefined, passes all other values through.\n */\nexport function withNullAsUndefined<T>(x: T | null): T | undefined {\n\treturn x === null ? undefined : x;\n}\n\n/**\n * Converts undefined to null, passes all other values through.\n */\nexport function withUndefinedAsNull<T>(x: T | undefined): T | null {\n\treturn typeof x === 'undefined' ? null : x;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isObject, isUndefinedOrNull, isArray } from 'vs/base/common/types';\n\nexport function deepClone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tif (obj instanceof RegExp) {\n\t\t// See https://github.com/Microsoft/TypeScript/issues/10990\n\t\treturn obj as any;\n\t}\n\tconst result: any = Array.isArray(obj) ? [] : {};\n\tObject.keys(obj).forEach((key: string) => {\n\t\tif (obj[key] && typeof obj[key] === 'object') {\n\t\t\tresult[key] = deepClone(obj[key]);\n\t\t} else {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function deepFreeze<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tconst stack: any[] = [obj];\n\twhile (stack.length > 0) {\n\t\tconst obj = stack.shift();\n\t\tObject.freeze(obj);\n\t\tfor (const key in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, key)) {\n\t\t\t\tconst prop = obj[key];\n\t\t\t\tif (typeof prop === 'object' && !Object.isFrozen(prop)) {\n\t\t\t\t\tstack.push(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function cloneAndChange(obj: any, changer: (orig: any) => any): any {\n\treturn _cloneAndChange(obj, changer, new Set());\n}\n\nfunction _cloneAndChange(obj: any, changer: (orig: any) => any, seen: Set<any>): any {\n\tif (isUndefinedOrNull(obj)) {\n\t\treturn obj;\n\t}\n\n\tconst changed = changer(obj);\n\tif (typeof changed !== 'undefined') {\n\t\treturn changed;\n\t}\n\n\tif (isArray(obj)) {\n\t\tconst r1: any[] = [];\n\t\tfor (const e of obj) {\n\t\t\tr1.push(_cloneAndChange(e, changer, seen));\n\t\t}\n\t\treturn r1;\n\t}\n\n\tif (isObject(obj)) {\n\t\tif (seen.has(obj)) {\n\t\t\tthrow new Error('Cannot clone recursive data-structure');\n\t\t}\n\t\tseen.add(obj);\n\t\tconst r2 = {};\n\t\tfor (let i2 in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, i2)) {\n\t\t\t\t(r2 as any)[i2] = _cloneAndChange(obj[i2], changer, seen);\n\t\t\t}\n\t\t}\n\t\tseen.delete(obj);\n\t\treturn r2;\n\t}\n\n\treturn obj;\n}\n\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination: any, source: any, overwrite: boolean = true): any {\n\tif (!isObject(destination)) {\n\t\treturn source;\n\t}\n\n\tif (isObject(source)) {\n\t\tObject.keys(source).forEach(key => {\n\t\t\tif (key in destination) {\n\t\t\t\tif (overwrite) {\n\t\t\t\t\tif (isObject(destination[key]) && isObject(source[key])) {\n\t\t\t\t\t\tmixin(destination[key], source[key], overwrite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn destination;\n}\n\nexport function assign<T>(destination: T): T;\nexport function assign<T, U>(destination: T, u: U): T & U;\nexport function assign<T, U, V>(destination: T, u: U, v: V): T & U & V;\nexport function assign<T, U, V, W>(destination: T, u: U, v: V, w: W): T & U & V & W;\nexport function assign(destination: any, ...sources: any[]): any {\n\tsources.forEach(source => Object.keys(source).forEach(key => destination[key] = source[key]));\n\treturn destination;\n}\n\nexport function equals(one: any, other: any): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\tif (one === null || one === undefined || other === null || other === undefined) {\n\t\treturn false;\n\t}\n\tif (typeof one !== typeof other) {\n\t\treturn false;\n\t}\n\tif (typeof one !== 'object') {\n\t\treturn false;\n\t}\n\tif ((Array.isArray(one)) !== (Array.isArray(other))) {\n\t\treturn false;\n\t}\n\n\tlet i: number;\n\tlet key: string;\n\n\tif (Array.isArray(one)) {\n\t\tif (one.length !== other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < one.length; i++) {\n\t\t\tif (!equals(one[i], other[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst oneKeys: string[] = [];\n\n\t\tfor (key in one) {\n\t\t\toneKeys.push(key);\n\t\t}\n\t\toneKeys.sort();\n\t\tconst otherKeys: string[] = [];\n\t\tfor (key in other) {\n\t\t\totherKeys.push(key);\n\t\t}\n\t\totherKeys.sort();\n\t\tif (!equals(oneKeys, otherKeys)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < oneKeys.length; i++) {\n\t\t\tif (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction arrayToHash(array: string[]): { [name: string]: true } {\n\tconst result: any = {};\n\tfor (const e of array) {\n\t\tresult[e] = true;\n\t}\n\treturn result;\n}\n\n/**\n * Given an array of strings, returns a function which, given a string\n * returns true or false whether the string is in that array.\n */\nexport function createKeywordMatcher(arr: string[], caseInsensitive: boolean = false): (str: string) => boolean {\n\tif (caseInsensitive) {\n\t\tarr = arr.map(function (x) { return x.toLowerCase(); });\n\t}\n\tconst hash = arrayToHash(arr);\n\tif (caseInsensitive) {\n\t\treturn function (word) {\n\t\t\treturn hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n\t\t};\n\t} else {\n\t\treturn function (word) {\n\t\t\treturn hash[word] !== undefined && hash.hasOwnProperty(word);\n\t\t};\n\t}\n}\n\n/**\n * Calls JSON.Stringify with a replacer to break apart any circular references.\n * This prevents JSON.stringify from throwing the exception\n *  \"Uncaught TypeError: Converting circular structure to JSON\"\n */\nexport function safeStringify(obj: any): string {\n\tconst seen: any[] = [];\n\treturn JSON.stringify(obj, (key, value) => {\n\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\tif (seen.indexOf(value) !== -1) {\n\t\t\t\treturn '[Circular]';\n\t\t\t} else {\n\t\t\t\tseen.push(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport function getOrDefault<T, R>(obj: T, fn: (obj: T) => R | undefined, defaultValue: R): R {\n\tconst result = fn(obj);\n\treturn typeof result === 'undefined' ? defaultValue : result;\n}\n\ntype obj = { [key: string]: any; };\n/**\n * Returns an object that has keys for each value that is different in the base object. Keys\n * that do not exist in the target but in the base object are not considered.\n *\n * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting\n * object if they differ.\n *\n * @param base the object to diff against\n * @param obj the object to use for diffing\n */\nexport function distinct(base: obj, target: obj): obj {\n\tconst result = Object.create(null);\n\n\tif (!base || !target) {\n\t\treturn result;\n\t}\n\n\tconst targetKeys = Object.keys(target);\n\ttargetKeys.forEach(k => {\n\t\tconst baseValue = base[k];\n\t\tconst targetValue = target[k];\n\n\t\tif (!equals(baseValue, targetValue)) {\n\t\t\tresult[k] = targetValue;\n\t\t}\n\t});\n\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nlet _throwOnMissingSchema: boolean = true;\n\n/**\n * @internal\n */\nexport function setUriThrowOnMissingScheme(value: boolean): boolean {\n\tconst old = _throwOnMissingSchema;\n\t_throwOnMissingSchema = value;\n\treturn old;\n}\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme) {\n\t\tif (_strict || _throwOnMissingSchema) {\n\t\t\t// console.error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t\t} else {\n\t\t\tconsole.warn(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t\t}\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (_strict || _throwOnMissingSchema) {\n\t\treturn scheme || _empty;\n\t}\n\tif (!scheme) {\n\t\tconsole.trace('BAD uri lacks scheme, falling back to file-scheme.');\n\t\tscheme = 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'function'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn _makeFsPath(this);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\tpublic with(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new _URI(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tpublic static parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new _URI(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new _URI(\n\t\t\tmatch[2] || _empty,\n\t\t\tdecodeURIComponent(match[4] || _empty),\n\t\t\tdecodeURIComponent(match[5] || _empty),\n\t\t\tdecodeURIComponent(match[7] || _empty),\n\t\t\tdecodeURIComponent(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tpublic static file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new _URI('file', authority, path, _empty, _empty);\n\t}\n\n\tpublic static from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\treturn new _URI(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\tpublic toJSON(): object {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | any): URI {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new _URI(data);\n\t\t\tresult._fsPath = (<UriState>data).fsPath;\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\tfsPath: string;\n\texternal: string;\n}\n\n\n// tslint:disable-next-line:class-name\nclass _URI extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\tget fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = _makeFsPath(this);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\ttoJSON(): object {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (allowSlash && code === CharCode.Slash)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nfunction _makeFsPath(uri: URI): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\t// windows drive letter: file:///c:/far/boo\n\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.indexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n\t}\n\treturn res;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport function getPathFromAmdModule(requirefn: typeof require, relativePath: string): string {\n\treturn URI.parse(requirefn.toUrl(relativePath)).fsPath;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Iterator, IteratorResult, FIN } from './iterator';\n\nexport function values<V = any>(set: Set<V>): V[];\nexport function values<K = any, V = any>(map: Map<K, V>): V[];\nexport function values<V>(forEachable: { forEach(callback: (value: V, ...more: any[]) => any): void }): V[] {\n\tconst result: V[] = [];\n\tforEachable.forEach(value => result.push(value));\n\treturn result;\n}\n\nexport function keys<K, V>(map: Map<K, V>): K[] {\n\tconst result: K[] = [];\n\tmap.forEach((value, key) => result.push(key));\n\n\treturn result;\n}\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport function mapToSerializable(map: Map<string, string>): [string, string][] {\n\tconst serializable: [string, string][] = [];\n\n\tmap.forEach((value, key) => {\n\t\tserializable.push([key, value]);\n\t});\n\n\treturn serializable;\n}\n\nexport function serializableToMap(serializable: [string, string][]): Map<string, string> {\n\tconst items = new Map<string, string>();\n\n\tfor (const [key, value] of serializable) {\n\t\titems.set(key, value);\n\t}\n\n\treturn items;\n}\n\nexport interface IKeyIterator {\n\treset(key: string): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class PathIterator implements IKeyIterator {\n\n\tprivate _value: string;\n\tprivate _from: number;\n\tprivate _to: number;\n\n\treset(key: string): this {\n\t\tthis._value = key.replace(/\\\\$|\\/$/, '');\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\n\t\tlet aPos = 0;\n\t\tconst aLen = a.length;\n\t\tlet thisPos = this._from;\n\n\t\twhile (aPos < aLen && thisPos < this._to) {\n\t\t\tconst cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n\t\t\tif (cmp !== 0) {\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t\taPos += 1;\n\t\t\tthisPos += 1;\n\t\t}\n\n\t\tif (aLen === this._to - this._from) {\n\t\t\treturn 0;\n\t\t} else if (aPos < aLen) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nclass TernarySearchTreeNode<E> {\n\tsegment: string;\n\tvalue: E | undefined;\n\tkey: string;\n\tleft: TernarySearchTreeNode<E> | undefined;\n\tmid: TernarySearchTreeNode<E> | undefined;\n\tright: TernarySearchTreeNode<E> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n}\n\nexport class TernarySearchTree<E> {\n\n\tstatic forPaths<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new PathIterator());\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new StringIterator());\n\t}\n\n\tprivate _iter: IKeyIterator;\n\tprivate _root: TernarySearchTreeNode<E> | undefined;\n\n\tconstructor(segments: IKeyIterator) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\tset(key: string, element: E): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<E>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<E>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\t\treturn oldElement;\n\t}\n\n\tget(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node ? node.value : undefined;\n\t}\n\n\tdelete(key: string): void {\n\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [-1 | 0 | 1, TernarySearchTreeNode<E>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find and unset node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([1, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([-1, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([0, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// remove element\n\t\t\t\tnode.value = undefined;\n\n\t\t\t\t// clean up empty nodes\n\t\t\t\twhile (stack.length > 0 && node.isEmpty()) {\n\t\t\t\t\tlet [dir, parent] = stack.pop()!;\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase 1: parent.left = undefined; break;\n\t\t\t\t\t\tcase 0: parent.mid = undefined; break;\n\t\t\t\t\t\tcase -1: parent.right = undefined; break;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindSubstr(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: E | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: string): Iterator<E> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._nodeIterator(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _nodeIterator(node: TernarySearchTreeNode<E>): Iterator<E> {\n\t\tlet res: { done: false; value: E; };\n\t\tlet idx: number;\n\t\tlet data: E[];\n\t\tconst next = (): IteratorResult<E> => {\n\t\t\tif (!data) {\n\t\t\t\t// lazy till first invocation\n\t\t\t\tdata = [];\n\t\t\t\tidx = 0;\n\t\t\t\tthis._forEach(node, value => data.push(value));\n\t\t\t}\n\t\t\tif (idx >= data.length) {\n\t\t\t\treturn FIN;\n\t\t\t}\n\n\t\t\tif (!res) {\n\t\t\t\tres = { done: false, value: data[idx++] };\n\t\t\t} else {\n\t\t\t\tres.value = data[idx++];\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t\treturn { next };\n\t}\n\n\tforEach(callback: (value: E, index: string) => any) {\n\t\tthis._forEach(this._root, callback);\n\t}\n\n\tprivate _forEach(node: TernarySearchTreeNode<E> | undefined, callback: (value: E, index: string) => any) {\n\t\tif (node) {\n\t\t\t// left\n\t\t\tthis._forEach(node.left, callback);\n\n\t\t\t// node\n\t\t\tif (node.value) {\n\t\t\t\t// callback(node.value, this._iter.join(parts));\n\t\t\t\tcallback(node.value, node.key);\n\t\t\t}\n\t\t\t// mid\n\t\t\tthis._forEach(node.mid, callback);\n\n\t\t\t// right\n\t\t\tthis._forEach(node.right, callback);\n\t\t}\n\t}\n}\n\nexport class ResourceMap<T> {\n\n\tprotected readonly map: Map<string, T>;\n\tprotected readonly ignoreCase?: boolean;\n\n\tconstructor() {\n\t\tthis.map = new Map<string, T>();\n\t\tthis.ignoreCase = false; // in the future this should be an uri-comparator\n\t}\n\n\tset(resource: URI, value: T): void {\n\t\tthis.map.set(this.toKey(resource), value);\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource));\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T) => void): void {\n\t\tthis.map.forEach(clb);\n\t}\n\n\tvalues(): T[] {\n\t\treturn values(this.map);\n\t}\n\n\tprivate toKey(resource: URI): string {\n\t\tlet key = resource.toString();\n\t\tif (this.ignoreCase) {\n\t\t\tkey = key.toLowerCase();\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tkeys(): URI[] {\n\t\treturn keys(this.map).map(k => URI.parse(k));\n\t}\n\n\tclone(): ResourceMap<T> {\n\t\tconst resourceMap = new ResourceMap<T>();\n\n\t\tthis.map.forEach((value, key) => resourceMap.map.set(key, value));\n\n\t\treturn resourceMap;\n\t}\n}\n\n// We should fold BoundedMap and LinkedMap. See https://github.com/Microsoft/vscode/issues/28496\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> {\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): void {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tvalues(): V[] {\n\t\tconst result: V[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.value);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tkeys(): K[] {\n\t\tconst result: K[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.key);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n\tkeys(): IterableIterator<K> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<K> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<V> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\t*/\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn super.get(key, Touch.AsNew);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\tset(key: K, value: V): void {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { LRUCache } from 'vs/base/common/map';\nimport * as strings from 'vs/base/common/strings';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[] | null;\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] | null {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tconst match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n// Prefix\n\nexport const matchesStrictPrefix: IFilter = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix: IFilter = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\n\tlet matches: boolean;\n\tif (ignoreCase) {\n\t\tmatches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n\t} else {\n\t\tmatches = wordToMatchAgainst.indexOf(word) === 0;\n\t}\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tconst index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] | null = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn CharCode.a <= code && code <= CharCode.z;\n}\n\nexport function isUpper(code: number): boolean {\n\treturn CharCode.A <= code && code <= CharCode.Z;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn CharCode.Digit0 <= code && code <= CharCode.Digit9;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn (\n\t\tcode === CharCode.Space\n\t\t|| code === CharCode.Tab\n\t\t|| code === CharCode.LineFeed\n\t\t|| code === CharCode.CarriageReturn\n\t);\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tconst c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\ninterface ICamelCaseAnalysis {\n\tupperPercent: number;\n\tlowerPercent: number;\n\talphaPercent: number;\n\tnumericPercent: number;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word: string): ICamelCaseAnalysis {\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tconst upperPercent = upper / word.length;\n\tconst lowerPercent = lower / word.length;\n\tconst alphaPercent = alpha / word.length;\n\tconst numericPercent = numeric / word.length;\n\n\treturn { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\n\nfunction isUpperCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent } = analysis;\n\treturn lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] | null {\n\tif (!camelCaseWord) {\n\t\treturn null;\n\t}\n\n\tcamelCaseWord = camelCaseWord.trim();\n\n\tif (camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\tif (camelCaseWord.length > 60) {\n\t\treturn null;\n\t}\n\n\tconst analysis = analyzeCamelCaseWord(camelCaseWord);\n\n\tif (!isCamelCaseWord(analysis)) {\n\t\tif (!isUpperCaseWord(analysis)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tcamelCaseWord = camelCaseWord.toLowerCase();\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string, contiguous: boolean = false): IMatch[] | null {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\ttarget = target.toLowerCase();\n\twhile (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n\t\ti = nextWord(target, i + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, i: number, j: number, contiguous: boolean): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === target.length) {\n\t\treturn null;\n\t} else if (word[i] !== target[j]) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextWordIndex = j + 1;\n\t\tresult = _matchesWords(word, target, i + 1, j + 1, contiguous);\n\t\tif (!contiguous) {\n\t\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\t\tresult = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n\t\t\t\tnextWordIndex++;\n\t\t\t}\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tconst c = word.charCodeAt(i);\n\t\tif (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache<string, RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tconst match = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n\n/**\n * Match pattern againt word in a fuzzy way. As in IntelliSense and faster and more\n * powerfull than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern: string, word: string): IMatch[] | null {\n\tconst score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, true);\n\treturn score ? createMatches(score) : null;\n}\n\nexport function anyScore(pattern: string, lowPattern: string, _patternPos: number, word: string, lowWord: string, _wordPos: number): FuzzyScore {\n\tconst result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n\tif (result) {\n\t\treturn result;\n\t}\n\tlet matches = 0;\n\tlet score = 0;\n\tlet idx = _wordPos;\n\tfor (let patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n\t\tconst wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n\t\tif (wordPos >= 0) {\n\t\t\tscore += 1;\n\t\t\tmatches += 2 ** wordPos;\n\t\t\tidx = wordPos + 1;\n\t\t}\n\t}\n\treturn [score, matches, _wordPos];\n}\n\n//#region --- fuzzyScore ---\n\nexport function createMatches(score: undefined | FuzzyScore): IMatch[] {\n\tif (typeof score === 'undefined') {\n\t\treturn [];\n\t}\n\n\tconst matches = score[1].toString(2);\n\tconst wordStart = score[2];\n\tconst res: IMatch[] = [];\n\n\tfor (let pos = wordStart; pos < _maxLen; pos++) {\n\t\tif (matches[matches.length - (pos + 1)] === '1') {\n\t\t\tconst last = res[res.length - 1];\n\t\t\tif (last && last.end === pos) {\n\t\t\t\tlast.end = pos + 1;\n\t\t\t} else {\n\t\t\t\tres.push({ start: pos, end: pos + 1 });\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nconst _maxLen = 53;\n\nfunction initTable() {\n\tconst table: number[][] = [];\n\tconst row: number[] = [0];\n\tfor (let i = 1; i <= _maxLen; i++) {\n\t\trow.push(-i);\n\t}\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\tconst thisRow = row.slice(0);\n\t\tthisRow[0] = -i;\n\t\ttable.push(thisRow);\n\t}\n\treturn table;\n}\n\nconst _table = initTable();\nconst _scores = initTable();\nconst _arrows = <Arrow[][]>initTable();\nconst _debug = false;\n\nfunction printTable(table: number[][], pattern: string, patternLen: number, word: string, wordLen: number): string {\n\tfunction pad(s: string, n: number, pad = ' ') {\n\t\twhile (s.length < n) {\n\t\t\ts = pad + s;\n\t\t}\n\t\treturn s;\n\t}\n\tlet ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n\n\tfor (let i = 0; i <= patternLen; i++) {\n\t\tif (i === 0) {\n\t\t\tret += ' |';\n\t\t} else {\n\t\t\tret += `${pattern[i - 1]}|`;\n\t\t}\n\t\tret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n\t}\n\treturn ret;\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\tcase CharCode.DollarSign:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Tab:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n\treturn word[pos] !== wordLow[pos];\n}\n\nfunction isPatternInWord(patternLow: string, patternPos: number, patternLen: number, wordLow: string, wordPos: number, wordLen: number): boolean {\n\twhile (patternPos < patternLen && wordPos < wordLen) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\tpatternPos += 1;\n\t\t}\n\t\twordPos += 1;\n\t}\n\treturn patternPos === patternLen; // pattern must be exhausted\n}\n\nconst enum Arrow { Top = 0b1, Diag = 0b10, Left = 0b100 }\n\n/**\n * A tuple of three values.\n * 0. the score\n * 1. the matches encoded as bitmask (2^53)\n * 2. the offset at which matching started\n */\nexport type FuzzyScore = [number, number, number];\n\nexport namespace FuzzyScore {\n\t/**\n\t * No matches and value `-100`\n\t */\n\texport const Default: [-100, 0, 0] = [-100, 0, 0];\n\n\texport function isDefault(score?: FuzzyScore): score is [-100, 0, 0] {\n\t\treturn !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\n\t}\n}\n\nexport interface FuzzyScorer {\n\t(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined;\n}\n\nexport function fuzzyScore(pattern: string, patternLow: string, patternPos: number, word: string, wordLow: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\n\tconst patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n\tconst wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n\tif (patternPos >= patternLen || wordPos >= wordLen || patternLen > wordLen) {\n\t\treturn undefined;\n\t}\n\n\t// Run a simple check if the characters of pattern occur\n\t// (in order) at all in word. If that isn't the case we\n\t// stop because no match will be possible\n\tif (!isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen)) {\n\t\treturn undefined;\n\t}\n\n\tconst patternStartPos = patternPos;\n\tconst wordStartPos = wordPos;\n\n\t// There will be a mach, fill in tables\n\tfor (patternPos = patternStartPos + 1; patternPos <= patternLen; patternPos++) {\n\n\t\tfor (wordPos = 1; wordPos <= wordLen; wordPos++) {\n\n\t\t\tlet score = -1;\n\t\t\tif (patternLow[patternPos - 1] === wordLow[wordPos - 1]) {\n\n\t\t\t\tif (wordPos === (patternPos - patternStartPos)) {\n\t\t\t\t\t// common prefix: `foobar <-> foobaz`\n\t\t\t\t\t//                            ^^^^^\n\t\t\t\t\tif (pattern[patternPos - 1] === word[wordPos - 1]) {\n\t\t\t\t\t\tscore = 7;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = 5;\n\t\t\t\t\t}\n\t\t\t\t} else if (isUpperCaseAtPos(wordPos - 1, word, wordLow) && (wordPos === 1 || !isUpperCaseAtPos(wordPos - 2, word, wordLow))) {\n\t\t\t\t\t// hitting upper-case: `foo <-> forOthers`\n\t\t\t\t\t//                              ^^ ^\n\t\t\t\t\tif (pattern[patternPos - 1] === word[wordPos - 1]) {\n\t\t\t\t\t\tscore = 7;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = 5;\n\t\t\t\t\t}\n\t\t\t\t} else if (isSeparatorAtPos(wordLow, wordPos - 2) || isWhitespaceAtPos(wordLow, wordPos - 2)) {\n\t\t\t\t\t// post separator: `foo <-> bar_foo`\n\t\t\t\t\t//                              ^^^\n\t\t\t\t\tscore = 5;\n\n\t\t\t\t} else {\n\t\t\t\t\tscore = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_scores[patternPos][wordPos] = score;\n\n\t\t\tconst diag = _table[patternPos - 1][wordPos - 1] + (score > 1 ? 1 : score);\n\t\t\tconst top = _table[patternPos - 1][wordPos] + -1;\n\t\t\tconst left = _table[patternPos][wordPos - 1] + -1;\n\n\t\t\tif (left >= top) {\n\t\t\t\t// left or diag\n\t\t\t\tif (left > diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = left;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Left;\n\t\t\t\t} else if (left === diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = left;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Left | Arrow.Diag;\n\t\t\t\t} else {\n\t\t\t\t\t_table[patternPos][wordPos] = diag;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Diag;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// top or diag\n\t\t\t\tif (top > diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = top;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Top;\n\t\t\t\t} else if (top === diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = top;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Top | Arrow.Diag;\n\t\t\t\t} else {\n\t\t\t\t\t_table[patternPos][wordPos] = diag;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Diag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_debug) {\n\t\tconsole.log(printTable(_table, pattern, patternLen, word, wordLen));\n\t\tconsole.log(printTable(_arrows, pattern, patternLen, word, wordLen));\n\t\tconsole.log(printTable(_scores, pattern, patternLen, word, wordLen));\n\t}\n\n\t_matchesCount = 0;\n\t_topScore = -100;\n\t_patternStartPos = patternStartPos;\n\t_firstMatchCanBeWeak = firstMatchCanBeWeak;\n\t_findAllMatches2(patternLen, wordLen, patternLen === wordLen ? 1 : 0, 0, false);\n\tif (_matchesCount === 0) {\n\t\treturn undefined;\n\t}\n\n\treturn [_topScore, _topMatch2, wordStartPos];\n}\n\n\nlet _matchesCount: number = 0;\nlet _topMatch2: number = 0;\nlet _topScore: number = 0;\nlet _patternStartPos: number = 0;\nlet _firstMatchCanBeWeak: boolean = false;\n\nfunction _findAllMatches2(patternPos: number, wordPos: number, total: number, matches: number, lastMatched: boolean): void {\n\n\tif (_matchesCount >= 10 || total < -25) {\n\t\t// stop when having already 10 results, or\n\t\t// when a potential alignment as already 5 gaps\n\t\treturn;\n\t}\n\n\tlet simpleMatchCount = 0;\n\n\twhile (patternPos > _patternStartPos && wordPos > 0) {\n\n\t\tconst score = _scores[patternPos][wordPos];\n\t\tconst arrow = _arrows[patternPos][wordPos];\n\n\t\tif (arrow === Arrow.Left) {\n\t\t\t// left -> no match, skip a word character\n\t\t\twordPos -= 1;\n\t\t\tif (lastMatched) {\n\t\t\t\ttotal -= 5; // new gap penalty\n\t\t\t} else if (matches !== 0) {\n\t\t\t\ttotal -= 1; // gap penalty after first match\n\t\t\t}\n\t\t\tlastMatched = false;\n\t\t\tsimpleMatchCount = 0;\n\n\t\t} else if (arrow & Arrow.Diag) {\n\n\t\t\tif (arrow & Arrow.Left) {\n\t\t\t\t// left\n\t\t\t\t_findAllMatches2(\n\t\t\t\t\tpatternPos,\n\t\t\t\t\twordPos - 1,\n\t\t\t\t\tmatches !== 0 ? total - 1 : total, // gap penalty after first match\n\t\t\t\t\tmatches,\n\t\t\t\t\tlastMatched\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// diag\n\t\t\ttotal += score;\n\t\t\tpatternPos -= 1;\n\t\t\twordPos -= 1;\n\t\t\tlastMatched = true;\n\n\t\t\t// match -> set a 1 at the word pos\n\t\t\tmatches += 2 ** wordPos;\n\n\t\t\t// count simple matches and boost a row of\n\t\t\t// simple matches when they yield in a\n\t\t\t// strong match.\n\t\t\tif (score === 1) {\n\t\t\t\tsimpleMatchCount += 1;\n\n\t\t\t\tif (patternPos === _patternStartPos && !_firstMatchCanBeWeak) {\n\t\t\t\t\t// when the first match is a weak\n\t\t\t\t\t// match we discard it\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// boost\n\t\t\t\ttotal += 1 + (simpleMatchCount * (score - 1));\n\t\t\t\tsimpleMatchCount = 0;\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\ttotal -= wordPos >= 3 ? 9 : wordPos * 3; // late start penalty\n\n\t// dynamically keep track of the current top score\n\t// and insert the current best score at head, the rest at tail\n\t_matchesCount += 1;\n\tif (total > _topScore) {\n\t\t_topScore = total;\n\t\t_topMatch2 = matches;\n\t}\n}\n\n//#endregion\n\n\n//#region --- graceful ---\n\nexport function fuzzyScoreGracefulAggressive(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\n\nexport function fuzzyScoreGraceful(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, firstMatchCanBeWeak);\n}\n\nfunction fuzzyScoreWithPermutations(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, aggressive: boolean, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\tlet top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n\tif (top && !aggressive) {\n\t\t// when using the original pattern yield a result we`\n\t\t// return it unless we are aggressive and try to find\n\t\t// a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n\t\treturn top;\n\t}\n\n\tif (pattern.length >= 3) {\n\t\t// When the pattern is long enough then try a few (max 7)\n\t\t// permutations of the pattern to find a better match. The\n\t\t// permutations only swap neighbouring characters, e.g\n\t\t// `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n\t\tconst tries = Math.min(7, pattern.length - 1);\n\t\tfor (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n\t\t\tconst newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\t\t\tif (newPattern) {\n\t\t\t\tconst candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\t\t\t\tif (candidate) {\n\t\t\t\t\tcandidate[0] -= 3; // permutation penalty\n\t\t\t\t\tif (!top || candidate[0] > top[0]) {\n\t\t\t\t\t\ttop = candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn top;\n}\n\nfunction nextTypoPermutation(pattern: string, patternPos: number): string | undefined {\n\n\tif (patternPos + 1 >= pattern.length) {\n\t\treturn undefined;\n\t}\n\n\tconst swap1 = pattern[patternPos];\n\tconst swap2 = pattern[patternPos + 1];\n\n\tif (swap1 === swap2) {\n\t\treturn undefined;\n\t}\n\n\treturn pattern.slice(0, patternPos)\n\t\t+ swap2\n\t\t+ swap1\n\t\t+ pattern.slice(patternPos + 2);\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause | any;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && strings.endsWith(path, base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string, basename: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): any {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): any {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1 as string | IRelativePattern, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern = function (path: string, basename: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\t(<ParsedStringPattern><any>resultPattern).allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\t(<ParsedStringPattern><any>resultPattern).allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: any): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\n/**\n * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise\n */\nexport function parseToAsync(expression: IExpression, options?: IGlobOptions): ParsedExpression {\n\tconst parsedExpression = parse(expression, options);\n\treturn (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> => {\n\t\tconst result = parsedExpression(path, basename, hasSibling);\n\t\treturn isThenable(result) ? result : Promise.resolve(result);\n\t};\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename: string, name: string, hasSibling: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCache } from 'vs/base/common/map';\n\n/**\n * The normalize() method returns the Unicode Normalization Form of a given string. The form will be\n * the Normalization Form Canonical Composition.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}\n */\nexport const canNormalize = typeof ((<any>'').normalize) === 'function';\n\nconst nfcCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFC(str: string): string {\n\treturn normalize(str, 'NFC', nfcCache);\n}\n\nconst nfdCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFD(str: string): string {\n\treturn normalize(str, 'NFD', nfdCache);\n}\n\nconst nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nfunction normalize(str: string, form: string, normalizedCache: LRUCache<string, string>): string {\n\tif (!canNormalize || !str) {\n\t\treturn str;\n\t}\n\n\tconst cached = normalizedCache.get(str);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tlet res: string;\n\tif (nonAsciiCharactersPattern.test(str)) {\n\t\tres = (<any>str).normalize(form);\n\t} else {\n\t\tres = str;\n\t}\n\n\t// Use the cache for fast lookup\n\tnormalizedCache.set(str, res);\n\n\treturn res;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { equalsIgnoreCase } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ParsedExpression, IExpression, parse } from 'vs/base/common/glob';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport function getComparisonKey(resource: URI): string {\n\treturn hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();\n}\n\nexport function hasToIgnoreCase(resource: URI | undefined): boolean {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\n\nexport function basenameOrAuthority(resource: URI): string {\n\treturn basename(resource) || resource.authority;\n}\n\n/**\n * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n * @param base A uri which is \"longer\"\n * @param parentCandidate A uri which is \"shorter\" then `base`\n */\nexport function isEqualOrParent(base: URI, parentCandidate: URI, ignoreCase = hasToIgnoreCase(base)): boolean {\n\tif (base.scheme === parentCandidate.scheme) {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase);\n\t\t}\n\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Tests wheter the two authorities are the same\n */\nexport function isEqualAuthority(a1: string, a2: string) {\n\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n}\n\nexport function isEqual(first: URI | undefined, second: URI | undefined, ignoreCase = hasToIgnoreCase(first)): boolean {\n\tif (first === second) {\n\t\treturn true;\n\t}\n\n\tif (!first || !second) {\n\t\treturn false;\n\t}\n\n\tif (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n\t\treturn false;\n\t}\n\n\tconst p1 = first.path || '/', p2 = second.path || '/';\n\treturn p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\n}\n\nexport function basename(resource: URI): string {\n\treturn paths.posix.basename(resource.path);\n}\n\nexport function extname(resource: URI): string {\n\treturn paths.posix.extname(resource.path);\n}\n\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\nexport function dirname(resource: URI): URI {\n\tif (resource.path.length === 0) {\n\t\treturn resource;\n\t}\n\tif (resource.scheme === Schemas.file) {\n\t\treturn URI.file(paths.dirname(originalFSPath(resource)));\n\t}\n\tlet dirname = paths.posix.dirname(resource.path);\n\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t}\n\treturn resource.with({\n\t\tpath: dirname\n\t});\n}\n\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\nexport function joinPath(resource: URI, ...pathFragment: string[]): URI {\n\tlet joinedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tjoinedPath = URI.file(paths.join(originalFSPath(resource), ...pathFragment)).path;\n\t} else {\n\t\tjoinedPath = paths.posix.join(resource.path || '/', ...pathFragment);\n\t}\n\treturn resource.with({\n\t\tpath: joinedPath\n\t});\n}\n\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\nexport function normalizePath(resource: URI): URI {\n\tif (!resource.path.length) {\n\t\treturn resource;\n\t}\n\tlet normalizedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t} else {\n\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t}\n\treturn resource.with({\n\t\tpath: normalizedPath\n\t});\n}\n\n/**\n * Returns the fsPath of an URI where the drive letter is not normalized.\n * See #56403.\n */\nexport function originalFSPath(uri: URI): string {\n\tlet value: string;\n\tconst uriPath = uri.path;\n\tif (uri.authority && uriPath.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uriPath}`;\n\t} else if (\n\t\tisWindows\n\t\t&& uriPath.charCodeAt(0) === CharCode.Slash\n\t\t&& extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n\t\t&& uriPath.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tvalue = uriPath.substr(1);\n\t} else {\n\t\t// other path\n\t\tvalue = uriPath;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Returns true if the URI path is absolute.\n */\nexport function isAbsolutePath(resource: URI): boolean {\n\treturn !!resource.path && resource.path[0] === '/';\n}\n\n/**\n * Returns true if the URI path has a trailing path separator\n */\nexport function hasTrailingPathSeparator(resource: URI): boolean {\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === paths.sep;\n\t} else {\n\t\tconst p = resource.path;\n\t\treturn p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash; // ignore the slash at offset 0\n\t}\n}\n\n\n/**\n * Removes a trailing path seperator, if theres one.\n * Important: Doesn't remove the first slash, it would make the URI invalid\n */\nexport function removeTrailingPathSeparator(resource: URI): URI {\n\tif (hasTrailingPathSeparator(resource)) {\n\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t}\n\treturn resource;\n}\n\n\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\nexport function relativePath(from: URI, to: URI): string | undefined {\n\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\treturn undefined;\n\t}\n\tif (from.scheme === Schemas.file) {\n\t\tconst relativePath = paths.relative(from.path, to.path);\n\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t}\n\treturn paths.posix.relative(from.path || '/', to.path || '/');\n}\n\n/**\n * Resolves a absolute or relative path against a base URI.\n */\nexport function resolvePath(base: URI, path: string): URI {\n\tlet resolvedPath: string;\n\tif (base.scheme === Schemas.file) {\n\t\tresolvedPath = URI.file(paths.resolve(originalFSPath(base), path)).path;\n\t} else {\n\t\tresolvedPath = paths.posix.resolve(base.path, path);\n\t}\n\treturn base.with({\n\t\tpath: resolvedPath\n\t});\n}\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\n\nexport class ResourceGlobMatcher {\n\n\tprivate readonly globalExpression: ParsedExpression;\n\tprivate readonly expressionsByRoot: TernarySearchTree<{ root: URI, expression: ParsedExpression }> = TernarySearchTree.forPaths<{ root: URI, expression: ParsedExpression }>();\n\n\tconstructor(\n\t\tglobalExpression: IExpression,\n\t\trootExpressions: { root: URI, expression: IExpression }[]\n\t) {\n\t\tthis.globalExpression = parse(globalExpression);\n\t\tfor (const expression of rootExpressions) {\n\t\t\tthis.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: parse(expression.expression) });\n\t\t}\n\t}\n\n\tmatches(resource: URI): boolean {\n\t\tconst rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n\t\tif (rootExpression) {\n\t\t\tconst path = relativePath(rootExpression.root, resource);\n\t\t\tif (path && !!rootExpression.expression(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn !!this.globalExpression(resource.path);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents a UUID as defined by rfc4122.\n */\nexport interface UUID {\n\n\t/**\n\t * @returns the canonical representation in sets of hexadecimal numbers separated by dashes.\n\t */\n\tasHex(): string;\n}\n\nclass ValueUUID implements UUID {\n\n\tconstructor(public _value: string) {\n\t\t// empty\n\t}\n\n\tpublic asHex(): string {\n\t\treturn this._value;\n\t}\n}\n\nclass V4UUID extends ValueUUID {\n\n\tprivate static readonly _chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\tprivate static readonly _timeHighBits = ['8', '9', 'a', 'b'];\n\n\tprivate static _oneOf(array: string[]): string {\n\t\treturn array[Math.floor(array.length * Math.random())];\n\t}\n\n\tprivate static _randomHex(): string {\n\t\treturn V4UUID._oneOf(V4UUID._chars);\n\t}\n\n\tconstructor() {\n\t\tsuper([\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\t'4',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._oneOf(V4UUID._timeHighBits),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t].join(''));\n\t}\n}\n\nexport function v4(): UUID {\n\treturn new V4UUID();\n}\n\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\nexport function isUUID(value: string): boolean {\n\treturn _UUIDPattern.test(value);\n}\n\n/**\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\n * @param value A uuid string.\n */\nexport function parse(value: string): UUID {\n\tif (!isUUID(value)) {\n\t\tthrow new Error('invalid uuid');\n\t}\n\n\treturn new ValueUUID(value);\n}\n\nexport function generateUuid(): string {\n\treturn v4().asHex();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IRemoteConsoleLog {\n\ttype: string;\n\tseverity: string;\n\targuments: string;\n}\n\ninterface IStackArgument {\n\t__$stack: string;\n}\n\nexport interface IStackFrame {\n\turi: URI;\n\tline: number;\n\tcolumn: number;\n}\n\nexport function isRemoteConsoleLog(obj: any): obj is IRemoteConsoleLog {\n\tconst entry = obj as IRemoteConsoleLog;\n\n\treturn entry && typeof entry.type === 'string' && typeof entry.severity === 'string';\n}\n\nexport function parse(entry: IRemoteConsoleLog): { args: any[], stack?: string } {\n\tconst args: any[] = [];\n\tlet stack: string | undefined;\n\n\t// Parse Entry\n\ttry {\n\t\tconst parsedArguments: any[] = JSON.parse(entry.arguments);\n\n\t\t// Check for special stack entry as last entry\n\t\tconst stackArgument = parsedArguments[parsedArguments.length - 1] as IStackArgument;\n\t\tif (stackArgument && stackArgument.__$stack) {\n\t\t\tparsedArguments.pop(); // stack is handled specially\n\t\t\tstack = stackArgument.__$stack;\n\t\t}\n\n\t\targs.push(...parsedArguments);\n\t} catch (error) {\n\t\targs.push('Unable to log remote console arguments', entry.arguments);\n\t}\n\n\treturn { args, stack };\n}\n\nexport function getFirstFrame(entry: IRemoteConsoleLog): IStackFrame | undefined;\nexport function getFirstFrame(stack: string | undefined): IStackFrame | undefined;\nexport function getFirstFrame(arg0: IRemoteConsoleLog | string | undefined): IStackFrame | undefined {\n\tif (typeof arg0 !== 'string') {\n\t\treturn getFirstFrame(parse(arg0!).stack);\n\t}\n\n\t// Parse a source information out of the stack if we have one. Format can be:\n\t// at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)\n\t// or\n\t// at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17\n\t// or\n\t// at c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17\n\t// or\n\t// at e.$executeContributedCommand(c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17)\n\tconst stack = arg0;\n\tif (stack) {\n\t\tconst topFrame = findFirstFrame(stack);\n\n\t\t// at [^\\/]* => line starts with \"at\" followed by any character except '/' (to not capture unix paths too late)\n\t\t// (?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\) => windows drive letter OR unix root OR unc root\n\t\t// (?:.+) => simple pattern for the path, only works because of the line/col pattern after\n\t\t// :(?:\\d+):(?:\\d+) => :line:column data\n\t\tconst matches = /at [^\\/]*((?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\))(?:.+)):(\\d+):(\\d+)/.exec(topFrame || '');\n\t\tif (matches && matches.length === 4) {\n\t\t\treturn {\n\t\t\t\turi: URI.file(matches[1]),\n\t\t\t\tline: Number(matches[2]),\n\t\t\t\tcolumn: Number(matches[3])\n\t\t\t} as IStackFrame;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction findFirstFrame(stack: string | undefined): string | undefined {\n\tif (!stack) {\n\t\treturn stack;\n\t}\n\n\tconst newlineIndex = stack.indexOf('\\n');\n\tif (newlineIndex === -1) {\n\t\treturn stack;\n\t}\n\n\treturn stack.substring(0, newlineIndex);\n}\n\nexport function log(entry: IRemoteConsoleLog, label: string): void {\n\tconst { args, stack } = parse(entry);\n\n\tconst isOneStringArg = typeof args[0] === 'string' && args.length === 1;\n\n\tlet topFrame = findFirstFrame(stack);\n\tif (topFrame) {\n\t\ttopFrame = `(${topFrame.trim()})`;\n\t}\n\n\tlet consoleArgs: string[] = [];\n\n\t// First arg is a string\n\tif (typeof args[0] === 'string') {\n\t\tif (topFrame && isOneStringArg) {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color('black'), color('grey')];\n\t\t} else {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color('black'), ...args.slice(1)];\n\t\t}\n\t}\n\n\t// First arg is something else, just apply all\n\telse {\n\t\tconsoleArgs = [`%c[${label}]%`, color('blue'), ...args];\n\t}\n\n\t// Stack: add to args unless already aded\n\tif (topFrame && !isOneStringArg) {\n\t\tconsoleArgs.push(topFrame);\n\t}\n\n\t// Log it\n\tconsole[entry.severity].apply(console, consoleArgs);\n}\n\nfunction color(color: string): string {\n\treturn `color: ${color}`;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as sd from 'string_decoder';\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * Convenient way to iterate over output line by line. This helper accommodates for the fact that\n * a buffer might not end with new lines all the way.\n *\n * To use:\n * - call the write method\n * - forEach() over the result to get the lines\n */\nexport class LineDecoder {\n\tprivate stringDecoder: sd.NodeStringDecoder;\n\tprivate remaining: string | null;\n\n\tconstructor(encoding: string = 'utf8') {\n\t\tthis.stringDecoder = new sd.StringDecoder(encoding);\n\t\tthis.remaining = null;\n\t}\n\n\tpublic write(buffer: Buffer): string[] {\n\t\tconst result: string[] = [];\n\t\tconst value = this.remaining\n\t\t\t? this.remaining + this.stringDecoder.write(buffer)\n\t\t\t: this.stringDecoder.write(buffer);\n\n\t\tif (value.length < 1) {\n\t\t\treturn result;\n\t\t}\n\t\tlet start = 0;\n\t\tlet ch: number;\n\t\tlet idx = start;\n\t\twhile (idx < value.length) {\n\t\t\tch = value.charCodeAt(idx);\n\t\t\tif (ch === CharCode.CarriageReturn || ch === CharCode.LineFeed) {\n\t\t\t\tresult.push(value.substring(start, idx));\n\t\t\t\tidx++;\n\t\t\t\tif (idx < value.length) {\n\t\t\t\t\tconst lastChar = ch;\n\t\t\t\t\tch = value.charCodeAt(idx);\n\t\t\t\t\tif ((lastChar === CharCode.CarriageReturn && ch === CharCode.LineFeed) || (lastChar === CharCode.LineFeed && ch === CharCode.CarriageReturn)) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = idx;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tthis.remaining = start < value.length ? value.substr(start) : null;\n\t\treturn result;\n\t}\n\n\tpublic end(): string | null {\n\t\treturn this.remaining;\n\t}\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\n\n/**\n * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as\n * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.\n */\nexport function parallel<T, E>(list: T[], fn: (item: T, callback: (err: Error | null, result: E | null) => void) => void, callback: (err: Array<Error | null> | null, result: E[]) => void): void {\n\tconst results = new Array(list.length);\n\tconst errors = new Array<Error | null>(list.length);\n\tlet didErrorOccur = false;\n\tlet doneCount = 0;\n\n\tif (list.length === 0) {\n\t\treturn callback(null, []);\n\t}\n\n\tlist.forEach((item, index) => {\n\t\tfn(item, (error, result) => {\n\t\t\tif (error) {\n\t\t\t\tdidErrorOccur = true;\n\t\t\t\tresults[index] = null;\n\t\t\t\terrors[index] = error;\n\t\t\t} else {\n\t\t\t\tresults[index] = result;\n\t\t\t\terrors[index] = null;\n\t\t\t}\n\n\t\t\tif (++doneCount === list.length) {\n\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Executes the given function (fn) over the given array of items (param) in sequential order and returns the first occurred error or the result as\n * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function. The first param can\n * either be a function that returns an array of results to loop in async fashion or be an array of items already.\n */\nexport function loop<T, E>(param: (callback: (error: Error, result: T[]) => void) => void, fn: (item: T, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void;\nexport function loop<T, E>(param: T[], fn: (item: T, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void;\nexport function loop<E>(param: any, fn: (item: any, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void {\n\n\t// Assert\n\tassert.ok(param, 'Missing first parameter');\n\tassert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');\n\tassert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');\n\n\t// Param is function, execute to retrieve array\n\tif (typeof (param) === 'function') {\n\t\ttry {\n\t\t\tparam((error: Error, result: E[]) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tcallback(error, null);\n\t\t\t\t} else {\n\t\t\t\t\tloop(result, fn, callback);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tcallback(error, null);\n\t\t}\n\t}\n\n\t// Expect the param to be an array and loop over it\n\telse {\n\t\tconst results: E[] = [];\n\n\t\tconst looper: (i: number) => void = function (i: number): void {\n\n\t\t\t// Still work to do\n\t\t\tif (i < param.length) {\n\n\t\t\t\t// Execute function on array element\n\t\t\t\ttry {\n\t\t\t\t\tfn(param[i], (error: any, result: E) => {\n\n\t\t\t\t\t\t// A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n\t\t\t\t\t\tif (error === true || error === false) {\n\t\t\t\t\t\t\tresult = error;\n\t\t\t\t\t\t\terror = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Quit looping on error\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\tcallback(error, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise push result on stack and continue looping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (result) { //Could be that provided function is not returning a result\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\t\t\t\tlooper(i + 1);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, i, param.length);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcallback(error, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Done looping, pass back results too callback function\n\t\t\telse {\n\t\t\t\tcallback(null, results);\n\t\t\t}\n\t\t};\n\n\t\t// Start looping with first element in array\n\t\tlooper(0);\n\t}\n}\n\nfunction Sequence(sequences: { (...param: any[]): void; }[]): void {\n\n\t// Assert\n\tassert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');\n\tsequences.forEach((sequence) => {\n\t\tassert.ok(typeof (sequence) === 'function');\n\t});\n\n\t// Execute in Loop\n\tconst errorHandler = sequences.splice(0, 1)[0]; //Remove error handler\n\tlet sequenceResult: any = null;\n\n\tloop(sequences, (sequence, clb) => {\n\t\tconst sequenceFunction = function (error: any, result: any): void {\n\n\t\t\t// A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n\t\t\tif (error === true || error === false) {\n\t\t\t\tresult = error;\n\t\t\t\terror = null;\n\t\t\t}\n\n\t\t\t// Handle Error and Result\n\t\t\tif (error) {\n\t\t\t\tclb(error, null);\n\t\t\t} else {\n\t\t\t\tsequenceResult = result; //Remember result of sequence\n\t\t\t\tclb(null, null); //Don't pass on result to Looper as we are not aggregating it\n\t\t\t}\n\t\t};\n\n\t\t// We call the sequence function setting \"this\" to be the callback we define here\n\t\t// and we pass in the \"sequenceResult\" as first argument. Doing all this avoids having\n\t\t// to pass in a callback to the sequence because the callback is already \"this\".\n\t\ttry {\n\t\t\tsequence.call(sequenceFunction, sequenceResult);\n\t\t} catch (error) {\n\t\t\tclb(error, null);\n\t\t}\n\t}, (error, result) => {\n\t\tif (error) {\n\t\t\terrorHandler(error);\n\t\t}\n\t});\n}\n\n/**\n * Takes a variable list of functions to execute in sequence. The first function must be the error handler and the\n * following functions can do arbitrary work. \"this\" must be used as callback value for async functions to continue\n * through the sequence:\n * \tsequence(\n * \t\tfunction errorHandler(error) {\n * \t\t\tclb(error, null);\n * \t\t},\n *\n * \t\tfunction doSomethingAsync() {\n * \t\t\tfs.doAsync(path, this);\n * \t\t},\n *\n * \t\tfunction done(result) {\n * \t\t\tclb(null, result);\n * \t\t}\n * \t);\n */\nexport function sequence(errorHandler: (error: Error) => void, ...sequences: Function[]): void;\nexport function sequence(sequences: Function[]): void;\nexport function sequence(sequences: any): void {\n\tSequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\n\nexport interface ReadResult {\n\tbuffer: Buffer | null;\n\tbytesRead: number;\n}\n\n/**\n * Reads totalBytes from the provided file.\n */\nexport function readExactlyByFile(file: string, totalBytes: number): Promise<ReadResult> {\n\treturn new Promise<ReadResult>((resolve, reject) => {\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, resultBuffer: Buffer | null, bytesRead: number): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ buffer: resultBuffer, bytesRead });\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(totalBytes);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, totalBytes - offset, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tif (offset === totalBytes) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t});\n\t});\n}\n\n/**\n * Reads a file until a matching string is found.\n *\n * @param file The file to read.\n * @param matchingString The string to search for.\n * @param chunkBytes The number of bytes to read each iteration.\n * @param maximumBytesToRead The maximum number of bytes to read before giving up.\n * @param callback The finished callback.\n */\nexport function readToMatchingString(file: string, matchingString: string, chunkBytes: number, maximumBytesToRead: number): Promise<string | null> {\n\treturn new Promise<string | null>((resolve, reject) =>\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, result: string | null): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve(result);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(maximumBytesToRead);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, chunkBytes, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, null);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tconst newLineIndex = buffer.indexOf(matchingString);\n\t\t\t\t\tif (newLineIndex >= 0) {\n\t\t\t\t\t\treturn end(null, buffer.toString('utf8').substr(0, newLineIndex));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (offset >= maximumBytesToRead) {\n\t\t\t\t\t\treturn end(new Error(`Could not find ${matchingString} in first ${maximumBytesToRead} bytes of ${file}`), null);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t})\n\t);\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as stream from 'vs/base/node/stream';\nimport * as iconv from 'iconv-lite';\nimport { isLinux, isMacintosh } from 'vs/base/common/platform';\nimport { exec } from 'child_process';\nimport { Readable, Writable } from 'stream';\n\nexport const UTF8 = 'utf8';\nexport const UTF8_with_bom = 'utf8bom';\nexport const UTF16be = 'utf16be';\nexport const UTF16le = 'utf16le';\n\nexport interface IDecodeStreamOptions {\n\tguessEncoding?: boolean;\n\tminBytesRequiredForDetection?: number;\n\toverwriteEncoding?(detectedEncoding: string | null): string;\n}\n\nexport function toDecodeStream(readable: Readable, options: IDecodeStreamOptions): Promise<{ detected: IDetectedEncodingResult, stream: NodeJS.ReadableStream }> {\n\tif (!options.minBytesRequiredForDetection) {\n\t\toptions.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;\n\t}\n\n\tif (!options.overwriteEncoding) {\n\t\toptions.overwriteEncoding = detected => detected || UTF8;\n\t}\n\n\treturn new Promise<{ detected: IDetectedEncodingResult, stream: NodeJS.ReadableStream }>((resolve, reject) => {\n\n\t\treadable.on('error', reject);\n\n\t\treadable.pipe(new class extends Writable {\n\n\t\t\tprivate _decodeStream: NodeJS.ReadWriteStream;\n\t\t\tprivate _decodeStreamConstruction: Promise<any>;\n\t\t\tprivate _buffer: Buffer[] = [];\n\t\t\tprivate _bytesBuffered = 0;\n\n\t\t\t_write(chunk: any, encoding: string, callback: Function): void {\n\t\t\t\tif (!Buffer.isBuffer(chunk)) {\n\t\t\t\t\tcallback(new Error('data must be a buffer'));\n\t\t\t\t}\n\n\t\t\t\tif (this._decodeStream) {\n\t\t\t\t\t// just a forwarder now\n\t\t\t\t\tthis._decodeStream.write(chunk, callback);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._buffer.push(chunk);\n\t\t\t\tthis._bytesBuffered += chunk.length;\n\n\t\t\t\tif (this._decodeStreamConstruction) {\n\t\t\t\t\t// waiting for the decoder to be ready\n\t\t\t\t\tthis._decodeStreamConstruction.then(_ => callback(), err => callback(err));\n\n\t\t\t\t} else if (typeof options.minBytesRequiredForDetection === 'number' && this._bytesBuffered >= options.minBytesRequiredForDetection) {\n\t\t\t\t\t// buffered enough data, create stream and forward data\n\t\t\t\t\tthis._startDecodeStream(callback);\n\n\t\t\t\t} else {\n\t\t\t\t\t// only buffering\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_startDecodeStream(callback: Function): void {\n\n\t\t\t\tthis._decodeStreamConstruction = Promise.resolve(detectEncodingFromBuffer({\n\t\t\t\t\tbuffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered\n\t\t\t\t}, options.guessEncoding)).then(detected => {\n\t\t\t\t\tif (options.overwriteEncoding) {\n\t\t\t\t\t\tdetected.encoding = options.overwriteEncoding(detected.encoding);\n\t\t\t\t\t}\n\t\t\t\t\tthis._decodeStream = decodeStream(detected.encoding);\n\t\t\t\t\tfor (const buffer of this._buffer) {\n\t\t\t\t\t\tthis._decodeStream.write(buffer);\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t\tresolve({ detected, stream: this._decodeStream });\n\n\t\t\t\t}, err => {\n\t\t\t\t\tthis.emit('error', err);\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_final(callback: (err?: any) => any) {\n\t\t\t\tif (this._decodeStream) {\n\t\t\t\t\t// normal finish\n\t\t\t\t\tthis._decodeStream.end(callback);\n\t\t\t\t} else {\n\t\t\t\t\t// we were still waiting for data...\n\t\t\t\t\tthis._startDecodeStream(() => this._decodeStream.end(callback));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport function bomLength(encoding: string): number {\n\tswitch (encoding) {\n\t\tcase UTF8:\n\t\t\treturn 3;\n\t\tcase UTF16be:\n\t\tcase UTF16le:\n\t\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n\nexport function decode(buffer: Buffer, encoding: string): string {\n\treturn iconv.decode(buffer, toNodeEncoding(encoding));\n}\n\nexport function encode(content: string | Buffer, encoding: string, options?: { addBOM?: boolean }): Buffer {\n\treturn iconv.encode(content, toNodeEncoding(encoding), options);\n}\n\nexport function encodingExists(encoding: string): boolean {\n\treturn iconv.encodingExists(toNodeEncoding(encoding));\n}\n\nexport function decodeStream(encoding: string | null): NodeJS.ReadWriteStream {\n\treturn iconv.decodeStream(toNodeEncoding(encoding));\n}\n\nexport function encodeStream(encoding: string, options?: { addBOM?: boolean }): NodeJS.ReadWriteStream {\n\treturn iconv.encodeStream(toNodeEncoding(encoding), options);\n}\n\nfunction toNodeEncoding(enc: string | null): string {\n\tif (enc === UTF8_with_bom || enc === null) {\n\t\treturn UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n\t}\n\n\treturn enc;\n}\n\nexport function detectEncodingByBOMFromBuffer(buffer: Buffer | null, bytesRead: number): string | null {\n\tif (!buffer || bytesRead < 2) {\n\t\treturn null;\n\t}\n\n\tconst b0 = buffer.readUInt8(0);\n\tconst b1 = buffer.readUInt8(1);\n\n\t// UTF-16 BE\n\tif (b0 === 0xFE && b1 === 0xFF) {\n\t\treturn UTF16be;\n\t}\n\n\t// UTF-16 LE\n\tif (b0 === 0xFF && b1 === 0xFE) {\n\t\treturn UTF16le;\n\t}\n\n\tif (bytesRead < 3) {\n\t\treturn null;\n\t}\n\n\tconst b2 = buffer.readUInt8(2);\n\n\t// UTF-8\n\tif (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {\n\t\treturn UTF8;\n\t}\n\n\treturn null;\n}\n\n/**\n * Detects the Byte Order Mark in a given file.\n * If no BOM is detected, null will be passed to callback.\n */\nexport function detectEncodingByBOM(file: string): Promise<string | null> {\n\treturn stream.readExactlyByFile(file, 3).then(({ buffer, bytesRead }) => detectEncodingByBOMFromBuffer(buffer, bytesRead));\n}\n\nconst MINIMUM_THRESHOLD = 0.2;\nconst IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];\n\n/**\n * Guesses the encoding from buffer.\n */\nexport function guessEncodingByBuffer(buffer: Buffer): Promise<string | null> {\n\treturn import('jschardet').then(jschardet => {\n\t\tjschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;\n\n\t\tconst guessed = jschardet.detect(buffer);\n\t\tif (!guessed || !guessed.encoding) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst enc = guessed.encoding.toLowerCase();\n\n\t\t// Ignore encodings that cannot guess correctly\n\t\t// (http://chardet.readthedocs.io/en/latest/supported-encodings.html)\n\t\tif (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn toIconvLiteEncoding(guessed.encoding);\n\t});\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\t'ibm866': 'cp866',\n\t'big5': 'cp950'\n};\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\n/**\n * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n * See https://encoding.spec.whatwg.org/#names-and-labels\n * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n */\nexport function toCanonicalName(enc: string): string {\n\tswitch (enc) {\n\t\tcase 'shiftjis':\n\t\t\treturn 'shift-jis';\n\t\tcase 'utf16le':\n\t\t\treturn 'utf-16le';\n\t\tcase 'utf16be':\n\t\t\treturn 'utf-16be';\n\t\tcase 'big5hkscs':\n\t\t\treturn 'big5-hkscs';\n\t\tcase 'eucjp':\n\t\t\treturn 'euc-jp';\n\t\tcase 'euckr':\n\t\t\treturn 'euc-kr';\n\t\tcase 'koi8r':\n\t\t\treturn 'koi8-r';\n\t\tcase 'koi8u':\n\t\t\treturn 'koi8-u';\n\t\tcase 'macroman':\n\t\t\treturn 'x-mac-roman';\n\t\tcase 'utf8bom':\n\t\t\treturn 'utf8';\n\t\tdefault:\n\t\t\tconst m = enc.match(/windows(\\d+)/);\n\t\t\tif (m) {\n\t\t\t\treturn 'windows-' + m[1];\n\t\t\t}\n\n\t\t\treturn enc;\n\t}\n}\n\nconst ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not\nconst NO_GUESS_BUFFER_MAX_LEN = 512; \t\t\t// when not auto guessing the encoding, small number of bytes are enough\nconst AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; \t\t// with auto guessing we want a lot more content to be read for guessing\n\nexport interface IDetectedEncodingResult {\n\tencoding: string | null;\n\tseemsBinary: boolean;\n}\n\nexport function detectEncodingFromBuffer(readResult: stream.ReadResult, autoGuessEncoding?: false): IDetectedEncodingResult;\nexport function detectEncodingFromBuffer(readResult: stream.ReadResult, autoGuessEncoding?: boolean): Promise<IDetectedEncodingResult>;\nexport function detectEncodingFromBuffer({ buffer, bytesRead }: stream.ReadResult, autoGuessEncoding?: boolean): Promise<IDetectedEncodingResult> | IDetectedEncodingResult {\n\n\t// Always first check for BOM to find out about encoding\n\tlet encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n\t// Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n\t// unless we already know that this file has a UTF-16 encoding\n\tlet seemsBinary = false;\n\tif (encoding !== UTF16be && encoding !== UTF16le && buffer) {\n\t\tlet couldBeUTF16LE = true; // e.g. 0xAA 0x00\n\t\tlet couldBeUTF16BE = true; // e.g. 0x00 0xAA\n\t\tlet containsZeroByte = false;\n\n\t\t// This is a simplified guess to detect UTF-16 BE or LE by just checking if\n\t\t// the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n\t\t// this would be the odd byte index and for UTF-16 BE the even one.\n\t\t// Note: this can produce false positives (a binary file that uses a 2-byte\n\t\t// encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n\t\t// that is using 4 bytes to encode a character).\n\t\tfor (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n\t\t\tconst isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n\t\t\tconst isZeroByte = (buffer.readInt8(i) === 0);\n\n\t\t\tif (isZeroByte) {\n\t\t\t\tcontainsZeroByte = true;\n\t\t\t}\n\n\t\t\t// UTF-16 LE: expect e.g. 0xAA 0x00\n\t\t\tif (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n\t\t\t\tcouldBeUTF16LE = false;\n\t\t\t}\n\n\t\t\t// UTF-16 BE: expect e.g. 0x00 0xAA\n\t\t\tif (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n\t\t\t\tcouldBeUTF16BE = false;\n\t\t\t}\n\n\t\t\t// Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n\t\t\tif (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Handle case of 0-byte included\n\t\tif (containsZeroByte) {\n\t\t\tif (couldBeUTF16LE) {\n\t\t\t\tencoding = UTF16le;\n\t\t\t} else if (couldBeUTF16BE) {\n\t\t\t\tencoding = UTF16be;\n\t\t\t} else {\n\t\t\t\tseemsBinary = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Auto guess encoding if configured\n\tif (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n\t\treturn guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(guessedEncoding => {\n\t\t\treturn {\n\t\t\t\tseemsBinary: false,\n\t\t\t\tencoding: guessedEncoding\n\t\t\t};\n\t\t});\n\t}\n\n\treturn { seemsBinary, encoding };\n}\n\n// https://ss64.com/nt/chcp.html\nconst windowsTerminalEncodings = {\n\t'437': 'cp437', // United States\n\t'850': 'cp850', // Multilingual(Latin I)\n\t'852': 'cp852', // Slavic(Latin II)\n\t'855': 'cp855', // Cyrillic(Russian)\n\t'857': 'cp857', // Turkish\n\t'860': 'cp860', // Portuguese\n\t'861': 'cp861', // Icelandic\n\t'863': 'cp863', // Canadian - French\n\t'865': 'cp865', // Nordic\n\t'866': 'cp866', // Russian\n\t'869': 'cp869', // Modern Greek\n\t'936': 'cp936', // Simplified Chinese\n\t'1252': 'cp1252' // West European Latin\n};\n\nexport function resolveTerminalEncoding(verbose?: boolean): Promise<string> {\n\tlet rawEncodingPromise: Promise<string>;\n\n\t// Support a global environment variable to win over other mechanics\n\tconst cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];\n\tif (cliEncodingEnv) {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Found VSCODE_CLI_ENCODING variable: ${cliEncodingEnv}`);\n\t\t}\n\n\t\trawEncodingPromise = Promise.resolve(cliEncodingEnv);\n\t}\n\n\t// Linux/Mac: use \"locale charmap\" command\n\telse if (isLinux || isMacintosh) {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"locale charmap\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('locale charmap', (err, stdout, stderr) => resolve(stdout));\n\t\t});\n\t}\n\n\t// Windows: educated guess\n\telse {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"chcp\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('chcp', (err, stdout, stderr) => {\n\t\t\t\tif (stdout) {\n\t\t\t\t\tconst windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);\n\t\t\t\t\tfor (const key of windowsTerminalEncodingKeys) {\n\t\t\t\t\t\tif (stdout.indexOf(key) >= 0) {\n\t\t\t\t\t\t\treturn resolve(windowsTerminalEncodings[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn rawEncodingPromise.then(rawEncoding => {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Detected raw terminal encoding: ${rawEncoding}`);\n\t\t}\n\n\t\tif (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === UTF8) {\n\t\t\treturn UTF8;\n\t\t}\n\n\t\tconst iconvEncoding = toIconvLiteEncoding(rawEncoding);\n\t\tif (iconv.encodingExists(iconvEncoding)) {\n\t\t\treturn iconvEncoding;\n\t\t}\n\n\t\tif (verbose) {\n\t\t\tconsole.log('Unsupported terminal encoding, falling back to UTF-8.');\n\t\t}\n\n\t\treturn UTF8;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as paths from 'vs/base/common/path';\nimport { nfcall } from 'vs/base/common/async';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport * as platform from 'vs/base/common/platform';\nimport * as strings from 'vs/base/common/strings';\nimport * as uuid from 'vs/base/common/uuid';\nimport { encode, encodeStream } from 'vs/base/node/encoding';\nimport * as flow from 'vs/base/node/flow';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IDisposable, toDisposable, Disposable } from 'vs/base/common/lifecycle';\n\nconst loop = flow.loop;\n\nexport function readdirSync(path: string): string[] {\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\treturn fs.readdirSync(path).map(c => normalizeNFC(c));\n\t}\n\n\treturn fs.readdirSync(path);\n}\n\nexport function readdir(path: string, callback: (error: Error | null, files: string[]) => void): void {\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\treturn fs.readdir(path, (error, children) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(error, []);\n\t\t\t}\n\n\t\t\treturn callback(null, children.map(c => normalizeNFC(c)));\n\t\t});\n\t}\n\n\treturn fs.readdir(path, callback);\n}\n\nexport interface IStatAndLink {\n\tstat: fs.Stats;\n\tisSymbolicLink: boolean;\n}\n\nexport function statLink(path: string, callback: (error: Error | null, statAndIsLink: IStatAndLink | null) => void): void {\n\tfs.lstat(path, (error, lstat) => {\n\t\tif (error || lstat.isSymbolicLink()) {\n\t\t\tfs.stat(path, (error, stat) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn callback(error, null);\n\t\t\t\t}\n\n\t\t\t\tcallback(null, { stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });\n\t\t\t});\n\t\t} else {\n\t\t\tcallback(null, { stat: lstat, isSymbolicLink: false });\n\t\t}\n\t});\n}\n\nexport function copy(source: string, target: string, callback: (error: Error | null) => void, copiedSourcesIn?: { [path: string]: boolean }): void {\n\tconst copiedSources = copiedSourcesIn ? copiedSourcesIn : Object.create(null);\n\n\tfs.stat(source, (error, stat) => {\n\t\tif (error) {\n\t\t\treturn callback(error);\n\t\t}\n\n\t\tif (!stat.isDirectory()) {\n\t\t\treturn doCopyFile(source, target, stat.mode & 511, callback);\n\t\t}\n\n\t\tif (copiedSources[source]) {\n\t\t\treturn callback(null); // escape when there are cycles (can happen with symlinks)\n\t\t}\n\n\t\tcopiedSources[source] = true; // remember as copied\n\n\t\tconst proceed = function () {\n\t\t\treaddir(source, (err, files) => {\n\t\t\t\tloop(files, (file: string, clb: (error: Error | null, result: string[]) => void) => {\n\t\t\t\t\tcopy(paths.join(source, file), paths.join(target, file), (error: Error) => clb(error, []), copiedSources);\n\t\t\t\t}, callback);\n\t\t\t});\n\t\t};\n\n\t\tmkdirp(target, stat.mode & 511).then(proceed, proceed);\n\t});\n}\n\nfunction doCopyFile(source: string, target: string, mode: number, callback: (error: Error) => void): void {\n\tconst reader = fs.createReadStream(source);\n\tconst writer = fs.createWriteStream(target, { mode });\n\n\tlet finished = false;\n\tconst finish = (error?: Error) => {\n\t\tif (!finished) {\n\t\t\tfinished = true;\n\n\t\t\t// in error cases, pass to callback\n\t\t\tif (error) {\n\t\t\t\tcallback(error);\n\t\t\t}\n\n\t\t\t// we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104\n\t\t\telse {\n\t\t\t\tfs.chmod(target, mode, callback);\n\t\t\t}\n\t\t}\n\t};\n\n\t// handle errors properly\n\treader.once('error', error => finish(error));\n\twriter.once('error', error => finish(error));\n\n\t// we are done (underlying fd has been closed)\n\twriter.once('close', () => finish());\n\n\t// start piping\n\treader.pipe(writer);\n}\n\nexport function mkdirp(path: string, mode?: number, token?: CancellationToken): Promise<boolean> {\n\tconst mkdir = (): Promise<null> => {\n\t\treturn nfcall(fs.mkdir, path, mode).then(undefined, (mkdirErr: NodeJS.ErrnoException) => {\n\n\t\t\t// ENOENT: a parent folder does not exist yet\n\t\t\tif (mkdirErr.code === 'ENOENT') {\n\t\t\t\treturn Promise.reject(mkdirErr);\n\t\t\t}\n\n\t\t\t// Any other error: check if folder exists and\n\t\t\t// return normally in that case if its a folder\n\t\t\treturn nfcall(fs.stat, path).then((stat: fs.Stats) => {\n\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\treturn Promise.reject(new Error(`'${path}' exists and is not a directory.`));\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}, statErr => {\n\t\t\t\treturn Promise.reject(mkdirErr); // bubble up original mkdir error\n\t\t\t});\n\t\t});\n\t};\n\n\t// stop at root\n\tif (path === paths.dirname(path)) {\n\t\treturn Promise.resolve(true);\n\t}\n\n\t// recursively mkdir\n\treturn mkdir().then(undefined, (err: NodeJS.ErrnoException) => {\n\n\t\t// Respect cancellation\n\t\tif (token && token.isCancellationRequested) {\n\t\t\treturn Promise.resolve(false);\n\t\t}\n\n\t\t// ENOENT: a parent folder does not exist yet, continue\n\t\t// to create the parent folder and then try again.\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn mkdirp(paths.dirname(path), mode).then(mkdir);\n\t\t}\n\n\t\t// Any other error\n\t\treturn Promise.reject(err);\n\t});\n}\n\n// Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because\n// after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation\n// will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.\n// However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164\nexport function del(path: string, tmpFolder: string, callback: (error: Error | null) => void, done?: (error: Error | null) => void): void {\n\tfs.exists(path, exists => {\n\t\tif (!exists) {\n\t\t\treturn callback(null);\n\t\t}\n\n\t\tfs.stat(path, (err, stat) => {\n\t\t\tif (err || !stat) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\t// Special windows workaround: A file or folder that ends with a \".\" cannot be moved to another place\n\t\t\t// because it is not a valid file name. In this case, we really have to do the deletion without prior move.\n\t\t\tif (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\\\')) {\n\t\t\t\treturn rmRecursive(path, callback);\n\t\t\t}\n\n\t\t\tconst pathInTemp = paths.join(tmpFolder, uuid.generateUuid());\n\t\t\tfs.rename(path, pathInTemp, (error: Error | null) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn rmRecursive(path, callback); // if rename fails, delete without tmp dir\n\t\t\t\t}\n\n\t\t\t\t// Return early since the move succeeded\n\t\t\t\tcallback(null);\n\n\t\t\t\t// do the heavy deletion outside the callers callback\n\t\t\t\trmRecursive(pathInTemp, error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tdone(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction rmRecursive(path: string, callback: (error: Error | null) => void): void {\n\tif (path === paths.win32.sep || path === paths.posix.sep) {\n\t\treturn callback(new Error('Will not delete root!'));\n\t}\n\n\tfs.exists(path, exists => {\n\t\tif (!exists) {\n\t\t\tcallback(null);\n\t\t} else {\n\t\t\tfs.lstat(path, (err, stat) => {\n\t\t\t\tif (err || !stat) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {\n\t\t\t\t\tconst mode = stat.mode;\n\t\t\t\t\tif (!(mode & 128)) { // 128 === 0200\n\t\t\t\t\t\tfs.chmod(path, mode | 128, (err: Error) => { // 128 === 0200\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfs.unlink(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs.unlink(path, callback);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treaddir(path, (err, children) => {\n\t\t\t\t\t\tif (err || !children) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else if (children.length === 0) {\n\t\t\t\t\t\t\tfs.rmdir(path, callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet firstError: Error | null = null;\n\t\t\t\t\t\t\tlet childrenLeft = children.length;\n\t\t\t\t\t\t\tchildren.forEach(child => {\n\t\t\t\t\t\t\t\trmRecursive(paths.join(path, child), (err: Error) => {\n\t\t\t\t\t\t\t\t\tchildrenLeft--;\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tfirstError = firstError || err;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (childrenLeft === 0) {\n\t\t\t\t\t\t\t\t\t\tif (firstError) {\n\t\t\t\t\t\t\t\t\t\t\tcallback(firstError);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tfs.rmdir(path, callback);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nexport function delSync(path: string): void {\n\tif (path === paths.win32.sep || path === paths.posix.sep) {\n\t\tthrow new Error('Will not delete root!');\n\t}\n\n\ttry {\n\t\tconst stat = fs.lstatSync(path);\n\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\treaddirSync(path).forEach(child => delSync(paths.join(path, child)));\n\t\t\tfs.rmdirSync(path);\n\t\t} else {\n\t\t\tfs.unlinkSync(path);\n\t\t}\n\t} catch (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tthrow err;\n\t}\n}\n\nexport function mv(source: string, target: string, callback: (error: Error | null) => void): void {\n\tif (source === target) {\n\t\treturn callback(null);\n\t}\n\n\tfunction updateMtime(err: Error | null): void {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tfs.stat(target, (error, stat) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(error);\n\t\t\t}\n\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\treturn callback(null);\n\t\t\t}\n\n\t\t\tfs.open(target, 'a', null, (err: Error, fd: number) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tfs.futimes(fd, stat.atime, new Date(), (err: Error) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tfs.close(fd, callback);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t// Try native rename()\n\tfs.rename(source, target, (err: Error) => {\n\t\tif (!err) {\n\t\t\treturn updateMtime(null);\n\t\t}\n\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (err && source.toLowerCase() !== target.toLowerCase() && ((<any>err).code === 'EXDEV') || strings.endsWith(source, '.')) {\n\t\t\treturn copy(source, target, (err: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\trmRecursive(source, updateMtime);\n\t\t\t});\n\t\t}\n\n\t\treturn callback(err);\n\t});\n}\n\nexport interface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n\tencoding?: {\n\t\tcharset: string;\n\t\taddBOM: boolean;\n\t};\n}\n\nlet canFlush = true;\nexport function writeFileAndFlush(path: string, data: string | Buffer | NodeJS.ReadableStream, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\toptions = ensureOptions(options);\n\n\tif (typeof data === 'string' || Buffer.isBuffer(data)) {\n\t\tdoWriteFileAndFlush(path, data, options, callback);\n\t} else {\n\t\tdoWriteFileStreamAndFlush(path, data, options, callback);\n\t}\n}\n\nfunction doWriteFileStreamAndFlush(path: string, reader: NodeJS.ReadableStream, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\tif (process.env.isBrowser) {\n\t\tlet content = '';\n\t\tlet chunk = reader.read();\n\t\twhile (chunk !== null) {\n\t\t\tcontent += chunk;\n\t\t\tchunk = reader.read();\n\t\t}\n\t\tfs.writeFile(path, content, 'utf-8', function (error) {\n\t\t\tif (error) {\n\t\t\t\tcallback(error);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\treturn;\n\t}\n\t// finish only once\n\tlet finished = false;\n\tconst finish = (error?: Error) => {\n\t\tif (!finished) {\n\t\t\tfinished = true;\n\n\t\t\t// in error cases we need to manually close streams\n\t\t\t// if the write stream was successfully opened\n\t\t\tif (error) {\n\t\t\t\tif (isOpen) {\n\t\t\t\t\twriter.once('close', () => callback(error));\n\t\t\t\t\twriter.destroy();\n\t\t\t\t} else {\n\t\t\t\t\tcallback(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise just return without error\n\t\t\telse {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t};\n\n\t// create writer to target. we set autoClose: false because we want to use the streams\n\t// file descriptor to call fs.fdatasync to ensure the data is flushed to disk\n\tconst writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });\n\n\t// Event: 'open'\n\t// Purpose: save the fd for later use and start piping\n\t// Notes: will not be called when there is an error opening the file descriptor!\n\tlet fd: number;\n\tlet isOpen: boolean;\n\twriter.once('open', descriptor => {\n\t\tfd = descriptor;\n\t\tisOpen = true;\n\n\t\t// if an encoding is provided, we need to pipe the stream through\n\t\t// an encoder stream and forward the encoding related options\n\t\tif (options.encoding) {\n\t\t\treader = reader.pipe(encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));\n\t\t}\n\n\t\t// start data piping only when we got a successful open. this ensures that we do\n\t\t// not consume the stream when an error happens and helps to fix this issue:\n\t\t// https://github.com/Microsoft/vscode/issues/42542\n\t\treader.pipe(writer);\n\t});\n\n\t// Event: 'error'\n\t// Purpose: to return the error to the outside and to close the write stream (does not happen automatically)\n\treader.once('error', error => finish(error));\n\twriter.once('error', error => finish(error));\n\n\t// Event: 'finish'\n\t// Purpose: use fs.fdatasync to flush the contents to disk\n\t// Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()\n\t// because we have created the WriteStream with autoClose: false\n\twriter.once('finish', () => {\n\n\t\t// flush to disk\n\t\tif (canFlush && isOpen) {\n\t\t\tfs.fdatasync(fd, (syncError: Error) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\twriter.destroy();\n\t\t\t});\n\t\t} else {\n\t\t\twriter.destroy();\n\t\t}\n\t});\n\n\t// Event: 'close'\n\t// Purpose: signal we are done to the outside\n\t// Notes: event is called when the writer's filedescriptor is closed\n\twriter.once('close', () => finish());\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\tif (options.encoding) {\n\t\tdata = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n\t}\n\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(/** Desktop fd */path, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\tfs.fdatasync(fd, (syncError: Error) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport function writeFileAndFlushSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\toptions = ensureOptions(options);\n\n\tif (options.encoding) {\n\t\tdata = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n\t}\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(path, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd);\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tcanFlush = false;\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureOptions(options?: IWriteFileOptions): IWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666, flag: 'w' };\n\t}\n\n\tconst ensuredOptions: IWriteFileOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };\n\n\tif (typeof ensuredOptions.mode !== 'number') {\n\t\tensuredOptions.mode = 0o666;\n\t}\n\n\tif (typeof ensuredOptions.flag !== 'string') {\n\t\tensuredOptions.flag = 'w';\n\t}\n\n\treturn ensuredOptions;\n}\n\n/**\n * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport function realcaseSync(path: string): string | null {\n\tconst dir = paths.dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = readdirSync(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn paths.join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn paths.join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nexport function realpath(path: string, callback: (error: Error | null, realpath: string) => void): void {\n\treturn fs.realpath(path, (error, realpath) => {\n\t\tif (!error) {\n\t\t\treturn callback(null, realpath);\n\t\t}\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\treturn fs.access(normalizedPath, fs.constants.R_OK, error => {\n\t\t\treturn callback(error, normalizedPath);\n\t\t});\n\t});\n}\n\nfunction normalizePath(path: string): string {\n\treturn strings.rtrim(paths.normalize(path), paths.sep);\n}\n\nexport function watch(path: string, onChange: (type: string, path?: string) => void, onError: (error: string) => void): IDisposable {\n\ttry {\n\t\tconst watcher = fs.watch(path);\n\n\t\twatcher.on('change', (type, raw) => {\n\t\t\tlet file: string | undefined;\n\t\t\tif (raw) { // https://github.com/Microsoft/vscode/issues/38191\n\t\t\t\tfile = raw.toString();\n\t\t\t\tif (platform.isMacintosh) {\n\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\tfile = normalizeNFC(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tonChange(type, file);\n\t\t});\n\n\t\twatcher.on('error', (code: number, signal: string) => onError(`Failed to watch ${path} for changes (${code}, ${signal})`));\n\n\t\treturn toDisposable(() => {\n\t\t\twatcher.removeAllListeners();\n\t\t\twatcher.close();\n\t\t});\n\t} catch (error) {\n\t\tfs.exists(path, exists => {\n\t\t\tif (exists) {\n\t\t\t\tonError(`Failed to watch ${path} for changes (${error.toString()})`);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn Disposable.None;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (platform.isWindows && strings.endsWith(candidate, ':')) {\n\t\tcandidate += paths.sep;\n\t}\n\n\t// Ensure absolute\n\tif (!paths.isAbsolute(candidate)) {\n\t\tcandidate = paths.join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = paths.normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (platform.isWindows) {\n\t\tcandidate = strings.rtrim(candidate, paths.sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (strings.endsWith(candidate, ':')) {\n\t\t\tcandidate += paths.sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = strings.rtrim(candidate, paths.sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = paths.sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable, toDisposable, combinedDisposable } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, Relay } from 'vs/base/common/event';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any; };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel, id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any; };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose, id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string, name: string, stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: Buffer): void;\n\tonMessage: Event<Buffer>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the couter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidChangeConnections: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): Buffer;\n}\n\ninterface IWriter {\n\twrite(buffer: Buffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: Buffer) { }\n\n\tread(bytes: number): Buffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.length;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: Buffer[] = [];\n\n\tget buffer(): Buffer {\n\t\treturn Buffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: Buffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tArray = 3,\n\tObject = 4\n}\n\nfunction createSizeBuffer(size: number): Buffer {\n\tconst result = Buffer.allocUnsafe(4);\n\tresult.writeUInt32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUInt32BE(0);\n}\n\nconst BufferPresets = {\n\tUndefined: Buffer.alloc(1, DataType.Undefined),\n\tString: Buffer.alloc(1, DataType.String),\n\tBuffer: Buffer.alloc(1, DataType.Buffer),\n\tArray: Buffer.alloc(1, DataType.Array),\n\tObject: Buffer.alloc(1, DataType.Object)\n};\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = Buffer.from(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t} else if (Buffer.isBuffer(data)) {\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(data.length));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = Buffer.from(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.send([response.type]);\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.send([response.type, response.id], response.data);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(d => d.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\n\tprivate _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = createCancelablePromise(_ => this.whenInitialized());\n\t\t\tuninitializedPromise.then(() => {\n\t\t\t\tuninitializedPromise = null;\n\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t});\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable([toDisposable(cancel), cancellationTokenListener]);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => this.activeRequests.delete(disposable));\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawEventFireResponse) => emitter.fire(res.data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.send([request.type, request.id]);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onBuffer(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\tif (handler) {\n\t\t\thandler(response);\n\t\t}\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn Event.toPromise(this.onDidInitialize);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(p => p.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate _onDidChangeConnections = new Emitter<Connection<TContext>>();\n\treadonly onDidChangeConnections: Event<Connection<TContext>> = this._onDidChangeConnections.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidChangeConnections.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tconst channelPromise = router.routeCall(that, command, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tconst channelPromise = router.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidChangeConnections.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidChangeConnections);\n\t\treturn await this.route(hub);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareAnything } from 'vs/base/common/comparers';\nimport { matchesPrefix, IMatch, matchesCamelCase, isUpper } from 'vs/base/common/filters';\nimport { sep } from 'vs/base/common/path';\nimport { isWindows, isLinux } from 'vs/base/common/platform';\nimport { stripWildcards, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport type Score = [number /* score */, number[] /* match positions */];\nexport type ScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: Score = [NO_MATCH, []];\n\n// const DEBUG = false;\n// const DEBUG_MATRIX = false;\n\nexport function score(target: string, query: string, queryLower: string, fuzzy: boolean): Score {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\n\t// When not searching fuzzy, we require the query to be contained fully\n\t// in the target string contiguously.\n\tif (!fuzzy) {\n\t\tconst indexOfQueryInTarget = targetLower.indexOf(queryLower);\n\t\tif (indexOfQueryInTarget === -1) {\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);\n\t\t\t// }\n\n\t\t\treturn NO_SCORE;\n\t\t}\n\t}\n\n\tconst res = doScore(query, queryLower, queryLength, target, targetLower, targetLength);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScore(query: string, queryLower: string, queryLength: number, target: string, targetLower: string, targetLength: number): Score {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tif (score && diagScore + score >= leftScore) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// printMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(queryCharAtIndex: string, queryLowerCharAtIndex: string, target: string, targetLower: string, targetIndex: number, matchesSequenceLength: number): number {\n\tlet score = 0;\n\n\tif (queryLowerCharAtIndex !== targetLower[targetIndex]) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// \tconsole.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLower[queryIndex]} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus\n\tif (matchesSequenceLength > 0) {\n\t\tscore += (matchesSequenceLength * 5);\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Consecutive match bonus: ' + (matchesSequenceLength * 5));\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t}\n\n\telse {\n\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('After separtor bonus: +4');\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case)\n\t\telse if (isUpper(target.charCodeAt(targetIndex))) {\n\t\t\tscore += 1;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +1');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE: IItemScore = Object.freeze({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | null;\n\n\t/**\n\t * The optional description of the item to score on. Can be null.\n\t */\n\tgetItemDescription(item: T): string | null;\n\n\t/**\n\t * If the item is a file, the path of the file to score on. Can be null.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE = 1 << 17;\nconst LABEL_CAMELCASE_SCORE = 1 << 16;\nconst LABEL_SCORE_THRESHOLD = 1 << 15;\n\nexport interface IPreparedQuery {\n\toriginal: string;\n\tvalue: string;\n\tlowercase: string;\n\tcontainsPathSeparator: boolean;\n}\n\n/**\n * Helper function to prepare a search value for scoring in quick open by removing unwanted characters.\n */\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (!original) {\n\t\toriginal = '';\n\t}\n\n\tlet value = stripWildcards(original).replace(/\\s/g, ''); // get rid of all wildcards and whitespace\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t}\n\n\tconst lowercase = value.toLowerCase();\n\tconst containsPathSeparator = value.indexOf(sep) >= 0;\n\n\treturn { original, value, lowercase, containsPathSeparator };\n}\n\nexport function scoreItem<T>(item: T, query: IPreparedQuery, fuzzy: boolean, accessor: IItemAccessor<T>, cache: ScorerCache): IItemScore {\n\tif (!item || !query.value) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\tlet cacheHash: string;\n\tif (description) {\n\t\tcacheHash = `${label}${description}${query.value}${fuzzy}`;\n\t} else {\n\t\tcacheHash = `${label}${query.value}${fuzzy}`;\n\t}\n\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItem(label, description, accessor.getItemPath(item), query, fuzzy);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction createMatches(offsets: undefined | number[]): IMatch[] {\n\tlet ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\treturn ret;\n}\n\nfunction doScoreItem(label: string, description: string | null, path: string | undefined, query: IPreparedQuery, fuzzy: boolean): IItemScore {\n\n\t// 1.) treat identity matches on full path highest\n\tif (path && (isLinux ? query.original === path : equalsIgnoreCase(query.original, path))) {\n\t\treturn { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n\t}\n\n\t// We only consider label matches if the query is not including file path separators\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\tif (preferLabelMatches) {\n\n\t\t// 2.) treat prefix matches on the label second highest\n\t\tconst prefixLabelMatch = matchesPrefix(query.value, label);\n\t\tif (prefixLabelMatch) {\n\t\t\treturn { score: LABEL_PREFIX_SCORE, labelMatch: prefixLabelMatch };\n\t\t}\n\n\t\t// 3.) treat camelcase matches on the label third highest\n\t\tconst camelcaseLabelMatch = matchesCamelCase(query.value, label);\n\t\tif (camelcaseLabelMatch) {\n\t\t\treturn { score: LABEL_CAMELCASE_SCORE, labelMatch: camelcaseLabelMatch };\n\t\t}\n\n\t\t// 4.) prefer scores on the label if any\n\t\tconst [labelScore, labelPositions] = score(label, query.value, query.lowercase, fuzzy);\n\t\tif (labelScore) {\n\t\t\treturn { score: labelScore + LABEL_SCORE_THRESHOLD, labelMatch: createMatches(labelPositions) };\n\t\t}\n\t}\n\n\t// 5.) finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = score(descriptionAndLabel, query.value, query.lowercase, fuzzy);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(labelDescriptionPositions);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach(h => {\n\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n\t\t\t\t\tdescriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { score: labelDescriptionScore, labelMatch, descriptionMatch };\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nexport function compareItemsByScore<T>(itemA: T, itemB: T, query: IPreparedQuery, fuzzy: boolean, accessor: IItemAccessor<T>, cache: ScorerCache, fallbackComparer = fallbackCompare): number {\n\tconst itemScoreA = scoreItem(itemA, query, fuzzy, accessor, cache);\n\tconst itemScoreB = scoreItem(itemB, query, fuzzy, accessor, cache);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) prefer identity matches\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) prefer label prefix matches\n\tif (scoreA === LABEL_PREFIX_SCORE || scoreB === LABEL_PREFIX_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === LABEL_PREFIX_SCORE ? -1 : 1;\n\t\t}\n\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\t\t// prefer shorter names when both match on label prefix\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) prefer camelcase matches\n\tif (scoreA === LABEL_CAMELCASE_SCORE || scoreB === LABEL_CAMELCASE_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === LABEL_CAMELCASE_SCORE ? -1 : 1;\n\t\t}\n\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\t\t// prefer more compact camel case matches over longer\n\t\tconst comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n\t\tif (comparedByMatchLength !== 0) {\n\t\t\treturn comparedByMatchLength;\n\t\t}\n\n\t\t// prefer shorter names when both match on label camelcase\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 4.) prefer label scores\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreB < LABEL_SCORE_THRESHOLD) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (scoreA < LABEL_SCORE_THRESHOLD) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// 5.) compare by score\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical, prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n\tif (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 7.) at this point, scores are identical and match compactness as well\n\t// for both items so we start to use the fallback compare\n\treturn fallbackComparer(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(item: T, score: IItemScore, accessor: IItemAccessor<T>): number {\n\tlet matchStart: number = -1;\n\tlet matchEnd: number = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch && score.labelMatch.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch && score.labelMatch.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(matchesA?: IMatch[], matchesB?: IMatch[]): number {\n\tif ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB || !matchesB.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA || !matchesA.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\n\nexport function fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {\n\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || '';\n\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.value);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.value);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.value);\n\t}\n\n\t// equal\n\treturn 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport * as types from 'vs/base/common/types';\nimport * as arrays from 'vs/base/common/arrays';\n\nfunction exceptionToErrorMessage(exception: any, verbose: boolean): string {\n\tif (exception.message) {\n\t\tif (verbose && (exception.stack || exception.stacktrace)) {\n\t\t\treturn nls.localize('stackTrace.format', \"{0}: {1}\", detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);\n\t\t}\n\n\t\treturn detectSystemErrorMessage(exception);\n\t}\n\n\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n\nfunction detectSystemErrorMessage(exception: any): string {\n\n\t// See https://nodejs.org/api/errors.html#errors_class_system_error\n\tif (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n\t\treturn nls.localize('nodeExceptionMessage', \"A system error occurred ({0})\", exception.message);\n\t}\n\n\treturn exception.message;\n}\n\n/**\n * Tries to generate a human readable error message out of the error. If the verbose parameter\n * is set to true, the error message will include stacktrace details if provided.\n *\n * @returns A string containing the error message.\n */\nexport function toErrorMessage(error: any = null, verbose: boolean = false): string {\n\tif (!error) {\n\t\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n\t}\n\n\tif (Array.isArray(error)) {\n\t\tconst errors: any[] = arrays.coalesce(error);\n\t\tconst msg = toErrorMessage(errors[0], verbose);\n\n\t\tif (errors.length > 1) {\n\t\t\treturn nls.localize('error.moreErrors', \"{0} ({1} errors in total)\", msg, errors.length);\n\t\t}\n\n\t\treturn msg;\n\t}\n\n\tif (types.isString(error)) {\n\t\treturn error;\n\t}\n\n\tif (error.detail) {\n\t\tconst detail = error.detail;\n\n\t\tif (detail.error) {\n\t\t\treturn exceptionToErrorMessage(detail.error, verbose);\n\t\t}\n\n\t\tif (detail.exception) {\n\t\t\treturn exceptionToErrorMessage(detail.exception, verbose);\n\t\t}\n\t}\n\n\tif (error.stack) {\n\t\treturn exceptionToErrorMessage(error, verbose);\n\t}\n\n\tif (error.message) {\n\t\treturn error.message;\n\t}\n\n\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport * as nls from 'vs/nls';\nimport * as Types from 'vs/base/common/types';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as Objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as Platform from 'vs/base/common/platform';\nimport { LineDecoder } from 'vs/base/node/decoder';\nimport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode, Executable } from 'vs/base/common/processes';\nimport { getPathFromAmdModule } from 'vs/base/common/amd';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value?: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport interface LineData {\n\tline: string;\n\tsource: Source;\n}\n\nfunction getWindowsCode(status: number): TerminateResponseCode {\n\tswitch (status) {\n\t\tcase 0:\n\t\t\treturn TerminateResponseCode.Success;\n\t\tcase 1:\n\t\t\treturn TerminateResponseCode.AccessDenied;\n\t\tcase 128:\n\t\t\treturn TerminateResponseCode.ProcessNotFound;\n\t\tdefault:\n\t\t\treturn TerminateResponseCode.Unknown;\n\t}\n}\n\nexport function terminateProcess(process: cp.ChildProcess, cwd?: string): TerminateResponse {\n\tif (Platform.isWindows) {\n\t\ttry {\n\t\t\tconst options: any = {\n\t\t\t\tstdio: ['pipe', 'pipe', 'ignore']\n\t\t\t};\n\t\t\tif (cwd) {\n\t\t\t\toptions.cwd = cwd;\n\t\t\t}\n\t\t\tcp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err, code: err.status ? getWindowsCode(err.status) : TerminateResponseCode.Unknown };\n\t\t}\n\t} else if (Platform.isLinux || Platform.isMacintosh) {\n\t\ttry {\n\t\t\tconst cmd = getPathFromAmdModule(require, 'vs/base/node/terminateProcess.sh');\n\t\t\tconst result = cp.spawnSync(cmd, [process.pid.toString()]);\n\t\t\tif (result.error) {\n\t\t\t\treturn { success: false, error: result.error };\n\t\t\t}\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err };\n\t\t}\n\t} else {\n\t\tprocess.kill('SIGKILL');\n\t}\n\treturn { success: true };\n}\n\nexport function getWindowsShell(): string {\n\treturn process.env['comspec'] || 'cmd.exe';\n}\n\nexport abstract class AbstractProcess<TProgressData> {\n\tprivate cmd: string;\n\tprivate args: string[];\n\tprivate options: CommandOptions | ForkOptions;\n\tprotected shell: boolean;\n\n\tprivate childProcess: cp.ChildProcess | null;\n\tprotected childProcessPromise: Promise<cp.ChildProcess> | null;\n\tprivate pidResolve?: ValueCallback<number>;\n\tprotected terminateRequested: boolean;\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[] | undefined, shell: boolean, options: CommandOptions | undefined);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean, arg4?: CommandOptions) {\n\t\tif (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n\t\t\tthis.cmd = <string>arg1;\n\t\t\tthis.args = arg2;\n\t\t\tthis.shell = arg3;\n\t\t\tthis.options = arg4;\n\t\t} else {\n\t\t\tconst executable = <Executable>arg1;\n\t\t\tthis.cmd = executable.command;\n\t\t\tthis.shell = executable.isShellCommand;\n\t\t\tthis.args = executable.args.slice(0);\n\t\t\tthis.options = executable.options || {};\n\t\t}\n\n\t\tthis.childProcess = null;\n\t\tthis.terminateRequested = false;\n\n\t\tif (this.options.env) {\n\t\t\tconst newEnv: IStringDictionary<string> = Object.create(null);\n\t\t\tObject.keys(process.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = process.env[key]!;\n\t\t\t});\n\t\t\tObject.keys(this.options.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = this.options.env![key]!;\n\t\t\t});\n\t\t\tthis.options.env = newEnv;\n\t\t}\n\t}\n\n\tpublic getSanitizedCommand(): string {\n\t\tlet result = this.cmd.toLowerCase();\n\t\tconst index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (AbstractProcess.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tpublic start(pp: ProgressCallback<TProgressData>): Promise<SuccessData> {\n\t\tif (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n\t\t\treturn Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n\t\t}\n\t\treturn this.useExec().then((useExec) => {\n\t\t\tlet cc: ValueCallback<SuccessData>;\n\t\t\tlet ee: ErrorCallback;\n\t\t\tconst result = new Promise<any>((c, e) => {\n\t\t\t\tcc = c;\n\t\t\t\tee = e;\n\t\t\t});\n\n\t\t\tif (useExec) {\n\t\t\t\tlet cmd: string = this.cmd;\n\t\t\t\tif (this.args) {\n\t\t\t\t\tcmd = cmd + ' ' + this.args.join(' ');\n\t\t\t\t}\n\t\t\t\tthis.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tconst err: any = error;\n\t\t\t\t\t// This is tricky since executing a command shell reports error back in case the executed command return an\n\t\t\t\t\t// error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n\t\t\t\t\t// always parse the output and report success unless the job got killed.\n\t\t\t\t\tif (err && err.killed) {\n\t\t\t\t\t\tee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleExec(cc, pp, error, stdout as any, stderr as any);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet childProcess: cp.ChildProcess | null = null;\n\t\t\t\tconst closeHandler = (data: any) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tthis.childProcessPromise = null;\n\t\t\t\t\tthis.handleClose(data, cc, pp, ee);\n\t\t\t\t\tconst result: SuccessData = {\n\t\t\t\t\t\tterminated: this.terminateRequested\n\t\t\t\t\t};\n\t\t\t\t\tif (Types.isNumber(data)) {\n\t\t\t\t\t\tresult.cmdCode = <number>data;\n\t\t\t\t\t}\n\t\t\t\t\tcc(result);\n\t\t\t\t};\n\t\t\t\tif (this.shell && Platform.isWindows) {\n\t\t\t\t\tconst options: any = Objects.deepClone(this.options);\n\t\t\t\t\toptions.windowsVerbatimArguments = true;\n\t\t\t\t\toptions.detached = false;\n\t\t\t\t\tlet quotedCommand: boolean = false;\n\t\t\t\t\tlet quotedArg: boolean = false;\n\t\t\t\t\tconst commandLine: string[] = [];\n\t\t\t\t\tlet quoted = this.ensureQuotes(this.cmd);\n\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\tquotedCommand = quoted.quoted;\n\t\t\t\t\tif (this.args) {\n\t\t\t\t\t\tthis.args.forEach((elem) => {\n\t\t\t\t\t\t\tquoted = this.ensureQuotes(elem);\n\t\t\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\t\t\tquotedArg = quotedArg && quoted.quoted;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconst args: string[] = [\n\t\t\t\t\t\t'/s',\n\t\t\t\t\t\t'/c',\n\t\t\t\t\t];\n\t\t\t\t\tif (quotedCommand) {\n\t\t\t\t\t\tif (quotedArg) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine.join(' ') + '\"');\n\t\t\t\t\t\t} else if (commandLine.length > 1) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push(commandLine.join(' '));\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess = cp.spawn(getWindowsShell(), args, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.cmd) {\n\t\t\t\t\t\tchildProcess = cp.spawn(this.cmd, this.args, this.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (childProcess) {\n\t\t\t\t\tthis.childProcess = childProcess;\n\t\t\t\t\tthis.childProcessPromise = Promise.resolve(childProcess);\n\t\t\t\t\tif (this.pidResolve) {\n\t\t\t\t\t\tthis.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n\t\t\t\t\t\tthis.pidResolve = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess.on('error', (error: Error) => {\n\t\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\t\tee({ terminated: this.terminateRequested, error: error });\n\t\t\t\t\t});\n\t\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\t\tthis.childProcess.on('close', closeHandler);\n\t\t\t\t\t\tthis.handleSpawn(childProcess, cc!, pp, ee!, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tprotected abstract handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, error: Error | null, stdout: Buffer, stderr: Buffer): void;\n\tprotected abstract handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback, sync: boolean): void;\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback): void {\n\t\t// Default is to do nothing.\n\t}\n\n\tprivate static readonly regexp = /^[^\"].* .*[^\"]/;\n\tprivate ensureQuotes(value: string) {\n\t\tif (AbstractProcess.regexp.test(value)) {\n\t\t\treturn {\n\t\t\t\tvalue: '\"' + value + '\"', //`\"${value}\"`,\n\t\t\t\tquoted: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tquoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic get pid(): Promise<number> {\n\t\tif (this.childProcessPromise) {\n\t\t\treturn this.childProcessPromise.then(childProcess => childProcess.pid, err => -1);\n\t\t} else {\n\t\t\treturn new Promise<number>((resolve) => {\n\t\t\t\tthis.pidResolve = resolve;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic terminate(): Promise<TerminateResponse> {\n\t\tif (!this.childProcessPromise) {\n\t\t\treturn Promise.resolve<TerminateResponse>({ success: true });\n\t\t}\n\t\treturn this.childProcessPromise.then((childProcess) => {\n\t\t\tthis.terminateRequested = true;\n\t\t\tconst result = terminateProcess(childProcess, this.options.cwd);\n\t\t\tif (result.success) {\n\t\t\t\tthis.childProcess = null;\n\t\t\t}\n\t\t\treturn result;\n\t\t}, (err) => {\n\t\t\treturn { success: true };\n\t\t});\n\t}\n\n\tprivate useExec(): Promise<boolean> {\n\t\treturn new Promise<boolean>((c, e) => {\n\t\t\tif (!this.shell || !Platform.isWindows) {\n\t\t\t\treturn c(false);\n\t\t\t}\n\t\t\tconst cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n\t\t\tcmdShell.on('error', (error: Error) => {\n\t\t\t\treturn c(true);\n\t\t\t});\n\t\t\tcmdShell.on('exit', (data: any) => {\n\t\t\t\treturn c(false);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class LineProcess extends AbstractProcess<LineData> {\n\n\tprivate stdoutLineDecoder: LineDecoder;\n\tprivate stderrLineDecoder: LineDecoder;\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[], shell: boolean, options: CommandOptions);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean | ForkOptions, arg4?: CommandOptions) {\n\t\tsuper(<any>arg1, arg2, <any>arg3, arg4);\n\t}\n\n\tprotected handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, error: Error, stdout: Buffer, stderr: Buffer) {\n\t\t[stdout, stderr].forEach((buffer: Buffer, index: number) => {\n\t\t\tconst lineDecoder = new LineDecoder();\n\t\t\tconst lines = lineDecoder.write(buffer);\n\t\t\tlines.forEach((line) => {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t});\n\t\t\tconst line = lineDecoder.end();\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t\tcc({ terminated: this.terminateRequested, error: error });\n\t}\n\n\tprotected handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback, sync: boolean): void {\n\t\tthis.stdoutLineDecoder = new LineDecoder();\n\t\tthis.stderrLineDecoder = new LineDecoder();\n\t\tchildProcess.stdout.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stdoutLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stdout }));\n\t\t});\n\t\tchildProcess.stderr.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stderrLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stderr }));\n\t\t});\n\t}\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback): void {\n\t\t[this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach((line, index) => {\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport function findExecutable(command: string, cwd?: string, paths?: string[]): string {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env.PATH)) {\n\t\t\tpaths = process.env.PATH.split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (let pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (fs.existsSync(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, fork, ForkOptions } from 'child_process';\nimport { IDisposable, toDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Delayer, createCancelablePromise } from 'vs/base/common/async';\nimport { deepClone, assign } from 'vs/base/common/objects';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { createQueuedSender } from 'vs/base/node/processes';\nimport { ChannelServer as IPCServer, ChannelClient as IPCClient, IChannelClient, IChannel } from 'vs/base/parts/ipc/node/ipc';\nimport { isRemoteConsoleLog, log } from 'vs/base/node/console';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper({\n\t\t\tsend: r => {\n\t\t\t\ttry {\n\t\t\t\t\tif (process.send) {\n\t\t\t\t\t\tprocess.send(r.toString('base64'));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /* not much to do */ }\n\t\t\t},\n\t\t\tonMessage: Event.fromNodeEventEmitter(process, 'message', msg => Buffer.from(msg, 'base64'))\n\t\t}, ctx);\n\n\t\tprocess.once('disconnect', () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * See https://github.com/Microsoft/vscode/issues/27665\n\t * Allows to pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.\n\t * e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host\n\t * results in the forked process inheriting `--inspect-brk=xxx`.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\n\tprivate disposeDelayer: Delayer<void>;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate _onDidProcessExit = new Emitter<{ code: number, signal: string }>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(private modulePath: string, private options: IIPCOptions) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error('disposed'));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise(token => channel.call<T>(name, arg, token));\n\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(channelName: string, name: string, arg?: any): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args = this.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = assign(deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = assign(forkOpts.env, this.options.env);\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n\t\t\t}\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<Buffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n\n\t\t\tonRawMessage(msg => {\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(Buffer.from(msg, 'base64'));\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue ? createQueuedSender(this.child) : this.child;\n\t\t\tconst send = (r: Buffer) => this.child && (process.env.isBrowser ? true : this.child.connected) && sender.send(r.toString('base64'));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once('exit', onExit);\n\n\t\t\tthis.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n\n\t\t\tthis.child.on('exit', (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener('exit', onExit);\n\n\t\t\t\tthis.activeRequests.forEach(r => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== 'SIGTERM') {\n\t\t\t\t\tconsole.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n\t\t\t\t}\n\n\t\t\t\tif (this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.cancel();\n\t\t\t\t}\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tthis.disposeDelayer.cancel();\n\t\tthis.disposeDelayer = null!; // StrictNullOverride: nulling out ok in dispose\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// See https://github.com/Microsoft/vscode/issues/30180\nconst WIN32_MAX_FILE_SIZE = 300 * 1024 * 1024; // 300 MB\nconst GENERAL_MAX_FILE_SIZE = 16 * 1024 * 1024 * 1024; // 16 GB\n\n// See https://github.com/v8/v8/blob/5918a23a3d571b9625e5cce246bdd5b46ff7cd8b/src/heap/heap.cc#L149\nconst WIN32_MAX_HEAP_SIZE = 700 * 1024 * 1024; // 700 MB\nconst GENERAL_MAX_HEAP_SIZE = 700 * 2 * 1024 * 1024; // 1400 MB\n\nexport const MAX_FILE_SIZE = process.arch === 'ia32' ? WIN32_MAX_FILE_SIZE : GENERAL_MAX_FILE_SIZE;\nexport const MAX_HEAP_SIZE = process.arch === 'ia32' ? WIN32_MAX_HEAP_SIZE : GENERAL_MAX_HEAP_SIZE;","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ServiceCollection } from './serviceCollection';\nimport * as descriptors from './descriptors';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>, index: number, optional: boolean }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport interface IConstructorSignature0<T> {\n\tnew(...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature1<A1, T> {\n\tnew(first: A1, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature2<A1, A2, T> {\n\tnew(first: A1, second: A2, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature3<A1, A2, A3, T> {\n\tnew(first: A1, second: A2, third: A3, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature4<A1, A2, A3, A4, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature5<A1, A2, A3, A4, A5, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature6<A1, A2, A3, A4, A5, A6, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>, isOptional?: typeof optional): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\nexport interface IInstantiationService {\n\n\t_serviceBrand: any;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by\n\t * the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<A1, T>(descriptor: descriptors.SyncDescriptor1<A1, T>, a1: A1): T;\n\tcreateInstance<A1, A2, T>(descriptor: descriptors.SyncDescriptor2<A1, A2, T>, a1: A1, a2: A2): T;\n\tcreateInstance<A1, A2, A3, T>(descriptor: descriptors.SyncDescriptor3<A1, A2, A3, T>, a1: A1, a2: A2, a3: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(descriptor: descriptors.SyncDescriptor4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3, a4: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(descriptor: descriptors.SyncDescriptor5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(descriptor: descriptors.SyncDescriptor6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(descriptor: descriptors.SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(descriptor: descriptors.SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;\n\n\tcreateInstance<T>(ctor: IConstructorSignature0<T>): T;\n\tcreateInstance<A1, T>(ctor: IConstructorSignature1<A1, T>, first: A1): T;\n\tcreateInstance<A1, A2, T>(ctor: IConstructorSignature2<A1, A2, T>, first: A1, second: A2): T;\n\tcreateInstance<A1, A2, A3, T>(ctor: IConstructorSignature3<A1, A2, A3, T>, first: A1, second: A2, third: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(ctor: IConstructorSignature4<A1, A2, A3, A4, T>, first: A1, second: A2, third: A3, fourth: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(ctor: IConstructorSignature5<A1, A2, A3, A4, A5, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(ctor: IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(ctor: IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8): T;\n\n\t/**\n\t *\n\t */\n\tinvokeFunction<R, TS extends any[]=[]>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherts all current services\n\t * and adds/overwrites the given services\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type T\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void {\n\tif (target[_util.DI_TARGET] === target) {\n\t\ttarget[_util.DI_DEPENDENCIES].push({ id, index, optional });\n\t} else {\n\t\ttarget[_util.DI_DEPENDENCIES] = [{ id, index, optional }];\n\t\ttarget[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * A *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): { (...args: any[]): void; type: T; } {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index, false);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\n/**\n * Mark a service dependency as optional.\n */\nexport function optional<T>(serviceIdentifier: ServiceIdentifier<T>) {\n\n\treturn function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@optional-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(serviceIdentifier, target, index, true);\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator as createServiceDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable, Disposable } from 'vs/base/common/lifecycle';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\n\nexport const ILogService = createServiceDecorator<ILogService>('logService');\n\nfunction now(): string {\n\treturn new Date().toISOString();\n}\n\nexport enum LogLevel {\n\tTrace,\n\tDebug,\n\tInfo,\n\tWarning,\n\tError,\n\tCritical,\n\tOff\n}\n\nexport const DEFAULT_LOG_LEVEL: LogLevel = LogLevel.Info;\n\nexport interface ILogService extends IDisposable {\n\t_serviceBrand: any;\n\tonDidChangeLogLevel: Event<LogLevel>;\n\n\tgetLevel(): LogLevel;\n\tsetLevel(level: LogLevel): void;\n\ttrace(message: string, ...args: any[]): void;\n\tdebug(message: string, ...args: any[]): void;\n\tinfo(message: string, ...args: any[]): void;\n\twarn(message: string, ...args: any[]): void;\n\terror(message: string | Error, ...args: any[]): void;\n\tcritical(message: string | Error, ...args: any[]): void;\n}\n\nexport abstract class AbstractLogService extends Disposable {\n\n\tprivate level: LogLevel = DEFAULT_LOG_LEVEL;\n\tprivate readonly _onDidChangeLogLevel: Emitter<LogLevel> = this._register(new Emitter<LogLevel>());\n\treadonly onDidChangeLogLevel: Event<LogLevel> = this._onDidChangeLogLevel.event;\n\n\tsetLevel(level: LogLevel): void {\n\t\tif (this.level !== level) {\n\t\t\tthis.level = level;\n\t\t\tthis._onDidChangeLogLevel.fire(this.level);\n\t\t}\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.level;\n\t}\n}\n\nexport class ConsoleLogMainService extends AbstractLogService implements ILogService {\n\n\t_serviceBrand: any;\n\tprivate useColors: boolean;\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t\tthis.useColors = !isWindows;\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Trace) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Debug) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Info) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Warning) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.warn(`\\x1b[93m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Error) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error(`\\x1b[91m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tcritical(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Critical) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\t// noop\n\t}\n}\n\nexport class ConsoleLogService extends AbstractLogService implements ILogService {\n\n\t_serviceBrand: any;\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Trace) {\n\t\t\tconsole.log('%cTRACE', 'color: #888', message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Debug) {\n\t\t\tconsole.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Info) {\n\t\t\tconsole.log('%c INFO', 'color: #33f', message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Warning) {\n\t\t\tconsole.log('%c WARN', 'color: #993', message, ...args);\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Error) {\n\t\t\tconsole.log('%c  ERR', 'color: #f33', message, ...args);\n\t\t}\n\t}\n\n\tcritical(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Critical) {\n\t\t\tconsole.log('%cCRITI', 'background: #f33; color: white', message, ...args);\n\t\t}\n\t}\n\n\tdispose(): void { }\n}\n\nexport class MultiplexLogService extends AbstractLogService implements ILogService {\n\t_serviceBrand: any;\n\n\tconstructor(private logServices: ILogService[]) {\n\t\tsuper();\n\t\tif (logServices.length) {\n\t\t\tthis.setLevel(logServices[0].getLevel());\n\t\t}\n\t}\n\n\tsetLevel(level: LogLevel): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.setLevel(level);\n\t\t}\n\t\tsuper.setLevel(level);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.trace(message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.debug(message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.info(message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.warn(message, ...args);\n\t\t}\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.error(message, ...args);\n\t\t}\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.critical(message, ...args);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.dispose();\n\t\t}\n\t}\n}\n\nexport class DelegatedLogService extends Disposable implements ILogService {\n\t_serviceBrand: any;\n\n\tconstructor(private logService: ILogService) {\n\t\tsuper();\n\t\tthis._register(logService);\n\t}\n\n\tget onDidChangeLogLevel(): Event<LogLevel> {\n\t\treturn this.logService.onDidChangeLogLevel;\n\t}\n\n\tsetLevel(level: LogLevel): void {\n\t\tthis.logService.setLevel(level);\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.logService.getLevel();\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tthis.logService.trace(message, ...args);\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tthis.logService.debug(message, ...args);\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tthis.logService.info(message, ...args);\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tthis.logService.warn(message, ...args);\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tthis.logService.error(message, ...args);\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tthis.logService.critical(message, ...args);\n\t}\n}\n\nexport class NullLogService implements ILogService {\n\t_serviceBrand: any;\n\treadonly onDidChangeLogLevel: Event<LogLevel> = new Emitter<LogLevel>().event;\n\tsetLevel(level: LogLevel): void { }\n\tgetLevel(): LogLevel { return LogLevel.Info; }\n\ttrace(message: string, ...args: any[]): void { }\n\tdebug(message: string, ...args: any[]): void { }\n\tinfo(message: string, ...args: any[]): void { }\n\twarn(message: string, ...args: any[]): void { }\n\terror(message: string | Error, ...args: any[]): void { }\n\tcritical(message: string | Error, ...args: any[]): void { }\n\tdispose(): void { }\n}\n\nexport function getLogLevel(environmentService: IEnvironmentService): LogLevel {\n\tif (environmentService.verbose) {\n\t\treturn LogLevel.Trace;\n\t}\n\tif (typeof environmentService.args.log === 'string') {\n\t\tconst logLevel = environmentService.args.log.toLowerCase();\n\t\tswitch (logLevel) {\n\t\t\tcase 'trace':\n\t\t\t\treturn LogLevel.Trace;\n\t\t\tcase 'debug':\n\t\t\t\treturn LogLevel.Debug;\n\t\t\tcase 'info':\n\t\t\t\treturn LogLevel.Info;\n\t\t\tcase 'warn':\n\t\t\t\treturn LogLevel.Warning;\n\t\t\tcase 'error':\n\t\t\t\treturn LogLevel.Error;\n\t\t\tcase 'critical':\n\t\t\t\treturn LogLevel.Critical;\n\t\t\tcase 'off':\n\t\t\t\treturn LogLevel.Off;\n\t\t}\n\t}\n\treturn DEFAULT_LOG_LEVEL;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as Types from 'vs/base/common/types';\nimport * as Assert from 'vs/base/common/assert';\n\nexport interface IRegistry {\n\n\t/**\n\t * Adds the extension functions and properties defined by data to the\n\t * platform. The provided id must be unique.\n\t * @param id a unique identifier\n\t * @param data a contribution\n\t */\n\tadd(id: string, data: any): void;\n\n\t/**\n\t * Returns true iff there is an extension with the provided id.\n\t * @param id an extension identifier\n\t */\n\tknows(id: string): boolean;\n\n\t/**\n\t * Returns the extension functions and properties defined by the specified key or null.\n\t * @param id an extension identifier\n\t */\n\tas<T>(id: string): T;\n}\n\nclass RegistryImpl implements IRegistry {\n\n\tprivate data: { [id: string]: any; };\n\n\tconstructor() {\n\t\tthis.data = {};\n\t}\n\n\tpublic add(id: string, data: any): void {\n\t\tAssert.ok(Types.isString(id));\n\t\tAssert.ok(Types.isObject(data));\n\t\tAssert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');\n\n\t\tthis.data[id] = data;\n\t}\n\n\tpublic knows(id: string): boolean {\n\t\treturn this.data.hasOwnProperty(id);\n\t}\n\n\tpublic as(id: string): any {\n\t\treturn this.data[id] || null;\n\t}\n}\n\nexport const Registry = <IRegistry>new RegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Command } from 'vs/editor/common/modes';\nimport { UriComponents } from 'vs/base/common/uri';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';\nimport { ITreeViewDataProvider } from 'vs/workbench/common/views';\nimport { localize } from 'vs/nls';\nimport { IViewlet } from 'vs/workbench/common/viewlet';\nimport { createDecorator, ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { ThemeIcon } from 'vs/platform/theme/common/themeService';\nimport { values, keys } from 'vs/base/common/map';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { IKeybindings } from 'vs/platform/keybinding/common/keybindingsRegistry';\nimport { IAction } from 'vs/base/common/actions';\nimport { IMarkdownString } from 'vs/base/common/htmlContent';\nimport { ExtensionIdentifier } from 'vs/platform/extensions/common/extensions';\n\nexport const TEST_VIEW_CONTAINER_ID = 'workbench.view.extension.test';\n\nexport namespace Extensions {\n\texport const ViewContainersRegistry = 'workbench.registry.view.containers';\n\texport const ViewsRegistry = 'workbench.registry.view';\n}\n\nexport interface IViewContainersRegistry {\n\t/**\n\t * An event that is triggerred when a view container is registered.\n\t */\n\treadonly onDidRegister: Event<ViewContainer>;\n\n\t/**\n\t * An event that is triggerred when a view container is deregistered.\n\t */\n\treadonly onDidDeregister: Event<ViewContainer>;\n\n\t/**\n\t * All registered view containers\n\t */\n\treadonly all: ViewContainer[];\n\n\t/**\n\t * Registers a view container with given id\n\t * No op if a view container is already registered with the given id.\n\t *\n\t * @param id of the view container.\n\t *\n\t * @returns the registered ViewContainer.\n\t */\n\tregisterViewContainer(id: string, hideIfEmpty?: boolean, extensionId?: ExtensionIdentifier): ViewContainer;\n\n\t/**\n\t * Deregisters the given view container\n\t * No op if the view container is not registered\n\t */\n\tderegisterViewContainer(viewContainer: ViewContainer): void;\n\n\t/**\n\t * Returns the view container with given id.\n\t *\n\t * @returns the view container with given id.\n\t */\n\tget(id: string): ViewContainer | undefined;\n}\n\nexport class ViewContainer {\n\tprotected constructor(readonly id: string, readonly hideIfEmpty: boolean, readonly extensionId?: ExtensionIdentifier) { }\n}\n\nclass ViewContainersRegistryImpl implements IViewContainersRegistry {\n\n\tprivate readonly _onDidRegister = new Emitter<ViewContainer>();\n\treadonly onDidRegister: Event<ViewContainer> = this._onDidRegister.event;\n\n\tprivate readonly _onDidDeregister = new Emitter<ViewContainer>();\n\treadonly onDidDeregister: Event<ViewContainer> = this._onDidDeregister.event;\n\n\tprivate viewContainers: Map<string, ViewContainer> = new Map<string, ViewContainer>();\n\n\tget all(): ViewContainer[] {\n\t\treturn values(this.viewContainers);\n\t}\n\n\tregisterViewContainer(id: string, hideIfEmpty?: boolean, extensionId?: ExtensionIdentifier): ViewContainer {\n\t\tconst existing = this.viewContainers.get(id);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tconst viewContainer = new class extends ViewContainer {\n\t\t\tconstructor() {\n\t\t\t\tsuper(id, !!hideIfEmpty, extensionId);\n\t\t\t}\n\t\t};\n\t\tthis.viewContainers.set(id, viewContainer);\n\t\tthis._onDidRegister.fire(viewContainer);\n\t\treturn viewContainer;\n\t}\n\n\tderegisterViewContainer(viewContainer: ViewContainer): void {\n\t\tconst existing = this.viewContainers.get(viewContainer.id);\n\t\tif (existing) {\n\t\t\tthis.viewContainers.delete(viewContainer.id);\n\t\t\tthis._onDidDeregister.fire(viewContainer);\n\t\t}\n\t}\n\n\tget(id: string): ViewContainer | undefined {\n\t\treturn this.viewContainers.get(id);\n\t}\n}\n\nRegistry.add(Extensions.ViewContainersRegistry, new ViewContainersRegistryImpl());\n\nexport interface IViewDescriptor {\n\n\treadonly id: string;\n\n\treadonly name: string;\n\n\treadonly ctorDescriptor: { ctor: any, arguments?: any[] };\n\n\treadonly when?: ContextKeyExpr;\n\n\treadonly order?: number;\n\n\treadonly weight?: number;\n\n\treadonly collapsed?: boolean;\n\n\treadonly canToggleVisibility?: boolean;\n\n\t// Applies only to newly created views\n\treadonly hideByDefault?: boolean;\n\n\treadonly workspace?: boolean;\n\n\treadonly focusCommand?: { id: string, keybindings?: IKeybindings };\n}\n\nexport interface IViewDescriptorCollection extends IDisposable {\n\treadonly onDidChangeActiveViews: Event<{ added: IViewDescriptor[], removed: IViewDescriptor[] }>;\n\treadonly activeViewDescriptors: IViewDescriptor[];\n\treadonly allViewDescriptors: IViewDescriptor[];\n}\n\nexport interface IViewsRegistry {\n\n\treadonly onViewsRegistered: Event<{ views: IViewDescriptor[], viewContainer: ViewContainer }>;\n\n\treadonly onViewsDeregistered: Event<{ views: IViewDescriptor[], viewContainer: ViewContainer }>;\n\n\treadonly onDidChangeContainer: Event<{ views: IViewDescriptor[], from: ViewContainer, to: ViewContainer }>;\n\n\tregisterViews(views: IViewDescriptor[], viewContainer: ViewContainer): void;\n\n\tderegisterViews(views: IViewDescriptor[], viewContainer: ViewContainer): void;\n\n\tmoveViews(views: IViewDescriptor[], viewContainer: ViewContainer): void;\n\n\tgetViews(viewContainer: ViewContainer): IViewDescriptor[];\n\n\tgetView(id: string): IViewDescriptor | null;\n\n\tgetViewContainer(id: string): ViewContainer | null;\n}\n\nclass ViewsRegistry implements IViewsRegistry {\n\n\tprivate readonly _onViewsRegistered: Emitter<{ views: IViewDescriptor[], viewContainer: ViewContainer }> = new Emitter<{ views: IViewDescriptor[], viewContainer: ViewContainer }>();\n\treadonly onViewsRegistered: Event<{ views: IViewDescriptor[], viewContainer: ViewContainer }> = this._onViewsRegistered.event;\n\n\tprivate readonly _onViewsDeregistered: Emitter<{ views: IViewDescriptor[], viewContainer: ViewContainer }> = new Emitter<{ views: IViewDescriptor[], viewContainer: ViewContainer }>();\n\treadonly onViewsDeregistered: Event<{ views: IViewDescriptor[], viewContainer: ViewContainer }> = this._onViewsDeregistered.event;\n\n\tprivate readonly _onDidChangeContainer: Emitter<{ views: IViewDescriptor[], from: ViewContainer, to: ViewContainer }> = new Emitter<{ views: IViewDescriptor[], from: ViewContainer, to: ViewContainer }>();\n\treadonly onDidChangeContainer: Event<{ views: IViewDescriptor[], from: ViewContainer, to: ViewContainer }> = this._onDidChangeContainer.event;\n\n\tprivate _viewContainers: ViewContainer[] = [];\n\tprivate _views: Map<ViewContainer, IViewDescriptor[]> = new Map<ViewContainer, IViewDescriptor[]>();\n\n\tregisterViews(views: IViewDescriptor[], viewContainer: ViewContainer): void {\n\t\tthis.addViews(views, viewContainer);\n\t\tthis._onViewsRegistered.fire({ views: views, viewContainer });\n\t}\n\n\tderegisterViews(viewDescriptors: IViewDescriptor[], viewContainer: ViewContainer): void {\n\t\tconst views = this.removeViews(viewDescriptors, viewContainer);\n\t\tif (views.length) {\n\t\t\tthis._onViewsDeregistered.fire({ views, viewContainer });\n\t\t}\n\t}\n\n\tmoveViews(viewsToMove: IViewDescriptor[], viewContainer: ViewContainer): void {\n\t\tkeys(this._views).forEach(container => {\n\t\t\tif (container !== viewContainer) {\n\t\t\t\tconst views = this.removeViews(viewsToMove, container);\n\t\t\t\tif (views.length) {\n\t\t\t\t\tthis.addViews(views, viewContainer);\n\t\t\t\t\tthis._onDidChangeContainer.fire({ views, from: container, to: viewContainer });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tgetViews(loc: ViewContainer): IViewDescriptor[] {\n\t\treturn this._views.get(loc) || [];\n\t}\n\n\tgetView(id: string): IViewDescriptor | null {\n\t\tfor (const viewContainer of this._viewContainers) {\n\t\t\tconst viewDescriptor = (this._views.get(viewContainer) || []).filter(v => v.id === id)[0];\n\t\t\tif (viewDescriptor) {\n\t\t\t\treturn viewDescriptor;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetViewContainer(viewId: string): ViewContainer | null {\n\t\tfor (const viewContainer of this._viewContainers) {\n\t\t\tconst viewDescriptor = (this._views.get(viewContainer) || []).filter(v => v.id === viewId)[0];\n\t\t\tif (viewDescriptor) {\n\t\t\t\treturn viewContainer;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate addViews(viewDescriptors: IViewDescriptor[], viewContainer: ViewContainer): void {\n\t\tlet views = this._views.get(viewContainer);\n\t\tif (!views) {\n\t\t\tviews = [];\n\t\t\tthis._views.set(viewContainer, views);\n\t\t\tthis._viewContainers.push(viewContainer);\n\t\t}\n\t\tfor (const viewDescriptor of viewDescriptors) {\n\t\t\tif (views.some(v => v.id === viewDescriptor.id)) {\n\t\t\t\tthrow new Error(localize('duplicateId', \"A view with id '{0}' is already registered in the container '{1}'\", viewDescriptor.id, viewContainer.id));\n\t\t\t}\n\t\t\tviews.push(viewDescriptor);\n\t\t}\n\t}\n\n\tprivate removeViews(viewDescriptors: IViewDescriptor[], viewContainer: ViewContainer): IViewDescriptor[] {\n\t\tconst views = this._views.get(viewContainer);\n\t\tif (!views) {\n\t\t\treturn [];\n\t\t}\n\t\tconst viewsToDeregister: IViewDescriptor[] = [];\n\t\tconst remaningViews: IViewDescriptor[] = [];\n\t\tfor (const view of views) {\n\t\t\tif (viewDescriptors.indexOf(view) === -1) {\n\t\t\t\tremaningViews.push(view);\n\t\t\t} else {\n\t\t\t\tviewsToDeregister.push(view);\n\t\t\t}\n\t\t}\n\t\tif (viewsToDeregister.length) {\n\t\t\tif (remaningViews.length) {\n\t\t\t\tthis._views.set(viewContainer, remaningViews);\n\t\t\t} else {\n\t\t\t\tthis._views.delete(viewContainer);\n\t\t\t\tthis._viewContainers.splice(this._viewContainers.indexOf(viewContainer), 1);\n\t\t\t}\n\t\t}\n\t\treturn viewsToDeregister;\n\t}\n}\n\nRegistry.add(Extensions.ViewsRegistry, new ViewsRegistry());\n\nexport interface IView {\n\n\treadonly id: string;\n\n}\n\nexport interface IViewsViewlet extends IViewlet {\n\n\topenView(id: string, focus?: boolean): IView;\n\n}\n\nexport const IViewsService = createDecorator<IViewsService>('viewsService');\n\nexport interface IViewsService {\n\t_serviceBrand: ServiceIdentifier<any>;\n\n\topenView(id: string, focus?: boolean): Promise<IView | null>;\n\n\tgetViewDescriptors(container: ViewContainer): IViewDescriptorCollection | null;\n}\n\n// Custom views\n\nexport interface ITreeView extends IDisposable {\n\n\tdataProvider: ITreeViewDataProvider | null;\n\n\tshowCollapseAllAction: boolean;\n\n\tmessage?: string | IMarkdownString;\n\n\treadonly visible: boolean;\n\n\treadonly onDidExpandItem: Event<ITreeItem>;\n\n\treadonly onDidCollapseItem: Event<ITreeItem>;\n\n\treadonly onDidChangeSelection: Event<ITreeItem[]>;\n\n\treadonly onDidChangeVisibility: Event<boolean>;\n\n\treadonly onDidChangeActions: Event<void>;\n\n\trefresh(treeItems?: ITreeItem[]): Promise<void>;\n\n\tsetVisibility(visible: boolean): void;\n\n\tfocus(): void;\n\n\tlayout(height: number): void;\n\n\tshow(container: HTMLElement): void;\n\n\tgetOptimalWidth(): number;\n\n\treveal(item: ITreeItem): Promise<void>;\n\n\texpand(itemOrItems: ITreeItem | ITreeItem[]): Promise<void>;\n\n\tsetSelection(items: ITreeItem[]): void;\n\n\tsetFocus(item: ITreeItem): void;\n\n\tgetPrimaryActions(): IAction[];\n\n\tgetSecondaryActions(): IAction[];\n}\n\nexport interface IRevealOptions {\n\n\tselect?: boolean;\n\n\tfocus?: boolean;\n\n\texpand?: boolean | number;\n\n}\n\nexport interface ITreeViewDescriptor extends IViewDescriptor {\n\n\treadonly treeView: ITreeView;\n\n}\n\nexport type TreeViewItemHandleArg = {\n\t$treeViewId: string,\n\t$treeItemHandle: string\n};\n\nexport enum TreeItemCollapsibleState {\n\tNone = 0,\n\tCollapsed = 1,\n\tExpanded = 2\n}\n\nexport interface ITreeItemLabel {\n\n\tlabel: string;\n\n\thighlights?: [number, number][];\n\n}\n\nexport interface ITreeItem {\n\n\thandle: string;\n\n\tparentHandle: string | null;\n\n\tcollapsibleState: TreeItemCollapsibleState;\n\n\tlabel?: ITreeItemLabel;\n\n\tdescription?: string | boolean;\n\n\ticon?: UriComponents;\n\n\ticonDark?: UriComponents;\n\n\tthemeIcon?: ThemeIcon;\n\n\tresourceUri?: UriComponents;\n\n\ttooltip?: string;\n\n\tcontextValue?: string;\n\n\tcommand?: Command;\n\n\tchildren?: ITreeItem[];\n}\n\nexport interface ITreeViewDataProvider {\n\n\tgetChildren(element?: ITreeItem): Promise<ITreeItem[]>;\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { mapArrayOrNot } from 'vs/base/common/arrays';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as glob from 'vs/base/common/glob';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport * as objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport { getNLines } from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { IFilesConfiguration } from 'vs/platform/files/common/files';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ITelemetryData } from 'vs/platform/telemetry/common/telemetry';\nimport { Event } from 'vs/base/common/event';\nimport { ViewContainer, IViewContainersRegistry, Extensions as ViewContainerExtensions } from 'vs/workbench/common/views';\nimport { Registry } from 'vs/platform/registry/common/platform';\n\nexport const VIEWLET_ID = 'workbench.view.search';\nexport const PANEL_ID = 'workbench.view.search';\nexport const VIEW_ID = 'workbench.view.search';\n/**\n * Search viewlet container.\n */\nexport const VIEW_CONTAINER: ViewContainer = Registry.as<IViewContainersRegistry>(ViewContainerExtensions.ViewContainersRegistry).registerViewContainer(VIEWLET_ID, true);\n\nexport const ISearchService = createDecorator<ISearchService>('searchService');\n\n/**\n * A service that enables to search for files or with in files.\n */\nexport interface ISearchService {\n\t_serviceBrand: any;\n\ttextSearch(query: ITextQuery, token?: CancellationToken, onProgress?: (result: ISearchProgressItem) => void): Promise<ISearchComplete>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n\tregisterSearchResultProvider(scheme: string, type: SearchProviderType, provider: ISearchResultProvider): IDisposable;\n}\n\n/**\n * TODO@roblou - split text from file search entirely, or share code in a more natural way.\n */\nexport const enum SearchProviderType {\n\tfile,\n\ttext\n}\n\nexport interface ISearchResultProvider {\n\ttextSearch(query: ITextQuery, onProgress?: (p: ISearchProgressItem) => void, token?: CancellationToken): Promise<ISearchComplete | undefined>;\n\tfileSearch(query: IFileQuery, token?: CancellationToken): Promise<ISearchComplete | undefined>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IFolderQuery<U extends UriComponents=URI> {\n\tfolder: U;\n\texcludePattern?: glob.IExpression;\n\tincludePattern?: glob.IExpression;\n\tfileEncoding?: string;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface ICommonQueryProps<U extends UriComponents> {\n\t/** For telemetry - indicates what is triggering the source */\n\t_reason?: string;\n\n\tfolderQueries: IFolderQuery<U>[];\n\tincludePattern?: glob.IExpression;\n\texcludePattern?: glob.IExpression;\n\textraFileResources?: U[];\n\n\tmaxResults?: number;\n\tusingSearchPaths?: boolean;\n}\n\nexport interface IFileQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.File;\n\tfilePattern?: string;\n\n\t/**\n\t * If true no results will be returned. Instead `limitHit` will indicate if at least one result exists or not.\n\t * Currently does not work with queries including a 'siblings clause'.\n\t */\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryProps<U extends UriComponents> extends ICommonQueryProps<U> {\n\ttype: QueryType.Text;\n\tcontentPattern: IPatternInfo;\n\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tmaxFileSize?: number;\n\tusePCRE2?: boolean;\n\tafterContext?: number;\n\tbeforeContext?: number;\n\n\tuserDisabledExcludesAndIgnoreFiles?: boolean;\n}\n\nexport type IFileQuery = IFileQueryProps<URI>;\nexport type IRawFileQuery = IFileQueryProps<UriComponents>;\nexport type ITextQuery = ITextQueryProps<URI>;\nexport type IRawTextQuery = ITextQueryProps<UriComponents>;\n\nexport type IRawQuery = IRawTextQuery | IRawFileQuery;\nexport type ISearchQuery = ITextQuery | IFileQuery;\n\nexport const enum QueryType {\n\tFile = 1,\n\tText = 2\n}\n\n/* __GDPR__FRAGMENT__\n\t\"IPatternInfo\" : {\n\t\t\"pattern\" : { \"classification\": \"CustomerContent\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isRegExp\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isWordMatch\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"wordSeparators\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\"isMultiline\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isCaseSensitive\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n\t\t\"isSmartCase\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n\t}\n*/\nexport interface IPatternInfo {\n\tpattern: string;\n\tisRegExp?: boolean;\n\tisWordMatch?: boolean;\n\twordSeparators?: string;\n\tisMultiline?: boolean;\n\tisCaseSensitive?: boolean;\n}\n\nexport interface IExtendedExtensionSearchOptions {\n\tusePCRE2?: boolean;\n}\n\nexport interface IFileMatch<U extends UriComponents = URI> {\n\tresource: U;\n\tresults?: ITextSearchResult[];\n}\n\nexport type IRawFileMatch2 = IFileMatch<UriComponents>;\n\nexport interface ITextSearchPreviewOptions {\n\tmatchLines: number;\n\tcharsPerLine: number;\n}\n\nexport interface ISearchRange {\n\treadonly startLineNumber: number;\n\treadonly startColumn: number;\n\treadonly endLineNumber: number;\n\treadonly endColumn: number;\n}\n\nexport interface ITextSearchResultPreview {\n\ttext: string;\n\tmatches: ISearchRange | ISearchRange[];\n}\n\nexport interface ITextSearchMatch {\n\turi?: URI;\n\tranges: ISearchRange | ISearchRange[];\n\tpreview: ITextSearchResultPreview;\n}\n\nexport interface ITextSearchContext {\n\turi?: URI;\n\ttext: string;\n\tlineNumber: number;\n}\n\nexport type ITextSearchResult = ITextSearchMatch | ITextSearchContext;\n\nexport function resultIsMatch(result: ITextSearchResult): result is ITextSearchMatch {\n\treturn !!(<ITextSearchMatch>result).preview;\n}\n\nexport interface IProgress {\n\ttotal?: number;\n\tworked?: number;\n\tmessage?: string;\n}\n\nexport type ISearchProgressItem = IFileMatch | IProgress;\n\nexport interface ISearchCompleteStats {\n\tlimitHit?: boolean;\n\tstats?: IFileSearchStats | ITextSearchStats;\n}\n\nexport interface ISearchComplete extends ISearchCompleteStats {\n\tresults: IFileMatch[];\n}\n\nexport interface ITextSearchStats {\n\ttype: 'textSearchProvider' | 'searchProcess';\n}\n\nexport interface IFileSearchStats {\n\tfromCache: boolean;\n\tdetailStats: ISearchEngineStats | ICachedSearchStats | IFileSearchProviderStats;\n\n\tresultCount: number;\n\ttype: 'fileSearchProvider' | 'searchProcess';\n\tsortingTime?: number;\n}\n\nexport interface ICachedSearchStats {\n\tcacheWasResolved: boolean;\n\tcacheLookupTime: number;\n\tcacheFilterTime: number;\n\tcacheEntryCount: number;\n}\n\nexport interface ISearchEngineStats {\n\tfileWalkTime: number;\n\tdirectoriesWalked: number;\n\tfilesWalked: number;\n\tcmdTime: number;\n\tcmdResultCount?: number;\n}\n\nexport interface IFileSearchProviderStats {\n\tproviderTime: number;\n\tpostProcessTime: number;\n}\n\nexport class FileMatch implements IFileMatch {\n\tresults: ITextSearchResult[] = [];\n\tconstructor(public resource: URI) {\n\t\t// empty\n\t}\n}\n\nexport class TextSearchMatch implements ITextSearchMatch {\n\tranges: ISearchRange | ISearchRange[];\n\tpreview: ITextSearchResultPreview;\n\n\tconstructor(text: string, range: ISearchRange | ISearchRange[], previewOptions?: ITextSearchPreviewOptions) {\n\t\tthis.ranges = range;\n\n\t\tif (previewOptions && previewOptions.matchLines === 1 && !Array.isArray(range)) {\n\t\t\t// 1 line preview requested\n\t\t\ttext = getNLines(text, previewOptions.matchLines);\n\t\t\tconst leadingChars = Math.floor(previewOptions.charsPerLine / 5);\n\t\t\tconst previewStart = Math.max(range.startColumn - leadingChars, 0);\n\t\t\tconst previewText = text.substring(previewStart, previewOptions.charsPerLine + previewStart);\n\n\t\t\tconst endColInPreview = (range.endLineNumber - range.startLineNumber + 1) <= previewOptions.matchLines ?\n\t\t\t\tMath.min(previewText.length, range.endColumn - previewStart) :  // if number of match lines will not be trimmed by previewOptions\n\t\t\t\tpreviewText.length; // if number of lines is trimmed\n\n\t\t\tthis.preview = {\n\t\t\t\ttext: previewText,\n\t\t\t\tmatches: new OneLineRange(0, range.startColumn - previewStart, endColInPreview)\n\t\t\t};\n\t\t} else {\n\t\t\tconst firstMatchLine = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;\n\n\t\t\t// n line, no preview requested, or multiple matches in the preview\n\t\t\tthis.preview = {\n\t\t\t\ttext,\n\t\t\t\tmatches: mapArrayOrNot(range, r => new SearchRange(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn))\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport class SearchRange implements ISearchRange {\n\tstartLineNumber: number;\n\tstartColumn: number;\n\tendLineNumber: number;\n\tendColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.startColumn = startColumn;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.endColumn = endColumn;\n\t}\n}\n\nexport class OneLineRange extends SearchRange {\n\tconstructor(lineNumber: number, startColumn: number, endColumn: number) {\n\t\tsuper(lineNumber, startColumn, lineNumber, endColumn);\n\t}\n}\n\nexport interface ISearchConfigurationProperties {\n\texclude: glob.IExpression;\n\tuseRipgrep: boolean;\n\t/**\n\t * Use ignore file for file search.\n\t */\n\tuseIgnoreFiles: boolean;\n\tuseGlobalIgnoreFiles: boolean;\n\tfollowSymlinks: boolean;\n\tsmartCase: boolean;\n\tglobalFindClipboard: boolean;\n\tlocation: 'sidebar' | 'panel';\n\tuseReplacePreview: boolean;\n\tshowLineNumbers: boolean;\n\tusePCRE2: boolean;\n\tactionsPosition: 'auto' | 'right';\n\tmaintainFileSearchCache: boolean;\n\tcollapseResults: 'auto' | 'alwaysCollapse' | 'alwaysExpand';\n}\n\nexport interface ISearchConfiguration extends IFilesConfiguration {\n\tsearch: ISearchConfigurationProperties;\n\teditor: {\n\t\twordSeparators: string;\n\t};\n}\n\nexport function getExcludes(configuration: ISearchConfiguration, includeSearchExcludes = true): glob.IExpression | undefined {\n\tconst fileExcludes = configuration && configuration.files && configuration.files.exclude;\n\tconst searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;\n\n\tif (!fileExcludes && !searchExcludes) {\n\t\treturn undefined;\n\t}\n\n\tif (!fileExcludes || !searchExcludes) {\n\t\treturn fileExcludes || searchExcludes;\n\t}\n\n\tlet allExcludes: glob.IExpression = Object.create(null);\n\t// clone the config as it could be frozen\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));\n\tallExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);\n\n\treturn allExcludes;\n}\n\nexport function pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern && !glob.match(queryProps.includePattern, fsPath)) {\n\t\treturn false;\n\t}\n\n\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\tif (queryProps.usingSearchPaths) {\n\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.every(fq => {\n\t\t\tconst searchPath = fq.folder.fsPath;\n\t\t\tif (extpath.isEqualOrParent(fsPath, searchPath)) {\n\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, fsPath);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn true;\n}\n\nexport enum SearchErrorCode {\n\tunknownEncoding = 1,\n\tregexParseError,\n\tglobParseError,\n\tinvalidLiteral,\n\trgProcessError,\n\tother\n}\n\nexport class SearchError extends Error {\n\tconstructor(message: string, readonly code?: SearchErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function deserializeSearchError(errorMsg: string): SearchError {\n\ttry {\n\t\tconst details = JSON.parse(errorMsg);\n\t\treturn new SearchError(details.message, details.code);\n\t} catch (e) {\n\t\treturn new SearchError(errorMsg, SearchErrorCode.other);\n\t}\n}\n\nexport function serializeSearchError(searchError: SearchError): Error {\n\tconst details = { message: searchError.message, code: searchError.code };\n\treturn new Error(JSON.stringify(details));\n}\nexport interface ITelemetryEvent {\n\teventName: string;\n\tdata: ITelemetryData;\n}\n\nexport interface IRawSearchService {\n\tfileSearch(search: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\ttextSearch(search: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;\n\tclearCache(cacheKey: string): Promise<void>;\n}\n\nexport interface IRawFileMatch {\n\tbase?: string;\n\trelativePath: string;\n\tbasename: string;\n\tsize?: number;\n}\n\nexport interface ISearchEngine<T> {\n\tsearch: (onResult: (matches: T) => void, onProgress: (progress: IProgress) => void, done: (error: Error | null, complete: ISearchEngineSuccess) => void) => void;\n\tcancel: () => void;\n}\n\nexport interface ISerializedSearchSuccess {\n\ttype: 'success';\n\tlimitHit: boolean;\n\tstats: IFileSearchStats | ITextSearchStats | null;\n}\n\nexport interface ISearchEngineSuccess {\n\tlimitHit: boolean;\n\tstats: ISearchEngineStats;\n}\n\nexport interface ISerializedSearchError {\n\ttype: 'error';\n\terror: {\n\t\tmessage: string,\n\t\tstack: string\n\t};\n}\n\nexport type ISerializedSearchComplete = ISerializedSearchSuccess | ISerializedSearchError;\n\nexport function isSerializedSearchComplete(arg: ISerializedSearchProgressItem | ISerializedSearchComplete): arg is ISerializedSearchComplete {\n\tif ((arg as any).type === 'error') {\n\t\treturn true;\n\t} else if ((arg as any).type === 'success') {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function isSerializedSearchSuccess(arg: ISerializedSearchComplete): arg is ISerializedSearchSuccess {\n\treturn arg.type === 'success';\n}\n\nexport function isSerializedFileMatch(arg: ISerializedSearchProgressItem): arg is ISerializedFileMatch {\n\treturn !!(<ISerializedFileMatch>arg).path;\n}\n\nexport interface ISerializedFileMatch {\n\tpath?: string;\n\tresults?: ITextSearchResult[];\n\tnumMatches?: number;\n}\n\n// Type of the possible values for progress calls from the engine\nexport type ISerializedSearchProgressItem = ISerializedFileMatch | ISerializedFileMatch[] | IProgress;\nexport type IFileSearchProgressItem = IRawFileMatch | IRawFileMatch[] | IProgress;\n\n\nexport class SerializableFileMatch implements ISerializedFileMatch {\n\tpath: string;\n\tresults: ITextSearchMatch[];\n\n\tconstructor(path: string) {\n\t\tthis.path = path;\n\t\tthis.results = [];\n\t}\n\n\taddMatch(match: ITextSearchMatch): void {\n\t\tthis.results.push(match);\n\t}\n\n\tserialize(): ISerializedFileMatch {\n\t\treturn {\n\t\t\tpath: this.path,\n\t\t\tresults: this.results,\n\t\t\tnumMatches: this.results.length\n\t\t};\n\t}\n}\n\n/**\n *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns\n */\nexport function resolvePatternsForProvider(globalPattern: glob.IExpression | undefined, folderPattern: glob.IExpression | undefined): string[] {\n\tconst merged = {\n\t\t...(globalPattern || {}),\n\t\t...(folderPattern || {})\n\t};\n\n\treturn Object.keys(merged)\n\t\t.filter(key => {\n\t\t\tconst value = merged[key];\n\t\t\treturn typeof value === 'boolean' && value;\n\t\t});\n}\n\nexport class QueryGlobTester {\n\n\tprivate _excludeExpression: glob.IExpression;\n\tprivate _parsedExcludeExpression: glob.ParsedExpression;\n\n\tprivate _parsedIncludeExpression: glob.ParsedExpression;\n\n\tconstructor(config: ISearchQuery, folderQuery: IFolderQuery) {\n\t\tthis._excludeExpression = {\n\t\t\t...(config.excludePattern || {}),\n\t\t\t...(folderQuery.excludePattern || {})\n\t\t};\n\t\tthis._parsedExcludeExpression = glob.parse(this._excludeExpression);\n\n\t\t// Empty includeExpression means include nothing, so no {} shortcuts\n\t\tlet includeExpression: glob.IExpression | undefined = config.includePattern;\n\t\tif (folderQuery.includePattern) {\n\t\t\tif (includeExpression) {\n\t\t\t\tincludeExpression = {\n\t\t\t\t\t...includeExpression,\n\t\t\t\t\t...folderQuery.includePattern\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tincludeExpression = folderQuery.includePattern;\n\t\t\t}\n\t\t}\n\n\t\tif (includeExpression) {\n\t\t\tthis._parsedIncludeExpression = glob.parse(includeExpression);\n\t\t}\n\t}\n\n\t/**\n\t * Guaranteed sync - siblingsFn should not return a promise.\n\t */\n\tincludedInQuerySync(testPath: string, basename?: string, hasSibling?: (name: string) => boolean): boolean {\n\t\tif (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Guaranteed async.\n\t */\n\tincludedInQuery(testPath: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): Promise<boolean> {\n\t\tconst excludeP = this._parsedExcludeExpression ?\n\t\t\tPromise.resolve(this._parsedExcludeExpression(testPath, basename, hasSibling)).then(result => !!result) :\n\t\t\tPromise.resolve(false);\n\n\t\treturn excludeP.then(excluded => {\n\t\t\tif (excluded) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn this._parsedIncludeExpression ?\n\t\t\t\tPromise.resolve(this._parsedIncludeExpression(testPath, basename, hasSibling)).then(result => !!result) :\n\t\t\t\tPromise.resolve(true);\n\t\t}).then(included => {\n\t\t\treturn included;\n\t\t});\n\t}\n\n\thasSiblingExcludeClauses(): boolean {\n\t\treturn hasSiblingClauses(this._excludeExpression);\n\t}\n}\n\nfunction hasSiblingClauses(pattern: glob.IExpression): boolean {\n\tfor (const key in pattern) {\n\t\tif (typeof pattern[key] !== 'boolean') {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { startsWith } from 'vs/base/common/strings';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { SearchRange, TextSearchMatch } from 'vs/workbench/services/search/common/search';\nimport * as vscode from 'vscode';\nimport { mapArrayOrNot } from 'vs/base/common/arrays';\n\nexport type Maybe<T> = T | null | undefined;\n\nexport function anchorGlob(glob: string): string {\n\treturn startsWith(glob, '**') || startsWith(glob, '/') ? glob : `/${glob}`;\n}\n\n/**\n * Create a vscode.TextSearchResult by using our internal TextSearchResult type for its previewOptions logic.\n */\nexport function createTextSearchResult(uri: vscode.Uri, text: string, range: Range | Range[], previewOptions?: vscode.TextSearchPreviewOptions): vscode.TextSearchMatch {\n\tconst searchRange = mapArrayOrNot(range, rangeToSearchRange);\n\n\tconst internalResult = new TextSearchMatch(text, searchRange, previewOptions);\n\tconst internalPreviewRange = internalResult.preview.matches;\n\treturn {\n\t\tranges: mapArrayOrNot(searchRange, searchRangeToRange),\n\t\turi,\n\t\tpreview: {\n\t\t\ttext: internalResult.preview.text,\n\t\t\tmatches: mapArrayOrNot(internalPreviewRange, searchRangeToRange)\n\t\t}\n\t};\n}\n\nfunction rangeToSearchRange(range: Range): SearchRange {\n\treturn new SearchRange(range.start.line, range.start.character, range.end.line, range.end.character);\n}\n\nfunction searchRangeToRange(range: SearchRange): Range {\n\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n}\n\nexport class Position {\n\tconstructor(readonly line, readonly character) { }\n\n\tisBefore(other: Position): boolean { return false; }\n\tisBeforeOrEqual(other: Position): boolean { return false; }\n\tisAfter(other: Position): boolean { return false; }\n\tisAfterOrEqual(other: Position): boolean { return false; }\n\tisEqual(other: Position): boolean { return false; }\n\tcompareTo(other: Position): number { return 0; }\n\ttranslate(lineDelta?: number, characterDelta?: number): Position;\n\ttranslate(change: { lineDelta?: number; characterDelta?: number; }): Position;\n\ttranslate(_?: any, _2?: any): Position { return new Position(0, 0); }\n\twith(line?: number, character?: number): Position;\n\twith(change: { line?: number; character?: number; }): Position;\n\twith(_: any): Position { return new Position(0, 0); }\n}\n\nexport class Range {\n\treadonly start: Position;\n\treadonly end: Position;\n\n\tconstructor(startLine: number, startCol: number, endLine: number, endCol: number) {\n\t\tthis.start = new Position(startLine, startCol);\n\t\tthis.end = new Position(endLine, endCol);\n\t}\n\n\tisEmpty: boolean;\n\tisSingleLine: boolean;\n\tcontains(positionOrRange: Position | Range): boolean { return false; }\n\tisEqual(other: Range): boolean { return false; }\n\tintersection(range: Range): Range | undefined { return undefined; }\n\tunion(other: Range): Range { return new Range(0, 0, 0, 0); }\n\n\twith(start?: Position, end?: Position): Range;\n\twith(change: { start?: Position, end?: Position }): Range;\n\twith(_: any): Range { return new Range(0, 0, 0, 0); }\n}\n\nexport interface IOutputChannel {\n\tappendLine(msg: string): void;\n}\n\nexport class OutputChannel implements IOutputChannel {\n\tconstructor(@ILogService private readonly logService: ILogService) { }\n\n\tappendLine(msg: string): void {\n\t\tthis.logService.debug('RipgrepSearchEH#search', msg);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { IChannel, IServerChannel } from 'vs/base/parts/ipc/node/ipc';\nimport { IRawFileQuery, IRawTextQuery, IRawSearchService, ISerializedSearchComplete, ISerializedSearchProgressItem } from 'vs/workbench/services/search/common/search';\n\nexport class SearchChannel implements IServerChannel {\n\n\tconstructor(private service: IRawSearchService) { }\n\n\tlisten<T>(_, event: string, arg?: any): Event<any> {\n\t\tswitch (event) {\n\t\t\tcase 'fileSearch': return this.service.fileSearch(arg);\n\t\t\tcase 'textSearch': return this.service.textSearch(arg);\n\t\t}\n\t\tthrow new Error('Event not found');\n\t}\n\n\tcall(_, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'clearCache': return this.service.clearCache(arg);\n\t\t}\n\t\tthrow new Error('Call not found');\n\t}\n}\n\nexport class SearchChannelClient implements IRawSearchService {\n\n\tconstructor(private channel: IChannel) { }\n\n\tfileSearch(search: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\treturn this.channel.listen('fileSearch', search);\n\t}\n\n\ttextSearch(search: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\treturn this.channel.listen('textSearch', search);\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\treturn this.channel.call('clearCache', cacheKey);\n\t}\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport { mapArrayOrNot } from 'vs/base/common/arrays';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport * as glob from 'vs/base/common/glob';\nimport * as resources from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { toCanonicalName } from 'vs/base/node/encoding';\nimport * as extfs from 'vs/base/node/extfs';\nimport { IExtendedExtensionSearchOptions, IFileMatch, IFolderQuery, IPatternInfo, ISearchCompleteStats, ITextQuery, ITextSearchContext, ITextSearchMatch, ITextSearchResult, QueryGlobTester, resolvePatternsForProvider } from 'vs/workbench/services/search/common/search';\nimport * as vscode from 'vscode';\n\nexport class TextSearchManager {\n\n\tprivate collector: TextSearchResultsCollector;\n\n\tprivate isLimitHit: boolean;\n\tprivate resultCount = 0;\n\n\tconstructor(private query: ITextQuery, private provider: vscode.TextSearchProvider, private _extfs: typeof extfs = extfs) {\n\t}\n\n\tsearch(onProgress: (matches: IFileMatch[]) => void, token: CancellationToken): Promise<ISearchCompleteStats> {\n\t\tconst folderQueries = this.query.folderQueries || [];\n\t\tconst tokenSource = new CancellationTokenSource();\n\t\ttoken.onCancellationRequested(() => tokenSource.cancel());\n\n\t\treturn new Promise<ISearchCompleteStats>((resolve, reject) => {\n\t\t\tthis.collector = new TextSearchResultsCollector(onProgress);\n\n\t\t\tlet isCanceled = false;\n\t\t\tconst onResult = (result: vscode.TextSearchResult, folderIdx: number) => {\n\t\t\t\tif (isCanceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.isLimitHit) {\n\t\t\t\t\tconst resultSize = this.resultSize(result);\n\t\t\t\t\tif (extensionResultIsMatch(result) && typeof this.query.maxResults === 'number' && this.resultCount + resultSize > this.query.maxResults) {\n\t\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t\t\tisCanceled = true;\n\t\t\t\t\t\ttokenSource.cancel();\n\n\t\t\t\t\t\tresult = this.trimResultToSize(result, this.query.maxResults - this.resultCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst newResultSize = this.resultSize(result);\n\t\t\t\t\tthis.resultCount += newResultSize;\n\t\t\t\t\tif (newResultSize > 0) {\n\t\t\t\t\t\tthis.collector.add(result, folderIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// For each root folder\n\t\t\tPromise.all(folderQueries.map((fq, i) => {\n\t\t\t\treturn this.searchInFolder(fq, r => onResult(r, i), tokenSource.token);\n\t\t\t})).then(results => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tthis.collector.flush();\n\n\t\t\t\tconst someFolderHitLImit = results.some(result => !!result && !!result.limitHit);\n\t\t\t\tresolve({\n\t\t\t\t\tlimitHit: this.isLimitHit || someFolderHitLImit,\n\t\t\t\t\tstats: {\n\t\t\t\t\t\ttype: 'textSearchProvider'\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, (err: Error) => {\n\t\t\t\ttokenSource.dispose();\n\t\t\t\tconst errMsg = toErrorMessage(err);\n\t\t\t\treject(new Error(errMsg));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate resultSize(result: vscode.TextSearchResult): number {\n\t\tconst match = <vscode.TextSearchMatch>result;\n\t\treturn Array.isArray(match.ranges) ?\n\t\t\tmatch.ranges.length :\n\t\t\t1;\n\t}\n\n\tprivate trimResultToSize(result: vscode.TextSearchMatch, size: number): vscode.TextSearchMatch {\n\t\tconst rangesArr = Array.isArray(result.ranges) ? result.ranges : [result.ranges];\n\t\tconst matchesArr = Array.isArray(result.preview.matches) ? result.preview.matches : [result.preview.matches];\n\n\t\treturn {\n\t\t\tranges: rangesArr.slice(0, size),\n\t\t\tpreview: {\n\t\t\t\tmatches: matchesArr.slice(0, size),\n\t\t\t\ttext: result.preview.text\n\t\t\t},\n\t\t\turi: result.uri\n\t\t};\n\t}\n\n\tprivate searchInFolder(folderQuery: IFolderQuery<URI>, onResult: (result: vscode.TextSearchResult) => void, token: CancellationToken): Promise<vscode.TextSearchComplete | null | undefined> {\n\t\tconst queryTester = new QueryGlobTester(this.query, folderQuery);\n\t\tconst testingPs: Promise<void>[] = [];\n\t\tconst progress = {\n\t\t\treport: (result: vscode.TextSearchResult) => {\n\t\t\t\tif (!this.validateProviderResult(result)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst hasSibling = folderQuery.folder.scheme === 'file' ?\n\t\t\t\t\tglob.hasSiblingPromiseFn(() => {\n\t\t\t\t\t\treturn this.readdir(path.dirname(result.uri.fsPath));\n\t\t\t\t\t}) :\n\t\t\t\t\tundefined;\n\n\t\t\t\tconst relativePath = path.relative(folderQuery.folder.fsPath, result.uri.fsPath);\n\t\t\t\ttestingPs.push(\n\t\t\t\t\tqueryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling)\n\t\t\t\t\t\t.then(included => {\n\t\t\t\t\t\t\tif (included) {\n\t\t\t\t\t\t\t\tonResult(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t}\n\t\t};\n\n\t\tconst searchOptions = this.getSearchOptionsForFolder(folderQuery);\n\t\treturn new Promise(resolve => process.nextTick(resolve))\n\t\t\t.then(() => this.provider.provideTextSearchResults(patternInfoToQuery(this.query.contentPattern), searchOptions, progress, token))\n\t\t\t.then(result => {\n\t\t\t\treturn Promise.all(testingPs)\n\t\t\t\t\t.then(() => result);\n\t\t\t});\n\t}\n\n\tprivate validateProviderResult(result: vscode.TextSearchResult): boolean {\n\t\tif (extensionResultIsMatch(result)) {\n\t\t\tif (Array.isArray(result.ranges)) {\n\t\t\t\tif (!Array.isArray(result.preview.matches)) {\n\t\t\t\t\tconsole.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same type.');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif ((<vscode.Range[]>result.preview.matches).length !== result.ranges.length) {\n\t\t\t\t\tconsole.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same length.');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Array.isArray(result.preview.matches)) {\n\t\t\t\t\tconsole.warn('INVALID - A text search provider match\\'s`ranges` and`matches` properties must have the same length.');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate readdir(dirname: string): Promise<string[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._extfs.readdir(dirname, (err, files) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\n\t\t\t\tresolve(files);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getSearchOptionsForFolder(fq: IFolderQuery<URI>): vscode.TextSearchOptions {\n\t\tconst includes = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);\n\t\tconst excludes = resolvePatternsForProvider(this.query.excludePattern, fq.excludePattern);\n\n\t\tconst options = <vscode.TextSearchOptions>{\n\t\t\tfolder: URI.from(fq.folder),\n\t\t\texcludes,\n\t\t\tincludes,\n\t\t\tuseIgnoreFiles: !fq.disregardIgnoreFiles,\n\t\t\tuseGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,\n\t\t\tfollowSymlinks: !fq.ignoreSymlinks,\n\t\t\tencoding: fq.fileEncoding && toCanonicalName(fq.fileEncoding),\n\t\t\tmaxFileSize: this.query.maxFileSize,\n\t\t\tmaxResults: this.query.maxResults,\n\t\t\tpreviewOptions: this.query.previewOptions,\n\t\t\tafterContext: this.query.afterContext,\n\t\t\tbeforeContext: this.query.beforeContext\n\t\t};\n\t\t(<IExtendedExtensionSearchOptions>options).usePCRE2 = this.query.usePCRE2;\n\t\treturn options;\n\t}\n}\n\nfunction patternInfoToQuery(patternInfo: IPatternInfo): vscode.TextSearchQuery {\n\treturn <vscode.TextSearchQuery>{\n\t\tisCaseSensitive: patternInfo.isCaseSensitive || false,\n\t\tisRegExp: patternInfo.isRegExp || false,\n\t\tisWordMatch: patternInfo.isWordMatch || false,\n\t\tisMultiline: patternInfo.isMultiline || false,\n\t\tpattern: patternInfo.pattern\n\t};\n}\n\nexport class TextSearchResultsCollector {\n\tprivate _batchedCollector: BatchedCollector<IFileMatch>;\n\n\tprivate _currentFolderIdx: number;\n\tprivate _currentUri: URI;\n\tprivate _currentFileMatch: IFileMatch | null = null;\n\n\tconstructor(private _onResult: (result: IFileMatch[]) => void) {\n\t\tthis._batchedCollector = new BatchedCollector<IFileMatch>(512, items => this.sendItems(items));\n\t}\n\n\tadd(data: vscode.TextSearchResult, folderIdx: number): void {\n\t\t// Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.\n\t\t// This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search\n\t\t// providers that send results in random order. We could do this step afterwards instead.\n\t\tif (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !resources.isEqual(this._currentUri, data.uri))) {\n\t\t\tthis.pushToCollector();\n\t\t\tthis._currentFileMatch = null;\n\t\t}\n\n\t\tif (!this._currentFileMatch) {\n\t\t\tthis._currentFolderIdx = folderIdx;\n\t\t\tthis._currentFileMatch = {\n\t\t\t\tresource: data.uri,\n\t\t\t\tresults: []\n\t\t\t};\n\t\t}\n\n\t\tthis._currentFileMatch.results!.push(extensionResultToFrontendResult(data));\n\t}\n\n\tprivate pushToCollector(): void {\n\t\tconst size = this._currentFileMatch && this._currentFileMatch.results ?\n\t\t\tthis._currentFileMatch.results.length :\n\t\t\t0;\n\t\tthis._batchedCollector.addItem(this._currentFileMatch!, size);\n\t}\n\n\tflush(): void {\n\t\tthis.pushToCollector();\n\t\tthis._batchedCollector.flush();\n\t}\n\n\tprivate sendItems(items: IFileMatch[]): void {\n\t\tthis._onResult(items);\n\t}\n}\n\nfunction extensionResultToFrontendResult(data: vscode.TextSearchResult): ITextSearchResult {\n\t// Warning: result from RipgrepTextSearchEH has fake vscode.Range. Don't depend on any other props beyond these...\n\tif (extensionResultIsMatch(data)) {\n\t\treturn <ITextSearchMatch>{\n\t\t\tpreview: {\n\t\t\t\tmatches: mapArrayOrNot(data.preview.matches, m => ({\n\t\t\t\t\tstartLineNumber: m.start.line,\n\t\t\t\t\tstartColumn: m.start.character,\n\t\t\t\t\tendLineNumber: m.end.line,\n\t\t\t\t\tendColumn: m.end.character\n\t\t\t\t})),\n\t\t\t\ttext: data.preview.text\n\t\t\t},\n\t\t\tranges: mapArrayOrNot(data.ranges, r => ({\n\t\t\t\tstartLineNumber: r.start.line,\n\t\t\t\tstartColumn: r.start.character,\n\t\t\t\tendLineNumber: r.end.line,\n\t\t\t\tendColumn: r.end.character\n\t\t\t}))\n\t\t};\n\t} else {\n\t\treturn <ITextSearchContext>{\n\t\t\ttext: data.text,\n\t\t\tlineNumber: data.lineNumber\n\t\t};\n\t}\n}\n\nexport function extensionResultIsMatch(data: vscode.TextSearchResult): data is vscode.TextSearchMatch {\n\treturn !!(<vscode.TextSearchMatch>data).preview;\n}\n\n/**\n * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every\n * set of items collected.\n * But after that point, the callback is called with batches of maxBatchSize.\n * If the batch isn't filled within some time, the callback is also called.\n */\nexport class BatchedCollector<T> {\n\tprivate static readonly TIMEOUT = 4000;\n\n\t// After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout\n\tprivate static readonly START_BATCH_AFTER_COUNT = 50;\n\n\tprivate totalNumberCompleted = 0;\n\tprivate batch: T[] = [];\n\tprivate batchSize = 0;\n\tprivate timeoutHandle: any;\n\n\tconstructor(private maxBatchSize: number, private cb: (items: T[]) => void) {\n\t}\n\n\taddItem(item: T, size: number): void {\n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemToBatch(item, size);\n\t}\n\n\taddItems(items: T[], size: number): void {\n\t\tif (!items) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.addItemsToBatch(items, size);\n\t}\n\n\tprivate addItemToBatch(item: T, size: number): void {\n\t\tthis.batch.push(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate addItemsToBatch(item: T[], size: number): void {\n\t\tthis.batch = this.batch.concat(item);\n\t\tthis.batchSize += size;\n\t\tthis.onUpdate();\n\t}\n\n\tprivate onUpdate(): void {\n\t\tif (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {\n\t\t\t// Flush because we aren't batching yet\n\t\t\tthis.flush();\n\t\t} else if (this.batchSize >= this.maxBatchSize) {\n\t\t\t// Flush because the batch is full\n\t\t\tthis.flush();\n\t\t} else if (!this.timeoutHandle) {\n\t\t\t// No timeout running, start a timeout to flush\n\t\t\tthis.timeoutHandle = setTimeout(() => {\n\t\t\t\tthis.flush();\n\t\t\t}, BatchedCollector.TIMEOUT);\n\t\t}\n\t}\n\n\tflush(): void {\n\t\tif (this.batchSize) {\n\t\t\tthis.totalNumberCompleted += this.batchSize;\n\t\t\tthis.cb(this.batch);\n\t\t\tthis.batch = [];\n\t\t\tthis.batchSize = 0;\n\n\t\t\tif (this.timeoutHandle) {\n\t\t\t\tclearTimeout(this.timeoutHandle);\n\t\t\t\tthis.timeoutHandle = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport * as path from 'vs/base/common/path';\nimport * as glob from 'vs/base/common/glob';\nimport { normalizeNFD } from 'vs/base/common/normalization';\nimport * as objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport { isMacintosh as isMac } from 'vs/base/common/platform';\nimport * as strings from 'vs/base/common/strings';\nimport { IFileQuery, IFolderQuery } from 'vs/workbench/services/search/common/search';\nimport { anchorGlob } from 'vs/workbench/services/search/node/ripgrepSearchUtils';\nimport { rgPath } from 'vscode-ripgrep';\n\n// If vscode-ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport function spawnRipgrepCmd(config: IFileQuery, folderQuery: IFolderQuery, includePattern?: glob.IExpression, excludePattern?: glob.IExpression) {\n\tconst rgArgs = getRgArgs(config, folderQuery, includePattern, excludePattern);\n\tconst cwd = folderQuery.folder.fsPath;\n\treturn {\n\t\tcmd: cp.spawn(rgDiskPath, rgArgs.args, { cwd }),\n\t\tsiblingClauses: rgArgs.siblingClauses,\n\t\trgArgs,\n\t\tcwd\n\t};\n}\n\nfunction getRgArgs(config: IFileQuery, folderQuery: IFolderQuery, includePattern?: glob.IExpression, excludePattern?: glob.IExpression) {\n\tconst args = ['--files', '--hidden', '--case-sensitive'];\n\n\t// includePattern can't have siblingClauses\n\tfoldersToIncludeGlobs([folderQuery], includePattern, false).forEach(globArg => {\n\t\tconst inclusion = anchorGlob(globArg);\n\t\targs.push('-g', inclusion);\n\t\tif (isMac) {\n\t\t\tconst normalized = normalizeNFD(inclusion);\n\t\t\tif (normalized !== inclusion) {\n\t\t\t\targs.push('-g', normalized);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst rgGlobs = foldersToRgExcludeGlobs([folderQuery], excludePattern, undefined, false);\n\trgGlobs.globArgs.forEach(globArg => {\n\t\tconst exclusion = `!${anchorGlob(globArg)}`;\n\t\targs.push('-g', exclusion);\n\t\tif (isMac) {\n\t\t\tconst normalized = normalizeNFD(exclusion);\n\t\t\tif (normalized !== exclusion) {\n\t\t\t\targs.push('-g', normalized);\n\t\t\t}\n\t\t}\n\t});\n\tif (folderQuery.disregardIgnoreFiles !== false) {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t} else {\n\t\targs.push('--no-ignore-parent');\n\t}\n\n\t// Follow symlinks\n\tif (!folderQuery.ignoreSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (config.exists) {\n\t\targs.push('--quiet');\n\t}\n\n\targs.push('--no-config');\n\tif (folderQuery.disregardGlobalIgnoreFiles) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\treturn {\n\t\targs,\n\t\tsiblingClauses: rgGlobs.siblingClauses\n\t};\n}\n\nexport interface IRgGlobResult {\n\tglobArgs: string[];\n\tsiblingClauses: glob.IExpression;\n}\n\nexport function foldersToRgExcludeGlobs(folderQueries: IFolderQuery[], globalExclude?: glob.IExpression, excludesToSkip?: Set<string>, absoluteGlobs = true): IRgGlobResult {\n\tconst globArgs: string[] = [];\n\tlet siblingClauses: glob.IExpression = {};\n\tfolderQueries.forEach(folderQuery => {\n\t\tconst totalExcludePattern = objects.assign({}, folderQuery.excludePattern || {}, globalExclude || {});\n\t\tconst result = globExprsToRgGlobs(totalExcludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined, excludesToSkip);\n\t\tglobArgs.push(...result.globArgs);\n\t\tif (result.siblingClauses) {\n\t\t\tsiblingClauses = objects.assign(siblingClauses, result.siblingClauses);\n\t\t}\n\t});\n\n\treturn { globArgs, siblingClauses };\n}\n\nexport function foldersToIncludeGlobs(folderQueries: IFolderQuery[], globalInclude?: glob.IExpression, absoluteGlobs = true): string[] {\n\tconst globArgs: string[] = [];\n\tfolderQueries.forEach(folderQuery => {\n\t\tconst totalIncludePattern = objects.assign({}, globalInclude || {}, folderQuery.includePattern || {});\n\t\tconst result = globExprsToRgGlobs(totalIncludePattern, absoluteGlobs ? folderQuery.folder.fsPath : undefined);\n\t\tglobArgs.push(...result.globArgs);\n\t});\n\n\treturn globArgs;\n}\n\nfunction globExprsToRgGlobs(patterns: glob.IExpression, folder?: string, excludesToSkip?: Set<string>): IRgGlobResult {\n\tconst globArgs: string[] = [];\n\tconst siblingClauses: glob.IExpression = {};\n\tObject.keys(patterns)\n\t\t.forEach(key => {\n\t\t\tif (excludesToSkip && excludesToSkip.has(key)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!key) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst value = patterns[key];\n\t\t\tkey = trimTrailingSlash(folder ? getAbsoluteGlob(folder, key) : key);\n\n\t\t\t// glob.ts requires forward slashes, but a UNC path still must start with \\\\\n\t\t\t// #38165 and #38151\n\t\t\tif (strings.startsWith(key, '\\\\\\\\')) {\n\t\t\t\tkey = '\\\\\\\\' + key.substr(2).replace(/\\\\/g, '/');\n\t\t\t} else {\n\t\t\t\tkey = key.replace(/\\\\/g, '/');\n\t\t\t}\n\n\t\t\tif (typeof value === 'boolean' && value) {\n\t\t\t\tif (strings.startsWith(key, '\\\\\\\\')) {\n\t\t\t\t\t// Absolute globs UNC paths don't work properly, see #58758\n\t\t\t\t\tkey += '**';\n\t\t\t\t}\n\n\t\t\t\tglobArgs.push(fixDriveC(key));\n\t\t\t} else if (value && value.when) {\n\t\t\t\tsiblingClauses[key] = value;\n\t\t\t}\n\t\t});\n\n\treturn { globArgs, siblingClauses };\n}\n\n/**\n * Resolves a glob like \"node_modules/**\" in \"/foo/bar\" to \"/foo/bar/node_modules/**\".\n * Special cases C:/foo paths to write the glob like /foo instead - see https://github.com/BurntSushi/ripgrep/issues/530.\n *\n * Exported for testing\n */\nexport function getAbsoluteGlob(folder: string, key: string): string {\n\treturn path.isAbsolute(key) ?\n\t\tkey :\n\t\tpath.join(folder, key);\n}\n\nfunction trimTrailingSlash(str: string): string {\n\tstr = strings.rtrim(str, '\\\\');\n\treturn strings.rtrim(str, '/');\n}\n\nexport function fixDriveC(path: string): string {\n\tconst root = extpath.getRoot(path);\n\treturn root.toLowerCase() === 'c:/' ?\n\t\tpath.replace(/^c:[/\\\\]/i, '/') :\n\t\tpath;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as childProcess from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'vs/base/common/path';\nimport { Readable } from 'stream';\nimport { NodeStringDecoder, StringDecoder } from 'string_decoder';\nimport * as arrays from 'vs/base/common/arrays';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport * as glob from 'vs/base/common/glob';\nimport * as normalization from 'vs/base/common/normalization';\nimport * as objects from 'vs/base/common/objects';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport * as platform from 'vs/base/common/platform';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport * as strings from 'vs/base/common/strings';\nimport * as types from 'vs/base/common/types';\nimport { URI } from 'vs/base/common/uri';\nimport * as extfs from 'vs/base/node/extfs';\nimport * as flow from 'vs/base/node/flow';\nimport { IFileQuery, IFolderQuery, IProgress, ISearchEngineStats, IRawFileMatch, ISearchEngine, ISearchEngineSuccess } from 'vs/workbench/services/search/common/search';\nimport { spawnRipgrepCmd } from './ripgrepFileSearch';\n\ninterface IDirectoryEntry {\n\tbase: string;\n\trelativePath: string;\n\tbasename: string;\n}\n\ninterface IDirectoryTree {\n\trootEntries: IDirectoryEntry[];\n\tpathToEntries: { [relativePath: string]: IDirectoryEntry[] };\n}\n\nconst killCmds = new Set<() => void>();\nprocess.on('exit', () => {\n\tkillCmds.forEach(cmd => cmd());\n});\n\nexport class FileWalker {\n\tprivate config: IFileQuery;\n\tprivate filePattern: string;\n\tprivate normalizedFilePatternLowercase: string;\n\tprivate includePattern: glob.ParsedExpression | undefined;\n\tprivate maxResults: number | null;\n\tprivate exists: boolean;\n\tprivate maxFilesize: number | null;\n\tprivate isLimitHit: boolean;\n\tprivate resultCount: number;\n\tprivate isCanceled: boolean;\n\tprivate fileWalkSW: StopWatch;\n\tprivate directoriesWalked: number;\n\tprivate filesWalked: number;\n\tprivate errors: string[];\n\tprivate cmdSW: StopWatch;\n\tprivate cmdResultCount: number;\n\n\tprivate folderExcludePatterns: Map<string, AbsoluteAndRelativeParsedExpression>;\n\tprivate globalExcludePattern: glob.ParsedExpression | undefined;\n\n\tprivate walkedPaths: { [path: string]: boolean; };\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.config = config;\n\t\tthis.filePattern = config.filePattern || '';\n\t\tthis.includePattern = config.includePattern && glob.parse(config.includePattern);\n\t\tthis.maxResults = config.maxResults || null;\n\t\tthis.exists = !!config.exists;\n\t\tthis.walkedPaths = Object.create(null);\n\t\tthis.resultCount = 0;\n\t\tthis.isLimitHit = false;\n\t\tthis.directoriesWalked = 0;\n\t\tthis.filesWalked = 0;\n\t\tthis.errors = [];\n\n\t\tif (this.filePattern) {\n\t\t\tthis.normalizedFilePatternLowercase = strings.stripWildcards(this.filePattern).toLowerCase();\n\t\t}\n\n\t\tthis.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n\t\tthis.folderExcludePatterns = new Map<string, AbsoluteAndRelativeParsedExpression>();\n\n\t\tconfig.folderQueries.forEach(folderQuery => {\n\t\t\tconst folderExcludeExpression: glob.IExpression = objects.assign({}, folderQuery.excludePattern || {}, this.config.excludePattern || {});\n\n\t\t\t// Add excludes for other root folders\n\t\t\tconst fqPath = folderQuery.folder.fsPath;\n\t\t\tconfig.folderQueries\n\t\t\t\t.map(rootFolderQuery => rootFolderQuery.folder.fsPath)\n\t\t\t\t.filter(rootFolder => rootFolder !== fqPath)\n\t\t\t\t.forEach(otherRootFolder => {\n\t\t\t\t\t// Exclude nested root folders\n\t\t\t\t\tif (isEqualOrParent(otherRootFolder, fqPath)) {\n\t\t\t\t\t\tfolderExcludeExpression[path.relative(fqPath, otherRootFolder)] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.folderExcludePatterns.set(fqPath, new AbsoluteAndRelativeParsedExpression(folderExcludeExpression, fqPath));\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.isCanceled = true;\n\t}\n\n\twalk(folderQueries: IFolderQuery[], extraFiles: URI[], onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgress) => void, done: (error: Error | null, isLimitHit: boolean) => void): void {\n\t\tthis.fileWalkSW = StopWatch.create(false);\n\n\t\t// Support that the file pattern is a full path to a file that exists\n\t\tif (this.isCanceled) {\n\t\t\treturn done(null, this.isLimitHit);\n\t\t}\n\n\t\t// For each extra file\n\t\textraFiles.forEach(extraFilePath => {\n\t\t\tconst basename = path.basename(extraFilePath.fsPath);\n\t\t\tif (this.globalExcludePattern && this.globalExcludePattern(extraFilePath.fsPath, basename)) {\n\t\t\t\treturn; // excluded\n\t\t\t}\n\n\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\tthis.matchFile(onResult, { relativePath: extraFilePath.fsPath /* no workspace relative path */, basename });\n\t\t});\n\n\t\tthis.cmdSW = StopWatch.create(false);\n\n\t\t// For each root folder\n\t\tflow.parallel<IFolderQuery, void>(folderQueries, (folderQuery: IFolderQuery, rootFolderDone: (err: Error | null, result: void) => void) => {\n\t\t\tthis.call(this.cmdTraversal, this, folderQuery, onResult, onMessage, (err?: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconst errorMessage = toErrorMessage(err);\n\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t\tthis.errors.push(errorMessage);\n\t\t\t\t\trootFolderDone(err, undefined);\n\t\t\t\t} else {\n\t\t\t\t\trootFolderDone(null, undefined);\n\t\t\t\t}\n\t\t\t});\n\t\t}, (errors, result) => {\n\t\t\tthis.fileWalkSW.stop();\n\t\t\tconst err = errors ? arrays.coalesce(errors)[0] : null;\n\t\t\tdone(err, this.isLimitHit);\n\t\t});\n\t}\n\n\tprivate call<F extends Function>(fun: F, that: any, ...args: any[]): void {\n\t\ttry {\n\t\t\tfun.apply(that, args);\n\t\t} catch (e) {\n\t\t\targs[args.length - 1](e);\n\t\t}\n\t}\n\n\tprivate cmdTraversal(folderQuery: IFolderQuery, onResult: (result: IRawFileMatch) => void, onMessage: (message: IProgress) => void, cb: (err?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder.fsPath;\n\t\tconst isMac = platform.isMacintosh;\n\t\tlet cmd: childProcess.ChildProcess;\n\t\tconst killCmd = () => cmd && cmd.kill();\n\t\tkillCmds.add(killCmd);\n\n\t\tlet done = (err?: Error) => {\n\t\t\tkillCmds.delete(killCmd);\n\t\t\tdone = () => { };\n\t\t\tcb(err);\n\t\t};\n\t\tlet leftover = '';\n\t\tconst tree = this.initDirectoryTree();\n\n\t\tlet noSiblingsClauses: boolean;\n\t\tconst ripgrep = spawnRipgrepCmd(this.config, folderQuery, this.config.includePattern, this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.expression);\n\t\tcmd = ripgrep.cmd;\n\t\tnoSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;\n\n\t\tconst escapedArgs = ripgrep.rgArgs.args\n\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t.join(' ');\n\n\t\tlet rgCmd = `rg ${escapedArgs}\\n - cwd: ${ripgrep.cwd}`;\n\t\tif (ripgrep.rgArgs.siblingClauses) {\n\t\t\trgCmd += `\\n - Sibling clauses: ${JSON.stringify(ripgrep.rgArgs.siblingClauses)}`;\n\t\t}\n\t\tonMessage({ message: rgCmd });\n\n\t\tthis.cmdResultCount = 0;\n\t\tthis.collectStdout(cmd, 'utf8', onMessage, (err: Error, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tdone(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isLimitHit) {\n\t\t\t\tdone();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\tconst normalized = leftover + (isMac ? normalization.normalizeNFC(stdout || '') : stdout);\n\t\t\tconst relativeFiles = normalized.split('\\n');\n\n\t\t\tif (last) {\n\t\t\t\tconst n = relativeFiles.length;\n\t\t\t\trelativeFiles[n - 1] = relativeFiles[n - 1].trim();\n\t\t\t\tif (!relativeFiles[n - 1]) {\n\t\t\t\t\trelativeFiles.pop();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tleftover = relativeFiles.pop() || '';\n\t\t\t}\n\n\t\t\tif (relativeFiles.length && relativeFiles[0].indexOf('\\n') !== -1) {\n\t\t\t\tdone(new Error('Splitting up files failed'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.cmdResultCount += relativeFiles.length;\n\n\t\t\tif (noSiblingsClauses) {\n\t\t\t\tfor (const relativePath of relativeFiles) {\n\t\t\t\t\tconst basename = path.basename(relativePath);\n\t\t\t\t\tthis.matchFile(onResult, { base: rootFolder, relativePath, basename });\n\t\t\t\t\tif (this.isLimitHit) {\n\t\t\t\t\t\tkillCmd();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (last || this.isLimitHit) {\n\t\t\t\t\tdone();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// TODO: Optimize siblings clauses with ripgrep here.\n\t\t\tthis.addDirectoryEntries(tree, rootFolder, relativeFiles, onResult);\n\n\t\t\tif (last) {\n\t\t\t\tthis.matchDirectoryTree(tree, rootFolder, onResult);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\tspawnFindCmd(folderQuery: IFolderQuery) {\n\t\tconst excludePattern = this.folderExcludePatterns.get(folderQuery.folder.fsPath)!;\n\t\tconst basenames = excludePattern.getBasenameTerms();\n\t\tconst pathTerms = excludePattern.getPathTerms();\n\t\tconst args = ['-L', '.'];\n\t\tif (basenames.length || pathTerms.length) {\n\t\t\targs.push('-not', '(', '(');\n\t\t\tfor (const basename of basenames) {\n\t\t\t\targs.push('-name', basename);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\tfor (const path of pathTerms) {\n\t\t\t\targs.push('-path', path);\n\t\t\t\targs.push('-o');\n\t\t\t}\n\t\t\targs.pop();\n\t\t\targs.push(')', '-prune', ')');\n\t\t}\n\t\targs.push('-type', 'f');\n\t\treturn childProcess.spawn('find', args, { cwd: folderQuery.folder.fsPath });\n\t}\n\n\t/**\n\t * Public for testing.\n\t */\n\treadStdout(cmd: childProcess.ChildProcess, encoding: string, cb: (err: Error | null, stdout?: string) => void): void {\n\t\tlet all = '';\n\t\tthis.collectStdout(cmd, encoding, () => { }, (err: Error, stdout?: string, last?: boolean) => {\n\t\t\tif (err) {\n\t\t\t\tcb(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tall += stdout;\n\t\t\tif (last) {\n\t\t\t\tcb(null, all);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate collectStdout(cmd: childProcess.ChildProcess, encoding: string, onMessage: (message: IProgress) => void, cb: (err: Error | null, stdout?: string, last?: boolean) => void): void {\n\t\tlet onData = (err: Error | null, stdout?: string, last?: boolean) => {\n\t\t\tif (err || last) {\n\t\t\t\tonData = () => { };\n\n\t\t\t\tif (this.cmdSW) {\n\t\t\t\t\tthis.cmdSW.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb(err, stdout, last);\n\t\t};\n\n\t\tlet gotData = false;\n\t\tif (cmd.stdout) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tthis.forwardData(cmd.stdout, encoding, onData);\n\t\t\tcmd.stdout.once('data', () => gotData = true);\n\t\t} else {\n\t\t\tonMessage({ message: 'stdout is null' });\n\t\t}\n\n\t\tlet stderr: Buffer[];\n\t\tif (cmd.stderr) {\n\t\t\t// Should be non-null, but #38195\n\t\t\tstderr = this.collectData(cmd.stderr);\n\t\t} else {\n\t\t\tonMessage({ message: 'stderr is null' });\n\t\t}\n\n\t\tcmd.on('error', (err: Error) => {\n\t\t\tonData(err);\n\t\t});\n\n\t\tcmd.on('close', (code: number) => {\n\t\t\t// ripgrep returns code=1 when no results are found\n\t\t\tlet stderrText: string;\n\t\t\tif (!gotData && (stderrText = this.decodeData(stderr, encoding)) && rgErrorMsgForDisplay(stderrText)) {\n\t\t\t\tonData(new Error(`command failed with error code ${code}: ${this.decodeData(stderr, encoding)}`));\n\t\t\t} else {\n\t\t\t\tif (this.exists && code === 0) {\n\t\t\t\t\tthis.isLimitHit = true;\n\t\t\t\t}\n\t\t\t\tonData(null, '', true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate forwardData(stream: Readable, encoding: string, cb: (err: Error | null, stdout?: string) => void): NodeStringDecoder {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tcb(null, decoder.write(data));\n\t\t});\n\t\treturn decoder;\n\t}\n\n\tprivate collectData(stream: Readable): Buffer[] {\n\t\tconst buffers: Buffer[] = [];\n\t\tstream.on('data', (data: Buffer) => {\n\t\t\tbuffers.push(data);\n\t\t});\n\t\treturn buffers;\n\t}\n\n\tprivate decodeData(buffers: Buffer[], encoding: string): string {\n\t\tconst decoder = new StringDecoder(encoding);\n\t\treturn buffers.map(buffer => decoder.write(buffer)).join('');\n\t}\n\n\tprivate initDirectoryTree(): IDirectoryTree {\n\t\tconst tree: IDirectoryTree = {\n\t\t\trootEntries: [],\n\t\t\tpathToEntries: Object.create(null)\n\t\t};\n\t\ttree.pathToEntries['.'] = tree.rootEntries;\n\t\treturn tree;\n\t}\n\n\tprivate addDirectoryEntries({ pathToEntries }: IDirectoryTree, base: string, relativeFiles: string[], onResult: (result: IRawFileMatch) => void) {\n\t\t// Support relative paths to files from a root resource (ignores excludes)\n\t\tif (relativeFiles.indexOf(this.filePattern) !== -1) {\n\t\t\tconst basename = path.basename(this.filePattern);\n\t\t\tthis.matchFile(onResult, { base: base, relativePath: this.filePattern, basename });\n\t\t}\n\n\t\tfunction add(relativePath: string) {\n\t\t\tconst basename = path.basename(relativePath);\n\t\t\tconst dirname = path.dirname(relativePath);\n\t\t\tlet entries = pathToEntries[dirname];\n\t\t\tif (!entries) {\n\t\t\t\tentries = pathToEntries[dirname] = [];\n\t\t\t\tadd(dirname);\n\t\t\t}\n\t\t\tentries.push({\n\t\t\t\tbase,\n\t\t\t\trelativePath,\n\t\t\t\tbasename\n\t\t\t});\n\t\t}\n\t\trelativeFiles.forEach(add);\n\t}\n\n\tprivate matchDirectoryTree({ rootEntries, pathToEntries }: IDirectoryTree, rootFolder: string, onResult: (result: IRawFileMatch) => void) {\n\t\tconst self = this;\n\t\tconst excludePattern = this.folderExcludePatterns.get(rootFolder)!;\n\t\tconst filePattern = this.filePattern;\n\t\tfunction matchDirectory(entries: IDirectoryEntry[]) {\n\t\t\tself.directoriesWalked++;\n\t\t\tconst hasSibling = glob.hasSiblingFn(() => entries.map(entry => entry.basename));\n\t\t\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\t\t\tconst entry = entries[i];\n\t\t\t\tconst { relativePath, basename } = entry;\n\n\t\t\t\t// Check exclude pattern\n\t\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t\t// to ignore filtering by siblings because the user seems to know what she\n\t\t\t\t// is searching for and we want to include the result in that case anyway\n\t\t\t\tif (excludePattern.test(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst sub = pathToEntries[relativePath];\n\t\t\t\tif (sub) {\n\t\t\t\t\tmatchDirectory(sub);\n\t\t\t\t} else {\n\t\t\t\t\tself.filesWalked++;\n\t\t\t\t\tif (relativePath === filePattern) {\n\t\t\t\t\t\tcontinue; // ignore file if its path matches with the file pattern because that is already matched above\n\t\t\t\t\t}\n\n\t\t\t\t\tself.matchFile(onResult, entry);\n\t\t\t\t}\n\n\t\t\t\tif (self.isLimitHit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchDirectory(rootEntries);\n\t}\n\n\tgetStats(): ISearchEngineStats {\n\t\treturn {\n\t\t\tcmdTime: this.cmdSW && this.cmdSW.elapsed(),\n\t\t\tfileWalkTime: this.fileWalkSW.elapsed(),\n\t\t\tdirectoriesWalked: this.directoriesWalked,\n\t\t\tfilesWalked: this.filesWalked,\n\t\t\tcmdResultCount: this.cmdResultCount\n\t\t};\n\t}\n\n\tprivate doWalk(folderQuery: IFolderQuery, relativeParentPath: string, files: string[], onResult: (result: IRawFileMatch) => void, done: (error?: Error) => void): void {\n\t\tconst rootFolder = folderQuery.folder;\n\n\t\t// Execute tasks on each file in parallel to optimize throughput\n\t\tconst hasSibling = glob.hasSiblingFn(() => files);\n\t\tflow.parallel(files, (file: string, clb: (error: Error | null, _?: any) => void): void => {\n\n\t\t\t// Check canceled\n\t\t\tif (this.isCanceled || this.isLimitHit) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Check exclude pattern\n\t\t\t// If the user searches for the exact file name, we adjust the glob matching\n\t\t\t// to ignore filtering by siblings because the user seems to know what she\n\t\t\t// is searching for and we want to include the result in that case anyway\n\t\t\tconst currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(path.sep) : file;\n\t\t\tif (this.folderExcludePatterns.get(folderQuery.folder.fsPath)!.test(currentRelativePath, file, this.config.filePattern !== file ? hasSibling : undefined)) {\n\t\t\t\treturn clb(null);\n\t\t\t}\n\n\t\t\t// Use lstat to detect links\n\t\t\tconst currentAbsolutePath = [rootFolder.fsPath, currentRelativePath].join(path.sep);\n\t\t\tfs.lstat(currentAbsolutePath, (error, lstat) => {\n\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\treturn clb(null);\n\t\t\t\t}\n\n\t\t\t\t// If the path is a link, we must instead use fs.stat() to find out if the\n\t\t\t\t// link is a directory or not because lstat will always return the stat of\n\t\t\t\t// the link which is always a file.\n\t\t\t\tthis.statLinkIfNeeded(currentAbsolutePath, lstat, (error, stat) => {\n\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Directory: Follow directories\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\tthis.directoriesWalked++;\n\n\t\t\t\t\t\t// to really prevent loops with links we need to resolve the real path of them\n\t\t\t\t\t\treturn this.realPathIfNeeded(currentAbsolutePath, lstat, (error, realpath) => {\n\t\t\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trealpath = realpath || '';\n\t\t\t\t\t\t\tif (this.walkedPaths[realpath]) {\n\t\t\t\t\t\t\t\treturn clb(null); // escape when there are cycles (can happen with symlinks)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.walkedPaths[realpath] = true; // remember as walked\n\n\t\t\t\t\t\t\t// Continue walking\n\t\t\t\t\t\t\treturn extfs.readdir(currentAbsolutePath, (error: Error, children: string[]): void => {\n\t\t\t\t\t\t\t\tif (error || this.isCanceled || this.isLimitHit) {\n\t\t\t\t\t\t\t\t\treturn clb(null);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.doWalk(folderQuery, currentRelativePath, children, onResult, err => clb(err || null));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// File: Check for match on file pattern and include pattern\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.filesWalked++;\n\t\t\t\t\t\tif (currentRelativePath === this.filePattern) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.maxFilesize && types.isNumber(stat.size) && stat.size > this.maxFilesize) {\n\t\t\t\t\t\t\treturn clb(null, undefined); // ignore file if max file size is hit\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.matchFile(onResult, { base: rootFolder.fsPath, relativePath: currentRelativePath, basename: file, size: stat.size });\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unwind\n\t\t\t\t\treturn clb(null, undefined);\n\t\t\t\t});\n\t\t\t});\n\t\t}, (error: Error[]): void => {\n\t\t\tif (error) {\n\t\t\t\terror = arrays.coalesce(error); // find any error by removing null values first\n\t\t\t}\n\n\t\t\treturn done(error && error.length > 0 ? error[0] : undefined);\n\t\t});\n\t}\n\n\tprivate matchFile(onResult: (result: IRawFileMatch) => void, candidate: IRawFileMatch): void {\n\t\tif (this.isFilePatternMatch(candidate.relativePath) && (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename))) {\n\t\t\tthis.resultCount++;\n\n\t\t\tif (this.exists || (this.maxResults && this.resultCount > this.maxResults)) {\n\t\t\t\tthis.isLimitHit = true;\n\t\t\t}\n\n\t\t\tif (!this.isLimitHit) {\n\t\t\t\tonResult(candidate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isFilePatternMatch(path: string): boolean {\n\n\t\t// Check for search pattern\n\t\tif (this.filePattern) {\n\t\t\tif (this.filePattern === '*') {\n\t\t\t\treturn true; // support the all-matching wildcard\n\t\t\t}\n\n\t\t\treturn strings.fuzzyContains(path, this.normalizedFilePatternLowercase);\n\t\t}\n\n\t\t// No patterns means we match all\n\t\treturn true;\n\t}\n\n\tprivate statLinkIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, stat: fs.Stats) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.stat(path, clb); // stat the target the link points to\n\t\t}\n\n\t\treturn clb(null, lstat); // not a link, so the stat is already ok for us\n\t}\n\n\tprivate realPathIfNeeded(path: string, lstat: fs.Stats, clb: (error: Error | null, realpath?: string) => void): void {\n\t\tif (lstat.isSymbolicLink()) {\n\t\t\treturn fs.realpath(path, (error, realpath) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn clb(error);\n\t\t\t\t}\n\n\t\t\t\treturn clb(null, realpath);\n\t\t\t});\n\t\t}\n\n\t\treturn clb(null, path);\n\t}\n}\n\nexport class Engine implements ISearchEngine<IRawFileMatch> {\n\tprivate folderQueries: IFolderQuery[];\n\tprivate extraFiles: URI[];\n\tprivate walker: FileWalker;\n\n\tconstructor(config: IFileQuery) {\n\t\tthis.folderQueries = config.folderQueries;\n\t\tthis.extraFiles = config.extraFileResources || [];\n\n\t\tthis.walker = new FileWalker(config);\n\t}\n\n\tsearch(onResult: (result: IRawFileMatch) => void, onProgress: (progress: IProgress) => void, done: (error: Error, complete: ISearchEngineSuccess) => void): void {\n\t\tthis.walker.walk(this.folderQueries, this.extraFiles, onResult, onProgress, (err: Error, isLimitHit: boolean) => {\n\t\t\tdone(err, {\n\t\t\t\tlimitHit: isLimitHit,\n\t\t\t\tstats: this.walker.getStats()\n\t\t\t});\n\t\t});\n\t}\n\n\tcancel(): void {\n\t\tthis.walker.cancel();\n\t}\n}\n\n/**\n * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.\n * The absolute and relative expressions don't \"have\" to be kept separate, but this keeps us from having to path.join every single\n * file searched, it's only used for a text search with a searchPath\n */\nclass AbsoluteAndRelativeParsedExpression {\n\tprivate absoluteParsedExpr: glob.ParsedExpression | undefined;\n\tprivate relativeParsedExpr: glob.ParsedExpression | undefined;\n\n\tconstructor(public expression: glob.IExpression, private root: string) {\n\t\tthis.init(expression);\n\t}\n\n\t/**\n\t * Split the IExpression into its absolute and relative components, and glob.parse them separately.\n\t */\n\tprivate init(expr: glob.IExpression): void {\n\t\tlet absoluteGlobExpr: glob.IExpression | undefined;\n\t\tlet relativeGlobExpr: glob.IExpression | undefined;\n\t\tObject.keys(expr)\n\t\t\t.filter(key => expr[key])\n\t\t\t.forEach(key => {\n\t\t\t\tif (path.isAbsolute(key)) {\n\t\t\t\t\tabsoluteGlobExpr = absoluteGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\tabsoluteGlobExpr[key] = expr[key];\n\t\t\t\t} else {\n\t\t\t\t\trelativeGlobExpr = relativeGlobExpr || glob.getEmptyExpression();\n\t\t\t\t\trelativeGlobExpr[key] = expr[key];\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.absoluteParsedExpr = absoluteGlobExpr && glob.parse(absoluteGlobExpr, { trimForExclusions: true });\n\t\tthis.relativeParsedExpr = relativeGlobExpr && glob.parse(relativeGlobExpr, { trimForExclusions: true });\n\t}\n\n\ttest(_path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | Promise<string | null> | undefined | null {\n\t\treturn (this.relativeParsedExpr && this.relativeParsedExpr(_path, basename, hasSibling)) ||\n\t\t\t(this.absoluteParsedExpr && this.absoluteParsedExpr(path.join(this.root, _path), basename, hasSibling));\n\t}\n\n\tgetBasenameTerms(): string[] {\n\t\tconst basenameTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tbasenameTerms.push(...glob.getBasenameTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn basenameTerms;\n\t}\n\n\tgetPathTerms(): string[] {\n\t\tconst pathTerms: string[] = [];\n\t\tif (this.absoluteParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.absoluteParsedExpr));\n\t\t}\n\n\t\tif (this.relativeParsedExpr) {\n\t\t\tpathTerms.push(...glob.getPathTerms(this.relativeParsedExpr));\n\t\t}\n\n\t\treturn pathTerms;\n\t}\n}\n\nexport function rgErrorMsgForDisplay(msg: string): string | undefined {\n\tconst lines = msg.trim().split('\\n');\n\tconst firstLine = lines[0].trim();\n\n\tif (strings.startsWith(firstLine, 'Error parsing regex')) {\n\t\treturn firstLine;\n\t}\n\n\tif (strings.startsWith(firstLine, 'regex parse error')) {\n\t\treturn strings.uppercaseFirstLetter(lines[lines.length - 1].trim());\n\t}\n\n\tif (strings.startsWith(firstLine, 'error parsing glob') ||\n\t\tstrings.startsWith(firstLine, 'unsupported encoding')) {\n\t\t// Uppercase first letter\n\t\treturn firstLine.charAt(0).toUpperCase() + firstLine.substr(1);\n\t}\n\n\tif (firstLine === `Literal '\\\\n' not allowed.`) {\n\t\t// I won't localize this because none of the Ripgrep error messages are localized\n\t\treturn `Literal '\\\\n' currently not supported`;\n\t}\n\n\tif (strings.startsWith(firstLine, 'Literal ')) {\n\t\t// Other unsupported chars\n\t\treturn firstLine;\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { EventEmitter } from 'events';\nimport * as path from 'vs/base/common/path';\nimport { NodeStringDecoder, StringDecoder } from 'string_decoder';\nimport { createRegExp, startsWith, startsWithUTF8BOM, stripUTF8BOM, escapeRegExpCharacters, endsWith } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\nimport { IExtendedExtensionSearchOptions, SearchError, SearchErrorCode, serializeSearchError } from 'vs/workbench/services/search/common/search';\nimport * as vscode from 'vscode';\nimport { rgPath } from 'vscode-ripgrep';\nimport { anchorGlob, createTextSearchResult, IOutputChannel, Maybe, Range } from './ripgrepSearchUtils';\nimport { coalesce } from 'vs/base/common/arrays';\nimport { splitGlobAware } from 'vs/base/common/glob';\nimport { groupBy } from 'vs/base/common/collections';\n\n// If vscode-ripgrep is in an .asar file, then the binary is unpacked.\nconst rgDiskPath = rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n\nexport class RipgrepTextSearchEngine {\n\n\tconstructor(private outputChannel: IOutputChannel) { }\n\n\tprovideTextSearchResults(query: vscode.TextSearchQuery, options: vscode.TextSearchOptions, progress: vscode.Progress<vscode.TextSearchResult>, token: vscode.CancellationToken): Promise<vscode.TextSearchComplete> {\n\t\tthis.outputChannel.appendLine(`provideTextSearchResults ${query.pattern}, ${JSON.stringify({\n\t\t\t...options,\n\t\t\t...{\n\t\t\t\tfolder: options.folder.toString()\n\t\t\t}\n\t\t})}`);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttoken.onCancellationRequested(() => cancel());\n\n\t\t\tconst rgArgs = getRgArgs(query, options);\n\n\t\t\tconst cwd = options.folder.fsPath;\n\n\t\t\tconst escapedArgs = rgArgs\n\t\t\t\t.map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n\t\t\t\t.join(' ');\n\t\t\tthis.outputChannel.appendLine(`rg ${escapedArgs}\\n - cwd: ${cwd}`);\n\n\t\t\tlet rgProc: Maybe<cp.ChildProcess> = cp.spawn(rgDiskPath, rgArgs, { cwd });\n\t\t\trgProc.on('error', e => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tthis.outputChannel.appendLine('Error: ' + (e && e.message));\n\t\t\t\treject(serializeSearchError(new SearchError(e && e.message, SearchErrorCode.rgProcessError)));\n\t\t\t});\n\n\t\t\tlet gotResult = false;\n\t\t\tconst ripgrepParser = new RipgrepParser(options.maxResults, cwd, options.previewOptions);\n\t\t\tripgrepParser.on('result', (match: vscode.TextSearchResult) => {\n\t\t\t\tgotResult = true;\n\t\t\t\tprogress.report(match);\n\t\t\t});\n\n\t\t\tlet isDone = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tisDone = true;\n\n\t\t\t\tif (rgProc) {\n\t\t\t\t\trgProc.kill();\n\t\t\t\t}\n\n\t\t\t\tif (ripgrepParser) {\n\t\t\t\t\tripgrepParser.cancel();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlet limitHit = false;\n\t\t\tripgrepParser.on('hitLimit', () => {\n\t\t\t\tlimitHit = true;\n\t\t\t\tcancel();\n\t\t\t});\n\n\t\t\trgProc.stdout.on('data', data => {\n\t\t\t\tripgrepParser.handleData(data);\n\t\t\t});\n\n\t\t\tlet gotData = false;\n\t\t\trgProc.stdout.once('data', () => gotData = true);\n\n\t\t\tlet stderr = '';\n\t\t\trgProc.stderr.on('data', data => {\n\t\t\t\tconst message = data.toString();\n\t\t\t\tthis.outputChannel.appendLine(message);\n\t\t\t\tstderr += message;\n\t\t\t});\n\n\t\t\trgProc.on('close', () => {\n\t\t\t\tthis.outputChannel.appendLine(gotData ? 'Got data from stdout' : 'No data from stdout');\n\t\t\t\tthis.outputChannel.appendLine(gotResult ? 'Got result from parser' : 'No result from parser');\n\t\t\t\tthis.outputChannel.appendLine('');\n\t\t\t\tif (isDone) {\n\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t} else {\n\t\t\t\t\t// Trigger last result\n\t\t\t\t\tripgrepParser.flush();\n\t\t\t\t\trgProc = null;\n\t\t\t\t\tlet searchError: Maybe<SearchError>;\n\t\t\t\t\tif (stderr && !gotData && (searchError = rgErrorMsgForDisplay(stderr))) {\n\t\t\t\t\t\treject(serializeSearchError(new SearchError(searchError.message, searchError.code)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ limitHit });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * Read the first line of stderr and return an error for display or undefined, based on a whitelist.\n * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be\n * \"failed\" when a fatal error was produced.\n */\nexport function rgErrorMsgForDisplay(msg: string): Maybe<SearchError> {\n\tconst firstLine = msg.split('\\n')[0].trim();\n\n\tif (startsWith(firstLine, 'regex parse error')) {\n\t\treturn new SearchError('Regex parse error', SearchErrorCode.regexParseError);\n\t}\n\n\tconst match = firstLine.match(/grep config error: unknown encoding: (.*)/);\n\tif (match) {\n\t\treturn new SearchError(`Unknown encoding: ${match[1]}`, SearchErrorCode.unknownEncoding);\n\t}\n\n\tif (startsWith(firstLine, 'error parsing glob')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.globParseError);\n\t}\n\n\tif (startsWith(firstLine, 'the literal')) {\n\t\t// Uppercase first letter\n\t\treturn new SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), SearchErrorCode.invalidLiteral);\n\t}\n\n\treturn undefined;\n}\n\nexport class RipgrepParser extends EventEmitter {\n\tprivate remainder = '';\n\tprivate isDone = false;\n\tprivate hitLimit = false;\n\tprivate stringDecoder: NodeStringDecoder;\n\n\tprivate numResults = 0;\n\n\tconstructor(private maxResults: number, private rootFolder: string, private previewOptions?: vscode.TextSearchPreviewOptions) {\n\t\tsuper();\n\t\tthis.stringDecoder = new StringDecoder();\n\t}\n\n\tcancel(): void {\n\t\tthis.isDone = true;\n\t}\n\n\tflush(): void {\n\t\tthis.handleDecodedData(this.stringDecoder.end());\n\t}\n\n\n\ton(event: 'result', listener: (result: vscode.TextSearchResult) => void);\n\ton(event: 'hitLimit', listener: () => void);\n\ton(event: string, listener: (...args: any[]) => void) {\n\t\tsuper.on(event, listener);\n\t}\n\n\thandleData(data: Buffer | string): void {\n\t\tif (this.isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst dataStr = typeof data === 'string' ? data : this.stringDecoder.write(data);\n\t\tthis.handleDecodedData(dataStr);\n\t}\n\n\tprivate handleDecodedData(decodedData: string): void {\n\t\t// check for newline before appending to remainder\n\t\tlet newlineIdx = decodedData.indexOf('\\n');\n\n\t\t// If the previous data chunk didn't end in a newline, prepend it to this chunk\n\t\tconst dataStr = this.remainder + decodedData;\n\n\t\tif (newlineIdx >= 0) {\n\t\t\tnewlineIdx += this.remainder.length;\n\t\t} else {\n\t\t\t// Shortcut\n\t\t\tthis.remainder = dataStr;\n\t\t\treturn;\n\t\t}\n\n\t\tlet prevIdx = 0;\n\t\twhile (newlineIdx >= 0) {\n\t\t\tthis.handleLine(dataStr.substring(prevIdx, newlineIdx).trim());\n\t\t\tprevIdx = newlineIdx + 1;\n\t\t\tnewlineIdx = dataStr.indexOf('\\n', prevIdx);\n\t\t}\n\n\t\tthis.remainder = dataStr.substring(prevIdx).trim();\n\t}\n\n\tprivate handleLine(outputLine: string): void {\n\t\tif (this.isDone || !outputLine) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet parsedLine: IRgMessage;\n\t\ttry {\n\t\t\tparsedLine = JSON.parse(outputLine);\n\t\t} catch (e) {\n\t\t\tthrow new Error(`malformed line from rg: ${outputLine}`);\n\t\t}\n\n\t\tif (parsedLine.type === 'match') {\n\t\t\tconst matchPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.file(path.join(this.rootFolder, matchPath));\n\t\t\tconst result = this.createTextSearchMatch(parsedLine.data, uri);\n\t\t\tthis.onResult(result);\n\n\t\t\tif (this.hitLimit) {\n\t\t\t\tthis.cancel();\n\t\t\t\tthis.emit('hitLimit');\n\t\t\t}\n\t\t} else if (parsedLine.type === 'context') {\n\t\t\tconst contextPath = bytesOrTextToString(parsedLine.data.path);\n\t\t\tconst uri = URI.file(path.join(this.rootFolder, contextPath));\n\t\t\tconst result = this.createTextSearchContext(parsedLine.data, uri);\n\t\t\tresult.forEach(r => this.onResult(r));\n\t\t}\n\t}\n\n\tprivate createTextSearchMatch(data: IRgMatch, uri: vscode.Uri): vscode.TextSearchMatch {\n\t\tconst lineNumber = data.line_number - 1;\n\t\tlet isBOMStripped = false;\n\t\tlet fullText = bytesOrTextToString(data.lines);\n\t\tif (lineNumber === 0 && startsWithUTF8BOM(fullText)) {\n\t\t\tisBOMStripped = true;\n\t\t\tfullText = stripUTF8BOM(fullText);\n\t\t}\n\t\tconst fullTextBytes = Buffer.from(fullText);\n\n\t\tlet prevMatchEnd = 0;\n\t\tlet prevMatchEndCol = 0;\n\t\tlet prevMatchEndLine = lineNumber;\n\t\tconst ranges = coalesce(data.submatches.map((match, i) => {\n\t\t\tif (this.hitLimit) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis.numResults++;\n\t\t\tif (this.numResults >= this.maxResults) {\n\t\t\t\t// Finish the line, then report the result below\n\t\t\t\tthis.hitLimit = true;\n\t\t\t}\n\n\t\t\tlet matchText = bytesOrTextToString(match.match);\n\t\t\tif (lineNumber === 0 && i === 0 && isBOMStripped) {\n\t\t\t\tmatchText = stripUTF8BOM(matchText);\n\t\t\t\tmatch.start = match.start <= 3 ? 0 : match.start - 3;\n\t\t\t\tmatch.end = match.end <= 3 ? 0 : match.end - 3;\n\t\t\t}\n\t\t\tconst inBetweenChars = fullTextBytes.slice(prevMatchEnd, match.start).toString().length;\n\t\t\tlet startCol = prevMatchEndCol + inBetweenChars;\n\n\t\t\tconst stats = getNumLinesAndLastNewlineLength(matchText);\n\t\t\tconst startLineNumber = prevMatchEndLine;\n\t\t\tconst endLineNumber = stats.numLines + startLineNumber;\n\t\t\tlet endCol = stats.numLines > 0 ?\n\t\t\t\tstats.lastLineLength :\n\t\t\t\tstats.lastLineLength + startCol;\n\n\t\t\tprevMatchEnd = match.end;\n\t\t\tprevMatchEndCol = endCol;\n\t\t\tprevMatchEndLine = endLineNumber;\n\n\t\t\treturn new Range(startLineNumber, startCol, endLineNumber, endCol);\n\t\t}));\n\n\t\treturn createTextSearchResult(uri, fullText, <Range[]>ranges, this.previewOptions);\n\t}\n\n\tprivate createTextSearchContext(data: IRgMatch, uri: URI): vscode.TextSearchContext[] {\n\t\tconst text = bytesOrTextToString(data.lines);\n\t\tconst startLine = data.line_number;\n\t\treturn text\n\t\t\t.replace(/\\r?\\n$/, '')\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => {\n\t\t\t\treturn {\n\t\t\t\t\ttext: line,\n\t\t\t\t\turi,\n\t\t\t\t\tlineNumber: startLine + i\n\t\t\t\t};\n\t\t\t});\n\t}\n\n\tprivate onResult(match: vscode.TextSearchResult): void {\n\t\tthis.emit('result', match);\n\t}\n}\n\nfunction bytesOrTextToString(obj: any): string {\n\treturn obj.bytes ?\n\t\tBuffer.from(obj.bytes, 'base64').toString() :\n\t\tobj.text;\n}\n\nfunction getNumLinesAndLastNewlineLength(text: string): { numLines: number, lastLineLength: number } {\n\tconst re = /\\n/g;\n\tlet numLines = 0;\n\tlet lastNewlineIdx = -1;\n\tlet match: ReturnType<typeof re.exec>;\n\twhile (match = re.exec(text)) {\n\t\tnumLines++;\n\t\tlastNewlineIdx = match.index;\n\t}\n\n\tconst lastLineLength = lastNewlineIdx >= 0 ?\n\t\ttext.length - lastNewlineIdx - 1 :\n\t\ttext.length;\n\n\treturn { numLines, lastLineLength };\n}\n\nfunction getRgArgs(query: vscode.TextSearchQuery, options: vscode.TextSearchOptions): string[] {\n\tconst args = ['--hidden'];\n\targs.push(query.isCaseSensitive ? '--case-sensitive' : '--ignore-case');\n\n\tconst { doubleStarIncludes, otherIncludes } = groupBy(\n\t\toptions.includes,\n\t\t(include: string) => startsWith(include, '**') ? 'doubleStarIncludes' : 'otherIncludes');\n\n\tif (otherIncludes && otherIncludes.length) {\n\t\tconst uniqueOthers = new Set<string>();\n\t\totherIncludes.forEach(other => {\n\t\t\tif (!endsWith(other, '/**')) {\n\t\t\t\tother += '/**';\n\t\t\t}\n\n\t\t\tuniqueOthers.add(other);\n\t\t});\n\n\t\targs.push('-g', '!*');\n\t\tuniqueOthers\n\t\t\t.forEach(otherIncude => {\n\t\t\t\tspreadGlobComponents(otherIncude)\n\t\t\t\t\t.map(anchorGlob)\n\t\t\t\t\t.forEach(globArg => {\n\t\t\t\t\t\targs.push('-g', globArg);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\tif (doubleStarIncludes && doubleStarIncludes.length) {\n\t\tdoubleStarIncludes.forEach(globArg => {\n\t\t\targs.push('-g', globArg);\n\t\t});\n\t}\n\n\toptions.excludes\n\t\t.map(anchorGlob)\n\t\t.forEach(rgGlob => args.push('-g', `!${rgGlob}`));\n\n\tif (options.maxFileSize) {\n\t\targs.push('--max-filesize', options.maxFileSize + '');\n\t}\n\n\tif (options.useIgnoreFiles) {\n\t\targs.push('--no-ignore-parent');\n\t} else {\n\t\t// Don't use .gitignore or .ignore\n\t\targs.push('--no-ignore');\n\t}\n\n\tif (options.followSymlinks) {\n\t\targs.push('--follow');\n\t}\n\n\tif (options.encoding && options.encoding !== 'utf8') {\n\t\targs.push('--encoding', options.encoding);\n\t}\n\n\tlet pattern = query.pattern;\n\n\t// Ripgrep handles -- as a -- arg separator. Only --.\n\t// - is ok, --- is ok, --some-flag is also ok. Need to special case.\n\tif (pattern === '--') {\n\t\tquery.isRegExp = true;\n\t\tpattern = '\\\\-\\\\-';\n\t}\n\n\tif (query.isMultiline && !query.isRegExp) {\n\t\tquery.pattern = escapeRegExpCharacters(query.pattern);\n\t\tquery.isRegExp = true;\n\t}\n\n\tif ((<IExtendedExtensionSearchOptions>options).usePCRE2) {\n\t\targs.push('--pcre2');\n\n\t\tif (query.isRegExp) {\n\t\t\tpattern = unicodeEscapesToPCRE2(pattern);\n\t\t}\n\t}\n\n\tlet searchPatternAfterDoubleDashes: Maybe<string>;\n\tif (query.isWordMatch) {\n\t\tconst regexp = createRegExp(pattern, !!query.isRegExp, { wholeWord: query.isWordMatch });\n\t\tconst regexpStr = regexp.source.replace(/\\\\\\//g, '/'); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.\n\t\targs.push('--regexp', regexpStr);\n\t} else if (query.isRegExp) {\n\t\tlet fixedRegexpQuery = fixRegexEndingPattern(query.pattern);\n\t\tfixedRegexpQuery = fixRegexNewline(fixedRegexpQuery);\n\t\tfixedRegexpQuery = fixNewline(fixedRegexpQuery);\n\t\tfixedRegexpQuery = fixRegexCRMatchingNonWordClass(fixedRegexpQuery, !!query.isMultiline);\n\t\tfixedRegexpQuery = fixRegexCRMatchingWhitespaceClass(fixedRegexpQuery, !!query.isMultiline);\n\t\targs.push('--regexp', fixedRegexpQuery);\n\t} else {\n\t\tsearchPatternAfterDoubleDashes = pattern;\n\t\targs.push('--fixed-strings');\n\t}\n\n\targs.push('--no-config');\n\tif (!options.useGlobalIgnoreFiles) {\n\t\targs.push('--no-ignore-global');\n\t}\n\n\targs.push('--json');\n\n\tif (query.isMultiline) {\n\t\targs.push('--multiline');\n\t}\n\n\tif (options.beforeContext) {\n\t\targs.push('--before-context', options.beforeContext + '');\n\t}\n\n\tif (options.afterContext) {\n\t\targs.push('--after-context', options.afterContext + '');\n\t}\n\n\t// Folder to search\n\targs.push('--');\n\n\tif (searchPatternAfterDoubleDashes) {\n\t\t// Put the query after --, in case the query starts with a dash\n\t\targs.push(searchPatternAfterDoubleDashes);\n\t}\n\n\targs.push('.');\n\n\treturn args;\n}\n\n/**\n * `\"foo/*bar/something\"` -> `[\"foo\", \"foo/*bar\", \"foo/*bar/something\", \"foo/*bar/something/**\"]`\n */\nexport function spreadGlobComponents(globArg: string): string[] {\n\tconst components = splitGlobAware(globArg, '/');\n\tif (components[components.length - 1] !== '**') {\n\t\tcomponents.push('**');\n\t}\n\n\treturn components.map((_, i) => components.slice(0, i + 1).join('/'));\n}\n\nexport function unicodeEscapesToPCRE2(pattern: string): string {\n\tconst reg = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u([a-z0-9]{4})(?!\\d)/g;\n\t// Replace an unescaped $ at the end of the pattern with \\r?$\n\t// Match $ preceeded by none or even number of literal \\\n\twhile (pattern.match(reg)) {\n\t\tpattern = pattern.replace(reg, `$1\\\\x{$2}`);\n\t}\n\n\treturn pattern;\n}\n\nexport interface IRgMessage {\n\ttype: 'match' | 'context' | string;\n\tdata: IRgMatch;\n}\n\nexport interface IRgMatch {\n\tpath: IRgBytesOrText;\n\tlines: IRgBytesOrText;\n\tline_number: number;\n\tabsolute_offset: number;\n\tsubmatches: IRgSubmatch[];\n}\n\nexport interface IRgSubmatch {\n\tmatch: IRgBytesOrText;\n\tstart: number;\n\tend: number;\n}\n\nexport type IRgBytesOrText = { bytes: string } | { text: string };\n\nexport function fixRegexEndingPattern(pattern: string): string {\n\t// Replace an unescaped $ at the end of the pattern with \\r?$\n\t// Match $ preceeded by none or even number of literal \\\n\treturn pattern.match(/([^\\\\]|^)(\\\\\\\\)*\\$$/) ?\n\t\tpattern.replace(/\\$$/, '\\\\r?$') :\n\t\tpattern;\n}\n\nexport function fixRegexNewline(pattern: string): string {\n\t// Replace an unescaped $ at the end of the pattern with \\r?$\n\t// Match $ preceeded by none or even number of literal \\\n\treturn pattern.replace(/([^\\\\]|^)(\\\\\\\\)*\\\\n/g, '$1$2\\\\r?\\\\n');\n}\n\nexport function fixRegexCRMatchingWhitespaceClass(pattern: string, isMultiline: boolean): string {\n\treturn isMultiline ?\n\t\tpattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\s/g, '$1$2(\\\\r?\\\\n|[^\\\\S\\\\r])') :\n\t\tpattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\s/g, '$1$2[ \\\\t\\\\f]');\n}\n\nexport function fixRegexCRMatchingNonWordClass(pattern: string, isMultiline: boolean): string {\n\treturn isMultiline ?\n\t\tpattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\W/g, '$1$2(\\\\r?\\\\n|[^\\\\w\\\\r])') :\n\t\tpattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\W/g, '$1$2[^\\\\w\\\\r]');\n}\n\nexport function fixNewline(pattern: string): string {\n\treturn pattern.replace(/\\n/g, '\\\\r?\\\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as extfs from 'vs/base/node/extfs';\nimport { IFileMatch, IProgress, ITextQuery, ITextSearchStats, ITextSearchMatch, ISerializedFileMatch, ISerializedSearchSuccess } from 'vs/workbench/services/search/common/search';\nimport { RipgrepTextSearchEngine } from 'vs/workbench/services/search/node/ripgrepTextSearchEngine';\nimport { TextSearchManager } from 'vs/workbench/services/search/node/textSearchManager';\n\nexport class TextSearchEngineAdapter {\n\n\tconstructor(private query: ITextQuery) {\n\t}\n\n\tsearch(token: CancellationToken, onResult: (matches: ISerializedFileMatch[]) => void, onMessage: (message: IProgress) => void): Promise<ISerializedSearchSuccess> {\n\t\tif ((!this.query.folderQueries || !this.query.folderQueries.length) && (!this.query.extraFileResources || !this.query.extraFileResources.length)) {\n\t\t\treturn Promise.resolve(<ISerializedSearchSuccess>{\n\t\t\t\ttype: 'success',\n\t\t\t\tlimitHit: false,\n\t\t\t\tstats: <ITextSearchStats>{\n\t\t\t\t\ttype: 'searchProcess'\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst pretendOutputChannel = {\n\t\t\tappendLine(msg) {\n\t\t\t\tonMessage({ message: msg });\n\t\t\t}\n\t\t};\n\t\tconst textSearchManager = new TextSearchManager(this.query, new RipgrepTextSearchEngine(pretendOutputChannel), extfs);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treturn textSearchManager\n\t\t\t\t.search(\n\t\t\t\t\tmatches => {\n\t\t\t\t\t\tonResult(matches.map(fileMatchToSerialized));\n\t\t\t\t\t},\n\t\t\t\t\ttoken)\n\t\t\t\t.then(\n\t\t\t\t\tc => resolve({ limitHit: c.limitHit, stats: null, type: 'success' } as ISerializedSearchSuccess),\n\t\t\t\t\treject);\n\t\t});\n\t}\n}\n\nfunction fileMatchToSerialized(match: IFileMatch): ISerializedFileMatch {\n\treturn {\n\t\tpath: match.resource ? match.resource.fsPath : undefined,\n\t\tresults: match.results,\n\t\tnumMatches: (match.results || []).reduce((sum, r) => {\n\t\t\tif (!!(<ITextSearchMatch>r).ranges) {\n\t\t\t\tconst m = <ITextSearchMatch>r;\n\t\t\t\treturn sum + (Array.isArray(m.ranges) ? m.ranges.length : 1);\n\t\t\t} else {\n\t\t\t\treturn sum + 1;\n\t\t\t}\n\t\t}, 0)\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// import * as fs from 'fs';\n// import * as gracefulFs from 'graceful-fs';\nimport { join, sep } from 'vs/base/common/path';\nimport * as arrays from 'vs/base/common/arrays';\nimport { CancelablePromise, createCancelablePromise } from 'vs/base/common/async';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { canceled } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport * as objects from 'vs/base/common/objects';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport * as strings from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { compareItemsByScore, IItemAccessor, prepareQuery, ScorerCache } from 'vs/base/parts/quickopen/common/quickOpenScorer';\nimport { MAX_FILE_SIZE } from 'vs/platform/files/node/files';\nimport { ICachedSearchStats, IFileQuery, IFileSearchStats, IFolderQuery, IProgress, IRawFileQuery, IRawQuery, IRawTextQuery, ITextQuery, IFileSearchProgressItem, IRawFileMatch, IRawSearchService, ISearchEngine, ISearchEngineSuccess, ISerializedFileMatch, ISerializedSearchComplete, ISerializedSearchProgressItem, ISerializedSearchSuccess } from 'vs/workbench/services/search/common/search';\nimport { Engine as FileSearchEngine } from 'vs/workbench/services/search/node/fileSearch';\nimport { TextSearchEngineAdapter } from 'vs/workbench/services/search/node/textSearchAdapter';\n\n// gracefulFs.gracefulify(fs);\n\ntype IProgressCallback = (p: ISerializedSearchProgressItem) => void;\ntype IFileProgressCallback = (p: IFileSearchProgressItem) => void;\n\nexport class SearchService implements IRawSearchService {\n\n\tprivate static readonly BATCH_SIZE = 512;\n\n\tprivate caches: { [cacheKey: string]: Cache; } = Object.create(null);\n\n\tfileSearch(config: IRawFileQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchSuccess>;\n\n\t\tconst query = reviveQuery(config);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonFirstListenerDidAdd: () => {\n\t\t\t\tpromise = createCancelablePromise(token => {\n\t\t\t\t\treturn this.doFileSearchWithEngine(FileSearchEngine, query, p => emitter.fire(p), token);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\ttextSearch(rawQuery: IRawTextQuery): Event<ISerializedSearchProgressItem | ISerializedSearchComplete> {\n\t\tlet promise: CancelablePromise<ISerializedSearchComplete>;\n\n\t\tconst query = reviveQuery(rawQuery);\n\t\tconst emitter = new Emitter<ISerializedSearchProgressItem | ISerializedSearchComplete>({\n\t\t\tonFirstListenerDidAdd: () => {\n\t\t\t\tpromise = createCancelablePromise(token => {\n\t\t\t\t\treturn this.ripgrepTextSearch(query, p => emitter.fire(p), token);\n\t\t\t\t});\n\n\t\t\t\tpromise.then(\n\t\t\t\t\tc => emitter.fire(c),\n\t\t\t\t\terr => emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }));\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate ripgrepTextSearch(config: ITextQuery, progressCallback: IProgressCallback, token: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\tconfig.maxFileSize = MAX_FILE_SIZE;\n\t\tconst engine = new TextSearchEngineAdapter(config);\n\n\t\treturn engine.search(token, progressCallback, progressCallback);\n\t}\n\n\tdoFileSearch(config: IFileQuery, progressCallback: IProgressCallback, token?: CancellationToken): Promise<ISerializedSearchSuccess> {\n\t\treturn this.doFileSearchWithEngine(FileSearchEngine, config, progressCallback, token);\n\t}\n\n\tdoFileSearchWithEngine(EngineClass: { new(config: IFileQuery): ISearchEngine<IRawFileMatch>; }, config: IFileQuery, progressCallback: IProgressCallback, token?: CancellationToken, batchSize = SearchService.BATCH_SIZE): Promise<ISerializedSearchSuccess> {\n\t\tlet resultCount = 0;\n\t\tconst fileProgressCallback: IFileProgressCallback = progress => {\n\t\t\tif (Array.isArray(progress)) {\n\t\t\t\tresultCount += progress.length;\n\t\t\t\tprogressCallback(progress.map(m => this.rawMatchToSearchItem(m)));\n\t\t\t} else if ((<IRawFileMatch>progress).relativePath) {\n\t\t\t\tresultCount++;\n\t\t\t\tprogressCallback(this.rawMatchToSearchItem(<IRawFileMatch>progress));\n\t\t\t} else {\n\t\t\t\tprogressCallback(<IProgress>progress);\n\t\t\t}\n\t\t};\n\n\t\tif (config.sortByScore) {\n\t\t\tlet sortedSearch = this.trySortedSearchFromCache(config, fileProgressCallback, token);\n\t\t\tif (!sortedSearch) {\n\t\t\t\tconst walkerConfig = config.maxResults ? objects.assign({}, config, { maxResults: null }) : config;\n\t\t\t\tconst engine = new EngineClass(walkerConfig);\n\t\t\t\tsortedSearch = this.doSortedSearch(engine, config, progressCallback, fileProgressCallback, token);\n\t\t\t}\n\n\t\t\treturn new Promise<ISerializedSearchSuccess>((c, e) => {\n\t\t\t\tsortedSearch!.then(([result, rawMatches]) => {\n\t\t\t\t\tconst serializedMatches = rawMatches.map(rawMatch => this.rawMatchToSearchItem(rawMatch));\n\t\t\t\t\tthis.sendProgress(serializedMatches, progressCallback, batchSize);\n\t\t\t\t\tc(result);\n\t\t\t\t}, e);\n\t\t\t});\n\t\t}\n\n\t\tconst engine = new EngineClass(config);\n\n\t\treturn this.doSearch(engine, fileProgressCallback, batchSize, token).then(complete => {\n\t\t\treturn <ISerializedSearchSuccess>{\n\t\t\t\tlimitHit: complete.limitHit,\n\t\t\t\ttype: 'success',\n\t\t\t\tstats: {\n\t\t\t\t\tdetailStats: complete.stats,\n\t\t\t\t\ttype: 'searchProcess',\n\t\t\t\t\tfromCache: false,\n\t\t\t\t\tresultCount,\n\t\t\t\t\tsortingTime: undefined\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate rawMatchToSearchItem(match: IRawFileMatch): ISerializedFileMatch {\n\t\treturn { path: match.base ? join(match.base, match.relativePath) : match.relativePath };\n\t}\n\n\tprivate doSortedSearch(engine: ISearchEngine<IRawFileMatch>, config: IFileQuery, progressCallback: IProgressCallback, fileProgressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> {\n\t\tconst emitter = new Emitter<IFileSearchProgressItem>();\n\n\t\tlet allResultsPromise = createCancelablePromise(token => {\n\t\t\tlet results: IRawFileMatch[] = [];\n\n\t\t\tconst innerProgressCallback: IFileProgressCallback = progress => {\n\t\t\t\tif (Array.isArray(progress)) {\n\t\t\t\t\tresults = progress;\n\t\t\t\t} else {\n\t\t\t\t\tfileProgressCallback(progress);\n\t\t\t\t\temitter.fire(progress);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn this.doSearch(engine, innerProgressCallback, -1, token)\n\t\t\t\t.then<[ISearchEngineSuccess, IRawFileMatch[]]>(result => {\n\t\t\t\t\treturn [result, results];\n\t\t\t\t});\n\t\t});\n\n\t\tlet cache: Cache;\n\t\tif (config.cacheKey) {\n\t\t\tcache = this.getOrCreateCache(config.cacheKey);\n\t\t\tconst cacheRow: ICacheRow = {\n\t\t\t\tpromise: allResultsPromise,\n\t\t\t\tevent: emitter.event,\n\t\t\t\tresolved: false\n\t\t\t};\n\t\t\tcache.resultsToSearchCache[config.filePattern || ''] = cacheRow;\n\t\t\tallResultsPromise.then(() => {\n\t\t\t\tcacheRow.resolved = true;\n\t\t\t}, err => {\n\t\t\t\tdelete cache.resultsToSearchCache[config.filePattern || ''];\n\t\t\t});\n\n\t\t\tallResultsPromise = this.preventCancellation(allResultsPromise);\n\t\t}\n\n\t\treturn allResultsPromise.then(([result, results]) => {\n\t\t\tconst scorerCache: ScorerCache = cache ? cache.scorerCache : Object.create(null);\n\t\t\tconst sortSW = (typeof config.maxResults !== 'number' || config.maxResults > 0) && StopWatch.create(false);\n\t\t\treturn this.sortResults(config, results, scorerCache, token)\n\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t// sortingTime: -1 indicates a \"sorted\" search that was not sorted, i.e. populating the cache when quickopen is opened.\n\t\t\t\t\t// Contrasting with findFiles which is not sorted and will have sortingTime: undefined\n\t\t\t\t\tconst sortingTime = sortSW ? sortSW.elapsed() : -1;\n\n\t\t\t\t\treturn [{\n\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\tstats: {\n\t\t\t\t\t\t\tdetailStats: result.stats,\n\t\t\t\t\t\t\tsortingTime,\n\t\t\t\t\t\t\tfromCache: false,\n\t\t\t\t\t\t\ttype: 'searchProcess',\n\t\t\t\t\t\t\tworkspaceFolderCount: config.folderQueries.length,\n\t\t\t\t\t\t\tresultCount: sortedResults.length\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults\n\t\t\t\t\t} as ISerializedSearchSuccess, sortedResults];\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate getOrCreateCache(cacheKey: string): Cache {\n\t\tconst existing = this.caches[cacheKey];\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\t\treturn this.caches[cacheKey] = new Cache();\n\t}\n\n\tprivate trySortedSearchFromCache(config: IFileQuery, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISerializedSearchSuccess, IRawFileMatch[]]> | undefined {\n\t\tconst cache = config.cacheKey && this.caches[config.cacheKey];\n\t\tif (!cache) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst cached = this.getResultsFromCache(cache, config.filePattern || '', progressCallback, token);\n\t\tif (cached) {\n\t\t\treturn cached.then(([result, results, cacheStats]) => {\n\t\t\t\tconst sortSW = StopWatch.create(false);\n\t\t\t\treturn this.sortResults(config, results, cache.scorerCache, token)\n\t\t\t\t\t.then<[ISerializedSearchSuccess, IRawFileMatch[]]>(sortedResults => {\n\t\t\t\t\t\tconst sortingTime = sortSW.elapsed();\n\t\t\t\t\t\tconst stats: IFileSearchStats = {\n\t\t\t\t\t\t\tfromCache: true,\n\t\t\t\t\t\t\tdetailStats: cacheStats,\n\t\t\t\t\t\t\ttype: 'searchProcess',\n\t\t\t\t\t\t\tresultCount: results.length,\n\t\t\t\t\t\t\tsortingTime\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: 'success',\n\t\t\t\t\t\t\t\tlimitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,\n\t\t\t\t\t\t\t\tstats\n\t\t\t\t\t\t\t} as ISerializedSearchSuccess,\n\t\t\t\t\t\t\tsortedResults\n\t\t\t\t\t\t];\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate sortResults(config: IFileQuery, results: IRawFileMatch[], scorerCache: ScorerCache, token?: CancellationToken): Promise<IRawFileMatch[]> {\n\t\t// we use the same compare function that is used later when showing the results using fuzzy scoring\n\t\t// this is very important because we are also limiting the number of results by config.maxResults\n\t\t// and as such we want the top items to be included in this result set if the number of items\n\t\t// exceeds config.maxResults.\n\t\tconst query = prepareQuery(config.filePattern || '');\n\t\tconst compare = (matchA: IRawFileMatch, matchB: IRawFileMatch) => compareItemsByScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache);\n\n\t\tconst maxResults = config.maxResults || Number.MAX_VALUE;\n\t\treturn arrays.topAsync(results, compare, maxResults, 10000, token);\n\t}\n\n\tprivate sendProgress(results: ISerializedFileMatch[], progressCb: IProgressCallback, batchSize: number) {\n\t\tif (batchSize && batchSize > 0) {\n\t\t\tfor (let i = 0; i < results.length; i += batchSize) {\n\t\t\t\tprogressCb(results.slice(i, i + batchSize));\n\t\t\t}\n\t\t} else {\n\t\t\tprogressCb(results);\n\t\t}\n\t}\n\n\tprivate getResultsFromCache(cache: Cache, searchValue: string, progressCallback: IFileProgressCallback, token?: CancellationToken): Promise<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]> | null {\n\t\tconst cacheLookupSW = StopWatch.create(false);\n\n\t\t// Find cache entries by prefix of search value\n\t\tconst hasPathSep = searchValue.indexOf(sep) >= 0;\n\t\tlet cachedRow: ICacheRow | undefined;\n\t\tfor (const previousSearch in cache.resultsToSearchCache) {\n\t\t\t// If we narrow down, we might be able to reuse the cached results\n\t\t\tif (strings.startsWith(searchValue, previousSearch)) {\n\t\t\t\tif (hasPathSep && previousSearch.indexOf(sep) < 0) {\n\t\t\t\t\tcontinue; // since a path character widens the search for potential more matches, require it in previous search too\n\t\t\t\t}\n\n\t\t\t\tconst row = cache.resultsToSearchCache[previousSearch];\n\t\t\t\tcachedRow = {\n\t\t\t\t\tpromise: this.preventCancellation(row.promise),\n\t\t\t\t\tevent: row.event,\n\t\t\t\t\tresolved: row.resolved\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!cachedRow) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cacheLookupTime = cacheLookupSW.elapsed();\n\t\tconst cacheFilterSW = StopWatch.create(false);\n\n\t\tconst listener = cachedRow.event(progressCallback);\n\t\tif (token) {\n\t\t\ttoken.onCancellationRequested(() => {\n\t\t\t\tlistener.dispose();\n\t\t\t});\n\t\t}\n\n\t\treturn cachedRow.promise.then<[ISearchEngineSuccess, IRawFileMatch[], ICachedSearchStats]>(([complete, cachedEntries]) => {\n\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\tthrow canceled();\n\t\t\t}\n\n\t\t\t// Pattern match on results\n\t\t\tconst results: IRawFileMatch[] = [];\n\t\t\tconst normalizedSearchValueLowercase = strings.stripWildcards(searchValue).toLowerCase();\n\t\t\tfor (const entry of cachedEntries) {\n\n\t\t\t\t// Check if this entry is a match for the search value\n\t\t\t\tif (!strings.fuzzyContains(entry.relativePath, normalizedSearchValueLowercase)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tresults.push(entry);\n\t\t\t}\n\n\t\t\treturn [complete, results, {\n\t\t\t\tcacheWasResolved: cachedRow!.resolved,\n\t\t\t\tcacheLookupTime,\n\t\t\t\tcacheFilterTime: cacheFilterSW.elapsed(),\n\t\t\t\tcacheEntryCount: cachedEntries.length\n\t\t\t}];\n\t\t});\n\t}\n\n\n\n\tprivate doSearch(engine: ISearchEngine<IRawFileMatch>, progressCallback: IFileProgressCallback, batchSize: number, token?: CancellationToken): Promise<ISearchEngineSuccess> {\n\t\treturn new Promise<ISearchEngineSuccess>((c, e) => {\n\t\t\tlet batch: IRawFileMatch[] = [];\n\t\t\tif (token) {\n\t\t\t\ttoken.onCancellationRequested(() => engine.cancel());\n\t\t\t}\n\n\t\t\tengine.search((match) => {\n\t\t\t\tif (match) {\n\t\t\t\t\tif (batchSize) {\n\t\t\t\t\t\tbatch.push(match);\n\t\t\t\t\t\tif (batchSize > 0 && batch.length >= batchSize) {\n\t\t\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t\t\t\tbatch = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogressCallback(match);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, (progress) => {\n\t\t\t\tprogressCallback(progress);\n\t\t\t}, (error, complete) => {\n\t\t\t\tif (batch.length) {\n\t\t\t\t\tprogressCallback(batch);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\te(error);\n\t\t\t\t} else {\n\t\t\t\t\tc(complete);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tclearCache(cacheKey: string): Promise<void> {\n\t\tdelete this.caches[cacheKey];\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\t/**\n\t * Return a CancelablePromise which is not actually cancelable\n\t * TODO@rob - Is this really needed?\n\t */\n\tprivate preventCancellation<C>(promise: CancelablePromise<C>): CancelablePromise<C> {\n\t\treturn new class implements CancelablePromise<C> {\n\t\t\tcancel() {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\tthen(resolve, reject) {\n\t\t\t\treturn promise.then(resolve, reject);\n\t\t\t}\n\t\t\tcatch(reject?) {\n\t\t\t\treturn this.then(undefined, reject);\n\t\t\t}\n\t\t\tfinally(onFinally) {\n\t\t\t\treturn promise.finally(onFinally);\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface ICacheRow {\n\t// TODO@roblou - never actually canceled\n\tpromise: CancelablePromise<[ISearchEngineSuccess, IRawFileMatch[]]>;\n\tresolved: boolean;\n\tevent: Event<IFileSearchProgressItem>;\n}\n\nclass Cache {\n\n\tresultsToSearchCache: { [searchValue: string]: ICacheRow; } = Object.create(null);\n\n\tscorerCache: ScorerCache = Object.create(null);\n}\n\nconst FileMatchItemAccessor = new class implements IItemAccessor<IRawFileMatch> {\n\n\tgetItemLabel(match: IRawFileMatch): string {\n\t\treturn match.basename; // e.g. myFile.txt\n\t}\n\n\tgetItemDescription(match: IRawFileMatch): string {\n\t\treturn match.relativePath.substr(0, match.relativePath.length - match.basename.length - 1); // e.g. some/path/to/file\n\t}\n\n\tgetItemPath(match: IRawFileMatch): string {\n\t\treturn match.relativePath; // e.g. some/path/to/file/myFile.txt\n\t}\n};\n\nfunction reviveQuery<U extends IRawQuery>(rawQuery: U): U extends IRawTextQuery ? ITextQuery : IFileQuery {\n\treturn {\n\t\t...<any>rawQuery, // TODO\n\t\t...{\n\t\t\tfolderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),\n\t\t\textraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(components => URI.revive(components))\n\t\t}\n\t};\n}\n\nfunction reviveFolderQuery(rawFolderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn {\n\t\t...rawFolderQuery,\n\t\tfolder: URI.revive(rawFolderQuery.folder)\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Server } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { SearchChannel } from './searchIpc';\nimport { SearchService } from './rawSearchService';\n\nconst server = new Server('search');\nconst service = new SearchService();\nconst channel = new SearchChannel(service);\nserver.registerChannel('search', channel);"]}