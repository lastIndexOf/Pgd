{"version":3,"sources":["vs/workbench/services/files/node/watcher/unix/fake","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/errors.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/arrays.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/functional.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/iterator.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/lifecycle.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/linkedList.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/event.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/cancellation.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/async.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/network.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/platform.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/process.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/path.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/strings.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/extpath.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/types.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/objects.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/uri.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/amd.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/map.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/glob.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/normalization.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/resources.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/uuid.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/console.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/decoder.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/flow.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/stream.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/encoding.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/extfs.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/processes.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.cp.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/instantiation/common/instantiation.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/files/common/files.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/files/node/watcher/common.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/files/node/watcher/unix/watcherIpc.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/files/node/watcher/unix/chokidarWatcherService.ts","vs/workbench/services/files/node/watcher/unix/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/services/files/node/watcher/unix/watcherApp.ts"],"names":["__m","__M","deps","result","i","len","length","isPromiseCanceledError","error","Error","name","canceledName","message","ErrorHandler","[object Object]","this","listeners","unexpectedErrorHandler","e","setTimeout","stack","listener","push","_removeListener","forEach","splice","indexOf","newUnexpectedErrorHandler","emit","exports","errorHandler","setUnexpectedErrorHandler","onUnexpectedError","onUnexpectedExternalError","transformErrorForSerialization","$isError","stacktrace","canceled","illegalArgument","illegalState","readonly","disposed","what","getErrorMessage","err","split","String","findFirstInSorted","array","p","low","high","mid","Math","floor","mergeSort","data","compare","_sort","a","lo","hi","aux","leftIdx","rightIdx","_merge","sortedDiff","before","after","pushSplice","start","deleteCount","toInsert","latest","beforeIdx","afterIdx","slice","beforeElement","afterElement","n","topStep","m","element","pop","j","firstIndex","fn","tail","tail2","arr","equals","one","other","itemEquals","b","binarySearch","key","comparator","comp","groupBy","currentGroup","undefined","delta","splices","removed","added","top","sort","topAsync","batch","token","Promise","resolve","reject","__awaiter","o","min","isCancellationRequested","errors_1","then","coalesce","filter","coalesceInPlace","to","move","from","isFalsyOrEmpty","obj","Array","isArray","isNonEmptyArray","distinct","keyFn","position","seen","Object","create","elem","uniqueFilter","first","notFoundValue","index","commonPrefixLength","flatten","concat","range","arg","fill","num","value","indexer","merger","t","reduce","r","insert","arrayInsert","target","insertIndex","insertArr","shuffle","_seed","rand","seed","x","sin","random","temp","pushToStart","unshift","pushToEnd","find","predicate","mapArrayOrNot","items","map","once","_this","didCall","apply","arguments","FIN","done","Iterator","iterator","next","_empty","empty","fromArray","elements","collect","getSequenceIterator","ArrayIterator","end","current","ArrayNavigator","super","max","MappedIterator","MappedNavigator","navigator","previous","parent","last","dispose","rest","d","isDisposable","thing","combinedDisposable","disposables","toDisposable","Disposable","_toDispose","_lifecycle_disposable_isDisposed","toDispose","console","warn","None","freeze","ReferenceCollection","references","reference","counter","object","createReferencedObject","functional_1","destroyReferencedObject","ImmortalReference","Node","LinkedList","_size","size","_first","_last","_insert","atTheEnd","newNode","oldLast","prev","oldFirst","_remove","bind","res","node","candidate","anchor","iterator_1","Event","event","thisArgs","didFire","call","snapshot","each","merge","initial","output","emitter","Emitter","fire","latch","cache","firstCall","shouldEmit","_disposable","signal","any","events","lifecycle_1","debounce","delay","leading","leakWarningThreshold","subscription","handle","numDebouncedCalls","cur","clearTimeout","_output","stopwatch","Date","getTime","_","buffer","nextTick","_buffer","flush","echo","ChainableEvent","chain","fromNodeEventEmitter","eventName","id","args","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromPromise","promise","toPromise","c","_globalLeakWarningThreshold","setGlobalLeakWarningThreshold","oldValue","LeakageMonitor","customThreshold","toString","_warnCountdown","_stacks","clear","listenerCount","threshold","Map","join","count","get","set","topStack","topCount","options","_disposed","_options","_leakageMon","_event","_listeners","linkedList_1","firstListener","isEmpty","remove","onFirstListenerDidAdd","onListenerDidAdd","removeMonitor","check","_noop","_deliveryQueue","iter","shift","AsyncEmitter","eventFn","_asyncDeliveryQueue","thenables","all","EventMultiplexer","hasListeners","hook","unhook","idx","EventBufferer","buffers","Relay","listening","inputEvent","inputEventListener","input","shortcutEvent","callback","context","CancellationToken","isCancellationToken","Cancelled","MutableToken","onCancellationRequested","event_1","_isCancelled","_emitter","CancellationTokenSource","_token","cancel","isThenable","createCancelablePromise","source","cancellation_1","thenable","errors","onfinally","finally","timeout","millis","sequence","promiseFactories","thenHandler","results","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","Sequencer","promiseTask","Delayer","defaultDelay","completionPromise","doResolve","task","cancelTimeout","doReject","ThrottledDelayer","delayer","throttler","trigger","isTriggered","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","timer","ignoreErrors","shouldStop","defaultValue","loop","factory","Limiter","maxDegreeOfParalellism","outstandingPromises","runningPromises","_onFinished","onFinished","consume","iLimitedTask","consumed","Queue","ResourceQueue","queues","resource","TimeoutTimer","runner","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","isScheduled","doRun","RunOnceWorker","units","unit","schedule","nfcall","ninvoke","thisArg","requestIdleCallback","cancelIdleCallback","dummyIdle","didTimeout","timeRemaining","runWhenIdle","IdleValue","executor","_executor","_value","_error","_didRun","_handle","Schemas","inMemory","vscode","internal","walkThrough","walkThroughSnippet","http","https","file","mailto","untitled","command","LANGUAGE_DEFAULT","_isWindows","_isMacintosh","_isNative","_locale","_language","_translationsConfigFile","isElectronRenderer","process","versions","electron","type","platform","rawNlsConfig","env","nlsConfig","JSON","parse","resolved","availableLanguages","locale","userAgent","language","Platform","PlatformToString","isRealWindows","isWindows","isMacintosh","isLinux","isNative","isWeb","isRootUser","getuid","translationsConfigFile","_globals","self","global","globals","_setImmediate","setImmediate","OperatingSystem","OS","safeProcess","cwd","platform_1","validateString","ErrorInvalidArgType","isPathSeparator","code","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","isPosixPathSeparator","isWindowsDeviceRoot","CHAR_UPPERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_A","CHAR_LOWERCASE_Z","normalizeString","path","allowAboveRoot","separator","lastSegmentLength","lastSlash","dots","charCodeAt","CHAR_DOT","lastSlashIndex","lastIndexOf","_format","sep","pathObject","dir","root","base","ext","expected","actual","determiner","replace","msg","win32","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","toLowerCase","rootEnd","device","isAbsolute","firstPart","paths","joined","needsReplace","slashCount","firstLen","normalize","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","resolvedPath","matchedSlash","offset","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","delimiter","posix","trailingSeparator","toNamespacedPath","hasRoot","relative","dirname","basename","extname","format","escapeRegExpCharacters","ltrim","haystack","needle","needleLen","substring","rtrim","haystackLen","isLowerAsciiLetter","isUpperAsciiLetter","isAsciiLetter","doEqualsIgnoreCase","stopAt","codeA","codeB","diff","abs","fromCharCode","substrEquals","aStart","aEnd","bStart","bEnd","isFullWidthCharacter","charCode","startsWithUTF8BOM","str","isFalsyOrWhitespace","trim","pad","l","char","reverse","_formatRegexp","match","group","parseInt","isNaN","escape","html","convertSimple2RegExpPattern","pattern","stripWildcards","startsWith","endsWith","createRegExp","searchString","isRegex","wholeWord","test","charAt","modifiers","matchCase","multiline","unicode","RegExp","regExpLeadsToEndlessLoop","regexp","exec","lastIndex","regExpContainsBackreference","regexpValue","regExpFlags","ignoreCase","firstNonWhitespaceIndex","chCode","getLeadingWhitespace","lastNonWhitespaceIndex","startIndex","compareIgnoreCase","equalsIgnoreCase","startsWithIgnoreCase","candidateLength","commonSuffixLength","aLastIndex","bLastIndex","overlap","isHighSurrogate","isLowSurrogate","CONTAINS_RTL","containsRTL","CONTAINS_EMOJI","containsEmoji","IS_BASIC_ASCII","isBasicASCII","containsFullWidthCharacter","lcut","text","re","EL","COLOR_START","COLOR_END","removeAnsiEscapeCodes","removeAccents","prototype","regex","UTF8_BOM_CHARACTER","stripUTF8BOM","substr","safeBtoa","btoa","encodeURIComponent","repeat","s","fuzzyContains","query","queryLen","targetLower","containsUppercaseCharacter","ignoreEscapedChars","uppercaseFirstLetter","toUpperCase","getNLines","isWindowsDriveLetter","char0","toSlashes","osPath","path_1","getRoot","firstLetter","pos","isUNC","INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","isValidBasename","isEqual","pathA","pathB","identityEquals","strings_1","isEqualOrParent","sepOffset","_typeof","number","constructor","isString","string","isObject","isUndefined","isUndefinedOrNull","isFunction","function","validateConstraint","constraint","_a","isStringArray","every","isNumber","Number","isBoolean","hasOwnProperty","isEmptyObject","areFunctions","objects","validateConstraints","constraints","ctor","isNativeClass","getAllPropertyNames","proto","getPrototypeOf","getOwnPropertyNames","withNullAsUndefined","withUndefinedAsNull","deepClone","keys","_cloneAndChange","changer","types_1","changed","r1","has","add","r2","i2","_hasOwnProperty","delete","mixin","destination","overwrite","oneKeys","otherKeys","deepFreeze","prop","isFrozen","cloneAndChange","Set","assign","sources","createKeywordMatcher","caseInsensitive","hash","arrayToHash","word","safeStringify","stringify","getOrDefault","k","baseValue","targetValue","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","escaped","encodeTable","_makeFsPath","uri","authority","scheme","_asFormatted","skipEncoding","encoder","fragment","_slash","userinfo","_schemePattern","_singleSlashStart","_doubleSlashStart","_throwOnMissingSchema","setUriThrowOnMissingScheme","old","_regexp","URI","fsPath","with","schemeOrData","_strict","trace","_schemeFix","_referenceResolution","_validateUri","change","_URI","decodeURIComponent","components","_fsPath","_formatted","external","$mid","58","47","63","35","91","93","64","33","36","38","39","40","41","42","43","44","59","61","32","getPathFromAmdModule","requirefn","relativePath","uri_1","toUrl","values","forEachable","getOrSet","mapToString","entries","setToString","mapToSerializable","serializable","serializableToMap","StringIterator","_pos","PathIterator","_from","_to","justSeps","ch","aPos","aLen","thisPos","cmp","TernarySearchTreeNode","left","right","TernarySearchTree","segments","_iter","_root","reset","segment","val","hasNext","oldElement","_nodeIterator","_forEach","ResourceMap","toKey","clb","resourceMap","Touch","LinkedMap","_map","_head","_tail","touch","addItemLast","addItemFirst","removeItem","callbackfn","newSize","currentSize","LRUCache","limit","ratio","_limit","_ratio","checkTrim","trimOld","round","starsToRegExp","starCount","NO_PATH_REGEX","PATH_REGEX","splitGlobAware","splitChar","inBraces","inBrackets","curVal","parseRegExp","regEx","GLOB_SPLIT","GLOBSTAR","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","strings","parsePattern","arg1","NULL","patternKey","trimForExclusions","parsedPattern","CACHE","wrapRelativePattern","T1","T2","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","T3_2","T3","parsedPatterns","aggregateBasenameMatches","withBasenames","arrays","allPaths","trivia3","T4","trivia4and5","T5","regExp","toRegExp","arg2","extpath","matchPathEnds","nativePath","ALL_FORWARD_SLASHES","nativePathEnd","FALSE","isRelativePattern","resultPattern","expression","when","hasSibling","clausePattern","matched","async_1","requiresSiblings","parseExpressionPattern","some","resultExpression","parsedExpression","listToMap","list","rp","basenamePatterns","aggregate","aggregatedPatterns","getEmptyExpression","map_1","hasSiblingPromiseFn","siblingsFn","siblings","hasSiblingFn","parseToAsync","getBasenameTerms","patternOrExpression","getPathTerms","form","normalizedCache","canNormalize","cached","nonAsciiCharactersPattern","nfcCache","normalizeNFC","nfdCache","normalizeNFD","hasToIgnoreCase","network_1","parentCandidate","originalFSPath","isEqualAuthority","a1","a2","uriPath","hasTrailingPathSeparator","fsp","getComparisonKey","basenameOrAuthority","second","p1","p2","joinPath","pathFragment","joinedPath","normalizePath","normalizedPath","isAbsolutePath","removeTrailingPathSeparator","resolvePath","distinctParents","resourceAccessor","candidateResource","otherItem","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","property","mime","ResourceGlobMatcher","globalExpression","rootExpressions","expressionsByRoot","forPaths","glob_1","rootExpression","findSubstr","v4","V4UUID","isUUID","_UUIDPattern","ValueUUID","_randomHex","_oneOf","_timeHighBits","_chars","generateUuid","asHex","entry","parsedArguments","stackArgument","__$stack","getFirstFrame","arg0","topFrame","findFirstFrame","matches","line","column","newlineIndex","color","isRemoteConsoleLog","severity","log","label","isOneStringArg","consoleArgs","LineDecoder","encoding","stringDecoder","sd","StringDecoder","remaining","write","lastChar","param","assert","ok","looper","sequences","sequenceResult","sequenceFunction","Sequence","parallel","didErrorOccur","doneCount","readExactlyByFile","totalBytes","fs","open","fd","resultBuffer","bytesRead","close","closeError","readChunk","read","Buffer","allocUnsafe","readToMatchingString","matchingString","chunkBytes","maximumBytesToRead","newLineIndex","decodeStream","iconv","toNodeEncoding","enc","UTF8_with_bom","UTF8","detectEncodingByBOMFromBuffer","b0","readUInt8","b1","UTF16be","UTF16le","b2","guessEncodingByBuffer","resolve_1","reject_1","require","jschardet","Constants","MINIMUM_THRESHOLD","guessed","detect","IGNORE_ENCODINGS","toIconvLiteEncoding","encodingName","normalizedEncodingName","JSCHARDET_TO_ICONV_ENCODINGS","detectEncodingFromBuffer","autoGuessEncoding","seemsBinary","couldBeUTF16LE","couldBeUTF16BE","containsZeroByte","ZERO_BYTE_DETECTION_BUFFER_MAX_LEN","isEndian","isZeroByte","readInt8","guessedEncoding","toDecodeStream","readable","minBytesRequiredForDetection","guessEncoding","AUTO_GUESS_BUFFER_MAX_LEN","NO_GUESS_BUFFER_MAX_LEN","overwriteEncoding","detected","pipe","stream_1","Writable","_bytesBuffered","chunk","isBuffer","_decodeStream","_decodeStreamConstruction","_startDecodeStream","stream","bomLength","decode","encode","content","encodingExists","encodeStream","detectEncodingByBOM","ibm866","big5","toCanonicalName","windowsTerminalEncodings","437","850","852","855","857","860","861","863","865","866","869","936","1252","resolveTerminalEncoding","verbose","rawEncodingPromise","cliEncodingEnv","child_process_1","stdout","stderr","windowsTerminalEncodingKeys","rawEncoding","iconvEncoding","readdirSync","normalization_1","readdir","children","copy","copiedSourcesIn","copiedSources","stat","isDirectory","mode","reader","createReadStream","writer","createWriteStream","finished","finish","chmod","doCopyFile","proceed","files","mkdirp","mkdir","mkdirErr","statErr","rmRecursive","exists","lstat","isSymbolicLink","unlink","rmdir","firstError","childrenLeft","child","delSync","lstatSync","rmdirSync","unlinkSync","writeFileAndFlush","ensureOptions","encoding_1","charset","addBOM","canFlush","writeFile","flag","openError","writeError","fdatasync","syncError","doWriteFileAndFlush","isBrowser","isOpen","destroy","flags","autoClose","descriptor","doWriteFileStreamAndFlush","ensuredOptions","realcaseSync","found","prefix","ix","flow","statLink","del","tmpFolder","pathInTemp","uuid","rename","mv","updateMtime","futimes","atime","writeFileAndFlushSync","writeFileSync","openSync","fdatasyncSync","closeSync","realpathSync","accessSync","constants","R_OK","realpath","access","watch","onChange","onError","watcher","raw","removeAllListeners","sanitizeFilePath","createSizeBuffer","writeUInt32BE","readSizeBuffer","readUInt32BE","serialize","BufferPresets","Undefined","el","deserialize","DataType","getDelayedChannel","cancellationToken","relay","listen","RequestType","ResponseType","State","BufferReader","bytes","BufferWriter","alloc","ChannelServer","protocol","ctx","channels","activeRequests","protocolListener","onMessage","onRawMessage","sendResponse","channelName","channel","response","send","header","body","sendBuffer","onPromise","onEventListen","disposeActiveRequest","request","cancellationTokenSource","disposable","ChannelClient","state","Uninitialized","handlers","lastRequestId","_onDidInitialize","onDidInitialize","onBuffer","that","requestPromise","requestEvent","uninitializedPromise","whenInitialized","sendRequest","cancellationTokenListener","onResponse","Idle","IPCServer","onDidClientConnect","_connections","_onDidChangeConnections","onDidChangeConnections","onDidClientDisconnect","onFirstMessage","channelServer","channelClient","registerChannel","connection","connections","router","routeCall","getChannel","routeEvent","IPCClient","getNextTickChannel","didTick","StaticRouter","hub","route","define","nls","terminateProcess","stdio","cp","execFileSync","pid","success","status","getWindowsCode","cmd","amd_1","spawnSync","kill","getWindowsShell","AbstractProcess","arg3","arg4","shell","executable","isShellCommand","childProcess","terminateRequested","newEnv","WellKnowCommands","pp","localize","useExec","cc","ee","killed","handleExec","Objects","windowsVerbatimArguments","detached","quotedCommand","quotedArg","commandLine","quoted","ensureQuotes","spawn","childProcessPromise","pidResolve","Types","terminated","handleClose","cmdCode","handleSpawn","cmdShell","ant","cmake","eslint","gradle","grunt","gulp","jake","jenkins","jshint","make","maven","msbuild","msc","nmake","npm","rake","tsc","xbuild","LineProcess","lineDecoder","decoder_1","sync","stdoutLineDecoder","stderrLineDecoder","createQueuedSender","msgQueue","useQueue","msgQueueCopy","findExecutable","PATH","pathEntry","fullPath","existsSync","withExtension","Server","ipc_1","Client","modulePath","_onDidProcessExit","onDidProcessExit","disposeDelayer","_client","getCachedChannel","disposeClient","client","forkOpts","objects_1","VSCODE_PARENT_PID","freshExecArgv","execArgv","debug","debugBrk","fork","onMessageEmitter","console_1","serverName","sender","processes_1","connected","onExit","storeServiceDependency","optional","_util","DI_TARGET","DI_DEPENDENCIES","createDecorator","serviceId","serviceIds","getServiceDependencies","IInstantiationService","serviceIdentifier","IFileService","instantiation_1","FileType","FileSystemProviderCapabilities","FileOperation","FileOperationEvent","_resource","_operation","_target","operation","FileChangeType","FileChangesEvent","changes","_changes","checkForChangeType","resources_1","getOfType","hasType","isParent","StringSnapshot","snapshotToString","chunks","FileOperationError","fileOperationResult","FileOperationResult","AutoSaveConfiguration","OFF","AFTER_DELAY","ON_FOCUS_CHANGE","ON_WINDOW_CHANGE","HotExitConfiguration","ON_EXIT","ON_EXIT_AND_WINDOW_CLOSE","CONTENT_CHANGE_EVENT_BUFFER_DELAY","FILES_ASSOCIATIONS_CONFIG","FILES_EXCLUDE_CONFIG","SUPPORTED_ENCODINGS","utf8","labelLong","labelShort","order","alias","utf8bom","encodeOnly","utf16le","utf16be","windows1252","iso88591","iso88593","iso885915","macroman","cp437","windows1256","iso88596","windows1257","iso88594","iso885914","windows1250","iso88592","cp852","windows1251","cp866","iso88595","koi8r","koi8u","iso885913","windows1253","iso88597","windows1255","iso88598","iso885910","iso885916","windows1254","iso88599","windows1258","gbk","gb18030","cp950","big5hkscs","shiftjis","eucjp","euckr","windows874","iso885911","koi8ru","koi8t","gb2312","cp865","cp850","FileKind","MIN_MAX_MEMORY_SIZE_MB","FALLBACK_MAX_MEMORY_SIZE_MB","toFileChangesEvent","files_1","normalizer","EventNormalizer","processEvent","normalized","mapPathToChange","existingEvent","currentChangeType","newChangeType","addedChangeEvents","deletedPaths","e1","e2","WatcherChannel","service","setRoots","setVerboseLogging","stop","WatcherChannelClient","enable","roots","normalizeRoots","requests","basePath","localeCompare","prevRequest","ignored","isEqualIgnore","i1","ChokidarWatcherService","_onWatchEvent","onWatchEvent","_verboseLogging","verboseLogging","_pollingInterval","pollingInterval","_watchers","_watcherCount","enabled","watchers","newRequests","requestsByBasePath","isEqualRequests","_watch","wacherCount","watcherOpts","ignoreInitial","ignorePermissionErrors","followSymlinks","binaryInterval","disableGlobbing","isSingleFolder","realBasePath","extfs_1","realBasePathLength","realBasePathDiffers","chokidarWatcher","chokidar","useFsEvents","undeliveredFileEvents","fileEventDelayer","FS_EVENT_DELAY","eventType","glob","relPath","isIgnored","now","spamWarningLogged","spamCheckStartTime","EVENT_SPAM_WARNING_THRESHOLD","watcherCommon","enospcErrorLogged","server","ipc_cp_1","chokidarWatcherService_1","watcherIpc_1"],"mappings":"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","file":"watcherApp.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\tpublic addListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tpublic setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tpublic getUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tpublic onUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tpublic onUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tlet { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): any;\n\tgetTypeName(): string;\n\tgetFunction(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string;\n\tgetLineNumber(): number;\n\tgetColumnNumber(): number;\n\tgetEvalOrigin(): string;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error: any): boolean {\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function disposed(what: string): Error {\n\tconst result = new Error(`${what} has been disposed`);\n\tresult.name = 'DISPOSED';\n\treturn result;\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { canceled } from 'vs/base/common/errors';\nimport { ISplice } from 'vs/base/common/sequence';\n\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail<T>(array: ArrayLike<T>, n: number = 0): T {\n\treturn array[array.length - (1 + n)];\n}\n\nexport function tail2<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\tlet low = 0,\n\t\thigh = array.length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = comparator(array[mid], key);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted<T>(array: ReadonlyArray<T>, p: (x: T) => boolean): number {\n\tlet low = 0, high = array.length;\n\tif (high === 0) {\n\t\treturn 0; // no children\n\t}\n\twhile (low < high) {\n\t\tconst mid = Math.floor((low + high) / 2);\n\t\tif (p(array[mid])) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn low;\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n/**\n * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`\n * so only use this when actually needing stable sort.\n */\nexport function mergeSort<T>(data: T[], compare: Compare<T>): T[] {\n\t_sort(data, compare, 0, data.length - 1, []);\n\treturn data;\n}\n\nfunction _merge<T>(a: T[], compare: Compare<T>, lo: number, mid: number, hi: number, aux: T[]): void {\n\tlet leftIdx = lo, rightIdx = mid + 1;\n\tfor (let i = lo; i <= hi; i++) {\n\t\taux[i] = a[i];\n\t}\n\tfor (let i = lo; i <= hi; i++) {\n\t\tif (leftIdx > mid) {\n\t\t\t// left side consumed\n\t\t\ta[i] = aux[rightIdx++];\n\t\t} else if (rightIdx > hi) {\n\t\t\t// right side consumed\n\t\t\ta[i] = aux[leftIdx++];\n\t\t} else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {\n\t\t\t// right element is less -> comes first\n\t\t\ta[i] = aux[rightIdx++];\n\t\t} else {\n\t\t\t// left element comes first (less or equal)\n\t\t\ta[i] = aux[leftIdx++];\n\t\t}\n\t}\n}\n\nfunction _sort<T>(a: T[], compare: Compare<T>, lo: number, hi: number, aux: T[]) {\n\tif (hi <= lo) {\n\t\treturn;\n\t}\n\tconst mid = lo + ((hi - lo) / 2) | 0;\n\t_sort(a, compare, lo, mid, aux);\n\t_sort(a, compare, mid + 1, hi, aux);\n\tif (compare(a[mid], a[mid + 1]) <= 0) {\n\t\t// left and right are sorted and if the last-left element is less\n\t\t// or equals than the first-right element there is nothing else\n\t\t// to do\n\t\treturn;\n\t}\n\t_merge(a, compare, lo, mid, hi, aux);\n}\n\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of mergeSort(data.slice(0), compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[], added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elemnts from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // nextTick() would starve I/O.\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow canceled();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstInSorted(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns a new array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: Array<T | undefined | null>): T[] {\n\tif (!array) {\n\t\treturn array;\n\t}\n\treturn <T[]>array.filter(e => !!e);\n}\n\n/**\n * Remove all falsey values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): void {\n\tif (!array) {\n\t\treturn;\n\t}\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * Moves the element in the array for the provided positions.\n */\nexport function move(array: any[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: any): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: ReadonlyArray<T> | undefined | null): obj is Array<T> {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn?: (t: T) => string): T[] {\n\tif (!keyFn) {\n\t\treturn array.filter((element, position) => {\n\t\t\treturn array.indexOf(element) === position;\n\t\t});\n\t}\n\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\treturn array.filter((elem) => {\n\t\tconst key = keyFn(elem);\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T>(keyFn: (t: T) => string): (t: T) => boolean {\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\t\treturn true;\n\t};\n}\n\nexport function firstIndex<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean): number {\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst element = array[i];\n\n\t\tif (fn(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean, notFoundValue: T): T;\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean): T | null;\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean, notFoundValue: T | null): T | null;\nexport function first<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean, notFoundValue: T | null = null): T | null {\n\tconst index = firstIndex(array, fn);\n\treturn index < 0 ? notFoundValue : array[index];\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function flatten<T>(arr: T[][]): T[] {\n\treturn (<T[]>[]).concat(...arr);\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function fill<T>(num: number, value: T, arr: T[] = []): T[] {\n\tfor (let i = 0; i < num; i++) {\n\t\tarr[i] = value;\n\t}\n\n\treturn arr;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, merger?: (t: T, r: R) => R): { [key: string]: R; };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, merger: (t: T, r: R) => R = t => t as any): { [key: string]: R; } {\n\treturn array.reduce((r, t) => {\n\t\tconst key = indexer(t);\n\t\tr[key] = merger(t, r[key]);\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => {\n\t\tconst index = array.indexOf(element);\n\t\tif (index > -1) {\n\t\t\tarray.splice(index, 1);\n\t\t}\n\t};\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function find<T>(arr: ArrayLike<T>, predicate: (value: T, index: number, arr: ArrayLike<T>) => any): T | undefined {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst element = arr[i];\n\t\tif (predicate(element, i, arr)) {\n\t\t\treturn element;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function once<T extends Function>(this: any, fn: T): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: any;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tresult = fn.apply(_this, arguments);\n\n\t\treturn result;\n\t} as any as T;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IteratorDefinedResult<T> {\n\treadonly done: false;\n\treadonly value: T;\n}\nexport interface IteratorUndefinedResult {\n\treadonly done: true;\n\treadonly value: undefined;\n}\nexport const FIN: IteratorUndefinedResult = { done: true, value: undefined };\nexport type IteratorResult<T> = IteratorDefinedResult<T> | IteratorUndefinedResult;\n\nexport interface Iterator<T> {\n\tnext(): IteratorResult<T>;\n}\n\nexport module Iterator {\n\tconst _empty: Iterator<any> = {\n\t\tnext() {\n\t\t\treturn FIN;\n\t\t}\n\t};\n\n\texport function empty<T>(): Iterator<T> {\n\t\treturn _empty;\n\t}\n\n\texport function fromArray<T>(array: T[], index = 0, length = array.length): Iterator<T> {\n\t\treturn {\n\t\t\tnext(): IteratorResult<T> {\n\t\t\t\tif (index >= length) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\treturn { done: false, value: array[index++] };\n\t\t\t}\n\t\t};\n\t}\n\n\texport function from<T>(elements: Iterator<T> | T[] | undefined): Iterator<T> {\n\t\tif (!elements) {\n\t\t\treturn Iterator.empty();\n\t\t} else if (Array.isArray(elements)) {\n\t\t\treturn Iterator.fromArray(elements);\n\t\t} else {\n\t\t\treturn elements;\n\t\t}\n\t}\n\n\texport function map<T, R>(iterator: Iterator<T>, fn: (t: T) => R): Iterator<R> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tconst element = iterator.next();\n\t\t\t\tif (element.done) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t} else {\n\t\t\t\t\treturn { done: false, value: fn(element.value) };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function filter<T>(iterator: Iterator<T>, fn: (t: T) => boolean): Iterator<T> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst element = iterator.next();\n\t\t\t\t\tif (element.done) {\n\t\t\t\t\t\treturn FIN;\n\t\t\t\t\t}\n\t\t\t\t\tif (fn(element.value)) {\n\t\t\t\t\t\treturn { done: false, value: element.value };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function forEach<T>(iterator: Iterator<T>, fn: (t: T) => void): void {\n\t\tfor (let next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\tfn(next.value);\n\t\t}\n\t}\n\n\texport function collect<T>(iterator: Iterator<T>): T[] {\n\t\tconst result: T[] = [];\n\t\tforEach(iterator, value => result.push(value));\n\t\treturn result;\n\t}\n}\n\nexport type ISequence<T> = Iterator<T> | T[];\n\nexport function getSequenceIterator<T>(arg: Iterator<T> | T[]): Iterator<T> {\n\tif (Array.isArray(arg)) {\n\t\treturn Iterator.fromArray(arg);\n\t} else {\n\t\treturn arg;\n\t}\n}\n\nexport interface INextIterator<T> {\n\tnext(): T | null;\n}\n\nexport class ArrayIterator<T> implements INextIterator<T> {\n\n\tprivate items: T[];\n\tprotected start: number;\n\tprotected end: number;\n\tprotected index: number;\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tthis.items = items;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.index = index;\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic next(): T | null {\n\t\tthis.index = Math.min(this.index + 1, this.end);\n\t\treturn this.current();\n\t}\n\n\tprotected current(): T | null {\n\t\tif (this.index === this.start - 1 || this.index === this.end) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.items[this.index];\n\t}\n}\n\nexport class ArrayNavigator<T> extends ArrayIterator<T> implements INavigator<T> {\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tsuper(items, start, end, index);\n\t}\n\n\tpublic current(): T | null {\n\t\treturn super.current();\n\t}\n\n\tpublic previous(): T | null {\n\t\tthis.index = Math.max(this.index - 1, this.start - 1);\n\t\treturn this.current();\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic last(): T | null {\n\t\tthis.index = this.end - 1;\n\t\treturn this.current();\n\t}\n\n\tpublic parent(): T | null {\n\t\treturn null;\n\t}\n}\n\nexport class MappedIterator<T, R> implements INextIterator<R> {\n\n\tconstructor(protected iterator: INextIterator<T>, protected fn: (item: T | null) => R) {\n\t\t// noop\n\t}\n\n\tnext() { return this.fn(this.iterator.next()); }\n}\n\nexport interface INavigator<T> extends INextIterator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tparent(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport class MappedNavigator<T, R> extends MappedIterator<T, R> implements INavigator<R> {\n\n\tconstructor(protected navigator: INavigator<T>, fn: (item: T) => R) {\n\t\tsuper(navigator, fn);\n\t}\n\n\tcurrent() { return this.fn(this.navigator.current()); }\n\tprevious() { return this.fn(this.navigator.previous()); }\n\tparent() { return this.fn(this.navigator.parent()); }\n\tfirst() { return this.fn(this.navigator.first()); }\n\tlast() { return this.fn(this.navigator.last()); }\n\tnext() { return this.fn(this.navigator.next()); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable><any>thing).dispose === 'function'\n\t\t&& (<IDisposable><any>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(...disposables: Array<T | undefined>): T[];\nexport function dispose<T extends IDisposable>(disposables: T[]): T[];\nexport function dispose<T extends IDisposable>(first: T | T[], ...rest: T[]): T | T[] | undefined {\n\tif (Array.isArray(first)) {\n\t\tfirst.forEach(d => d && d.dispose());\n\t\treturn [];\n\t} else if (rest.length === 0) {\n\t\tif (first) {\n\t\t\tfirst.dispose();\n\t\t\treturn first;\n\t\t}\n\t\treturn undefined;\n\t} else {\n\t\tdispose(first);\n\t\tdispose(rest);\n\t\treturn [];\n\t}\n}\n\nexport function combinedDisposable(disposables: IDisposable[]): IDisposable {\n\treturn { dispose: () => dispose(disposables) };\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn { dispose() { fn(); } };\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected _toDispose: IDisposable[] = [];\n\tprotected get toDispose(): IDisposable[] { return this._toDispose; }\n\n\tprivate _lifecycle_disposable_isDisposed = false;\n\n\tpublic dispose(): void {\n\t\tthis._lifecycle_disposable_isDisposed = true;\n\t\tthis._toDispose = dispose(this._toDispose);\n\t}\n\n\tprotected _register<T extends IDisposable>(t: T): T {\n\t\tif (this._lifecycle_disposable_isDisposed) {\n\t\t\tconsole.warn('Registering disposable on object that has already been disposed.');\n\t\t\tt.dispose();\n\t\t} else {\n\t\t\tthis._toDispose.push(t);\n\t\t}\n\n\t\treturn t;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate references: { [key: string]: { readonly object: T; counter: number; } } = Object.create(null);\n\n\tconstructor() { }\n\n\tacquire(key: string): IReference<T> {\n\t\tlet reference = this.references[key];\n\n\t\tif (!reference) {\n\t\t\treference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tdelete this.references[key];\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterator, IteratorResult, FIN } from 'vs/base/common/iterator';\n\nclass Node<E> {\n\telement: E;\n\tnext: Node<E> | undefined;\n\tprev: Node<E> | undefined;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> | undefined;\n\tprivate _last: Node<E> | undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._first;\n\t}\n\n\tclear(): void {\n\t\tthis._first = undefined;\n\t\tthis._last = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (!this._first) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last!;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\t\treturn this._remove.bind(this, newNode);\n\t}\n\n\n\tshift(): E | undefined {\n\t\tif (!this._first) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (!this._last) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tlet candidate: Node<E> | undefined = this._first;\n\t\twhile (candidate instanceof Node) {\n\t\t\tif (candidate !== node) {\n\t\t\t\tcandidate = candidate.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (candidate.prev && candidate.next) {\n\t\t\t\t// middle\n\t\t\t\tconst anchor = candidate.prev;\n\t\t\t\tanchor.next = candidate.next;\n\t\t\t\tcandidate.next.prev = anchor;\n\n\t\t\t} else if (!candidate.prev && !candidate.next) {\n\t\t\t\t// only node\n\t\t\t\tthis._first = undefined;\n\t\t\t\tthis._last = undefined;\n\n\t\t\t} else if (!candidate.next) {\n\t\t\t\t// last\n\t\t\t\tthis._last = this._last!.prev!;\n\t\t\t\tthis._last.next = undefined;\n\n\t\t\t} else if (!candidate.prev) {\n\t\t\t\t// first\n\t\t\t\tthis._first = this._first!.next!;\n\t\t\t\tthis._first.prev = undefined;\n\t\t\t}\n\n\t\t\t// done\n\t\t\tthis._size -= 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\titerator(): Iterator<E> {\n\t\tlet element: { done: false; value: E; };\n\t\tlet node = this._first;\n\t\treturn {\n\t\t\tnext(): IteratorResult<E> {\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\tif (!element) {\n\t\t\t\t\telement = { done: false, value: node.element };\n\t\t\t\t} else {\n\t\t\t\t\telement.value = node.element;\n\t\t\t\t}\n\t\t\t\tnode = node.next;\n\t\t\t\treturn element;\n\t\t\t}\n\t\t};\n\t}\n\n\ttoArray(): E[] {\n\t\tconst result: E[] = [];\n\t\tfor (let node = this._first; node instanceof Node; node = node.next) {\n\t\t\tresult.push(node.element);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { combinedDisposable, Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n}\n\nexport namespace Event {\n\tconst _disposable = { dispose() { } };\n\texport const None: Event<any> = function () { return _disposable; };\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event and a `map` function, returns another event which maps each element\n\t * throught the mapping function.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n\t}\n\n\t/**\n\t * Given an event and an `each` function, returns another identical event and calls\n\t * the `each` function per each element.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n\t}\n\n\t/**\n\t * Given an event and a `filter` function, returns another event which emits those\n\t * elements for which the `filter` function returns `true`.\n\t */\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * Given an event and a `merge` function, returns another event which maps each element\n\t * and the cummulative result throught the `merge` function. Similar to `map`, but with memory.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Given a chain of event processing functions (filter, map, etc), each\n\t * function will be invoked per event & per listener. Snapshotting an event\n\t * chain allows each function to be invoked just once per event.\n\t */\n\texport function snapshot<T>(event: Event<T>): Event<T> {\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces the provided event, given a `merge` function.\n\t *\n\t * @param event The input event.\n\t * @param merge The reducing function.\n\t * @param delay The debouncing delay in millis.\n\t * @param leading Whether the event should fire in the leading phase of the timeout.\n\t * @param leakWarningThreshold The leak warning threshold override.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst emitter = new Emitter<O>({\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only once and as soon as\n\t * the input event emits. The event data is the number of millis it took for the\n\t * event to fire.\n\t */\n\texport function stopwatch<T>(event: Event<T>): Event<number> {\n\t\tconst start = new Date().getTime();\n\t\treturn map(once(event), _ => new Date().getTime() - start);\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only when the event\n\t * element changes.\n\t */\n\texport function latch<T>(event: Event<T>): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || value !== cache;\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t});\n\t}\n\n\t/**\n\t * Buffers the provided event until a first listener comes\n\t * along, at which point fire all the events at once and\n\t * pipe the event from then on.\n\t *\n\t * ```typescript\n\t * const emitter = new Emitter<number>();\n\t * const event = emitter.event;\n\t * const bufferedEvent = buffer(event);\n\t *\n\t * emitter.fire(1);\n\t * emitter.fire(2);\n\t * emitter.fire(3);\n\t * // nothing...\n\t *\n\t * const listener = bufferedEvent(num => console.log(num));\n\t * // 1, 2, 3\n\t *\n\t * emitter.fire(4);\n\t * // 4\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, nextTick = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.forEach(e => emitter.fire(e));\n\t\t\t}\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (nextTick) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Similar to `buffer` but it buffers indefinitely and repeats\n\t * the buffered events to every new listener.\n\t */\n\texport function echo<T>(event: Event<T>, nextTick = false, buffer: T[] = []): Event<T> {\n\t\tbuffer = buffer.slice();\n\n\t\tevent(e => {\n\t\t\tbuffer.push(e);\n\t\t\temitter.fire(e);\n\t\t});\n\n\t\tconst flush = (listener: (e: T) => any, thisArgs?: any) => buffer.forEach(e => listener.call(thisArgs, e));\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonListenerDidAdd(emitter: Emitter<T>, listener: (e: T) => any, thisArgs?: any) {\n\t\t\t\tif (nextTick) {\n\t\t\t\t\tsetTimeout(() => flush(listener, thisArgs));\n\t\t\t\t} else {\n\t\t\t\t\tflush(listener, thisArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> {\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): this;\n\t\tremoveListener(event: string | symbol, listener: Function): this;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function fromPromise<T = any>(promise: Promise<T>): Event<undefined> {\n\t\tconst emitter = new Emitter<undefined>();\n\t\tlet shouldEmit = false;\n\n\t\tpromise\n\t\t\t.then(undefined, () => null)\n\t\t\t.then(() => {\n\t\t\t\tif (!shouldEmit) {\n\t\t\t\t\tsetTimeout(() => emitter.fire(undefined), 0);\n\t\t\t\t} else {\n\t\t\t\t\temitter.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\tshouldEmit = true;\n\t\treturn emitter.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(c => once(event)(c));\n\t}\n}\n\ntype Listener<T> = [(e: T) => void, any] | ((e: T) => void);\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n\t\tconst count = (this._stacks.get(stack) || 0);\n\t\tthis._stacks.set(stack, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string;\n\t\t\tlet topCount: number = 0;\n\t\t\tthis._stacks.forEach((count, stack) => {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack) || 0);\n\t\t\tthis._stacks!.set(stack, count - 1);\n\t\t};\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static readonly _noop = function () { };\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue: [Listener<T>, T][];\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0\n\t\t\t? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n\t\t\t: undefined;\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tconst remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options && this._options.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, listener, thisArgs);\n\t\t\t\t}\n\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tlet removeMonitor: (() => void) | undefined;\n\t\t\t\tif (this._leakageMon) {\n\t\t\t\t\tremoveMonitor = this._leakageMon.check(this._listeners.size);\n\t\t\t\t}\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (removeMonitor) {\n\t\t\t\t\t\t\tremoveMonitor();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tremove();\n\t\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = [];\n\t\t\t}\n\n\t\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\t\tthis._deliveryQueue.push([e.value, event]);\n\t\t\t}\n\n\t\t\twhile (this._deliveryQueue.length > 0) {\n\t\t\t\tconst [listener, event] = this._deliveryQueue.shift()!;\n\t\t\t\ttry {\n\t\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif (this._listeners) {\n\t\t\tthis._listeners = undefined;\n\t\t}\n\t\tif (this._deliveryQueue) {\n\t\t\tthis._deliveryQueue.length = 0;\n\t\t}\n\t\tif (this._leakageMon) {\n\t\t\tthis._leakageMon.dispose();\n\t\t}\n\t\tthis._disposed = true;\n\t}\n}\n\nexport interface IWaitUntil {\n\twaitUntil(thenable: Promise<any>): void;\n}\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue: [Listener<T>, T, Promise<any>[]][];\n\n\tasync fireAsync(eventFn: (thenables: Promise<any>[], listener: Function) => T): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\t// put all [listener,event]-pairs into delivery queue\n\t\t// then emit all event. an inner/nested event might be\n\t\t// the driver of this\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = [];\n\t\t}\n\n\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\tconst thenables: Promise<void>[] = [];\n\t\t\tthis._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);\n\t\t}\n\n\t\twhile (this._asyncDeliveryQueue.length > 0) {\n\t\t\tconst [listener, event, thenables] = this._asyncDeliveryQueue.shift()!;\n\t\t\ttry {\n\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t} else {\n\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\t\t\tawait Promise.all(thenables);\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null; }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\treadonly isCancellationRequested: boolean;\n\t/**\n\t * An event emitted when cancellation is requested\n\t * @event\n\t */\n\treadonly onCancellationRequested: Event<any>;\n}\n\nconst shortcutEvent = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n} as Event<any>);\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: any): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token: CancellationToken;\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn new class implements CancelablePromise<T> {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: (err: any) => void;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tconst task = this.task!;\n\t\t\t\tthis.task = null;\n\n\t\t\t\treturn task();\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tthis.doResolve!(null);\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject(errors.canceled());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tpublic get onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue {\n\tprivate queues: { [path: string]: Queue<void> };\n\n\tconstructor() {\n\t\tthis.queues = Object.create(null);\n\t}\n\n\tpublic queueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues[key]) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tdelete this.queues[key];\n\t\t\t});\n\n\t\t\tthis.queues[key] = queue;\n\t\t}\n\n\t\treturn this.queues[key];\n\t}\n}\n\nexport class TimeoutTimer extends Disposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tsuper();\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer extends Disposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport function nfcall(fn: Function, ...args: any[]): Promise<any>;\nexport function nfcall<T>(fn: Function, ...args: any[]): Promise<T>;\nexport function nfcall(fn: Function, ...args: any[]): any {\n\treturn new Promise((c, e) => fn(...args, (err: any, result: any) => err ? e(err) : c(result)));\n}\n\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): Promise<any>;\nexport function ninvoke<T>(thisArg: any, fn: Function, ...args: any[]): Promise<T>;\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): any {\n\treturn new Promise((resolve, reject) => fn.call(thisArg, ...args, (err: any, result: any) => err ? reject(err) : resolve(result)));\n}\n\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): DOMHighResTimeStamp;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean;\n\tprivate _value: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory: string = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode: string = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal: string = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough: string = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet: string = 'walkThroughSnippet';\n\n\texport const http: string = 'http';\n\n\texport const https: string = 'https';\n\n\texport const file: string = 'file';\n\n\texport const mailto: string = 'mailto';\n\n\texport const untitled: string = 'untitled';\n\n\texport const data: string = 'data';\n\n\texport const command: string = 'command';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\n// let _isLinux = false;\nlet _isNative = false;\n// let _isWeb = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\n\ninterface NLSConfig {\n\tlocale: string;\n\tavailableLanguages: { [key: string]: string; };\n\t_translationsConfigFile: string;\n}\n\nexport interface IProcessEnvironment {\n\t[key: string]: string;\n}\n\ninterface INodeProcess {\n\tplatform: string;\n\tenv: IProcessEnvironment;\n\tgetuid(): number;\n\tnextTick: Function;\n\tversions?: {\n\t\telectron?: string;\n\t};\n\ttype?: string;\n}\ndeclare const process: INodeProcess;\ndeclare const global: any;\n\ninterface INavigator {\n\tuserAgent: string;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\ndeclare const self: any;\n\nconst isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');\n\n// OS detection\nif (typeof navigator === 'object' && !isElectronRenderer) {\n\tconst userAgent = navigator.userAgent;\n\t_isWindows = userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = userAgent.indexOf('Macintosh') >= 0;\n\t// _isLinux = userAgent.indexOf('Linux') >= 0;\n\t// _isWeb = true;\n\t_locale = navigator.language;\n\t_language = _locale;\n} else if (typeof process === 'object') {\n\t_isWindows = (process.platform === 'win32');\n\t_isMacintosh = (process.platform === 'darwin');\n\t// _isLinux = (process.platform === 'linux');\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\tconst resolved = nlsConfig.availableLanguages['*'];\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t// VSCode's default language is 'en'\n\t\t\t_language = resolved ? resolved : LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport function PlatformToString(platform: Platform) {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\n// let _platform: Platform = Platform.Web;\n// if (_isNative) {\n// \tif (_isMacintosh) {\n// \t\t_platform = Platform.Mac;\n// \t} else if (_isWindows) {\n// \t\t_platform = Platform.Windows;\n// \t} else if (_isLinux) {\n// \t\t_platform = Platform.Linux;\n// \t}\n// }\n\nexport const isRealWindows = _isWindows;\nexport const isWindows = false; // _isWindows;\nexport const isMacintosh = true; // _isMacintosh;\nexport const isLinux = false; // _isLinux;\nexport const isNative = false; // _isNative;\nexport const isWeb = false; // _isWeb;\nexport const platform = 1; // _platform;\n\nexport function isRootUser(): boolean {\n\treturn _isNative && !_isWindows && (process.getuid() === 0);\n}\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * The translatios that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nconst _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {} as any);\nexport const globals: any = _globals;\n\nlet _setImmediate: ((callback: (...args: any[]) => void) => number) | null = null;\nexport function setImmediate(callback: (...args: any[]) => void): number {\n\tif (_setImmediate === null) {\n\t\tif (globals.setImmediate) {\n\t\t\t_setImmediate = globals.setImmediate.bind(globals);\n\t\t} else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n\t\t\t_setImmediate = process.nextTick.bind(process);\n\t\t} else {\n\t\t\t_setImmediate = globals.setTimeout.bind(globals);\n\t\t}\n\t}\n\treturn _setImmediate!(callback);\n}\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate } from 'vs/base/common/platform';\n\ninterface IProcess {\n\tplatform: string;\n\tenv: object;\n\n\tcwd(): string;\n\tnextTick(callback: (...args: any[]) => void): number;\n}\n\ndeclare const process: IProcess;\nconst safeProcess: IProcess = (typeof process === 'undefined') ? {\n\tcwd(): string { return '/'; },\n\tenv: Object.create(null),\n\tget platform(): string { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\tnextTick(callback: (...args: any[]) => void): number { return setImmediate(callback); }\n} : process;\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: string) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tlet msg;\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tmsg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\t}\n}\n\nfunction validateString(value: string, name) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (lastSlash !== i - 1 && dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length === 2 || res.length === 1) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tif (res.length > 0) {\n\t\t\t\t\t\tres += `${separator}..`;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = '..';\n\t\t\t\t\t}\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += separator + path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep, pathObject) {\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t((pathObject.name || '') + (pathObject.ext || ''));\n\tif (!dir) {\n\t\treturn base;\n\t}\n\tif (dir === pathObject.root) {\n\t\treturn dir + base;\n\t}\n\treturn dir + sep + base;\n}\n\ninterface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\ninterface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t} else if (!resolvedDevice) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env['=' + resolvedDevice] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 3).toLowerCase() !==\n\t\t\t\t\tresolvedDevice.toLowerCase() + '\\\\') {\n\t\t\t\t\tpath = resolvedDevice + '\\\\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len > 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// Possible UNC root\n\n\t\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\t\tisAbsolute = true;\n\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\t\tlet j = 2;\n\t\t\t\t\t\tlet last = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEnd = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t\t// Possible device root\n\n\t\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\t\trootEnd = 2;\n\t\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator\n\t\t\t\trootEnd = 1;\n\t\t\t\tisAbsolute = true;\n\t\t\t}\n\n\t\t\tif (device.length > 0 &&\n\t\t\t\tresolvedDevice.length > 0 &&\n\t\t\t\tdevice.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length === 0 && device.length > 0) {\n\t\t\t\tresolvedDevice = device;\n\t\t\t}\n\t\t\tif (!resolvedAbsolute) {\n\t\t\t\tresolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length > 0 && resolvedAbsolute) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n\t\t\t'.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t\t// path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t\t// is nothing left to process\n\n\t\t\t\t\t\t\t\treturn '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid unnecessary\n\t\t\t// work\n\t\t\treturn '\\\\';\n\t\t}\n\n\t\tlet tail;\n\t\tif (rootEnd < len) {\n\t\t\ttail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\',\n\t\t\t\tisPathSeparator);\n\t\t} else {\n\t\t\ttail = '';\n\t\t}\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\tif (isAbsolute) {\n\t\t\t\tif (tail.length > 0) {\n\t\t\t\t\treturn '\\\\' + tail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t} else if (tail.length > 0) {\n\t\t\t\treturn tail;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (isAbsolute) {\n\t\t\tif (tail.length > 0) {\n\t\t\t\treturn device + '\\\\' + tail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn device + '\\\\';\n\t\t\t}\n\t\t} else if (tail.length > 0) {\n\t\t\treturn device + tail;\n\t\t} else {\n\t\t\treturn device;\n\t\t}\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\tif (isPathSeparator(code)) {\n\t\t\treturn true;\n\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t// Possible device root\n\n\t\t\tif (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '\\\\' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1) {\n\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t\t++slashCount;\n\t\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\tfor (; slashCount < joined.length; ++slashCount) {\n\t\t\t\tif (!isPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = '\\\\' + joined.slice(slashCount);\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\tfor (; fromEnd - 1 > fromStart; --fromEnd) {\n\t\t\tif (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\tfor (; toEnd - 1 > toStart; --toEnd) {\n\t\t\tif (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length && lastCommonSep === -1) {\n\t\t\treturn toOrig;\n\t\t}\n\n\t\tlet out = '';\n\t\tif (lastCommonSep === -1) {\n\t\t\tlastCommonSep = 0;\n\t\t}\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '\\\\..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + toOrig.slice(toStart + lastCommonSep, toEnd);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn toOrig.slice(toStart, toEnd);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length >= 3) {\n\t\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\t\treturn '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\t\t\treturn '\\\\\\\\?\\\\' + resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = offset = 1;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = offset = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\trootEnd = offset = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn path;\n\t\t}\n\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = rootEnd;\n\t\t\t}\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2) {\n\t\t\tconst drive = path.charCodeAt(0);\n\t\t\tif (isWindowsDeviceRoot(drive)) {\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tstart = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('\\\\', pathObject);\n\t},\n\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = 1;\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\tif (len === 3) {\n\t\t\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\tret.root = ret.dir = path;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t}\n\t\t} else {\n\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\tret.base = path.slice(startPart, end);\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = process.cwd();\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = path + '/' + resolvedPath;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\tif (resolvedPath.length > 0) {\n\t\t\t\treturn '/' + resolvedPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t} else if (resolvedPath.length > 0) {\n\t\t\treturn resolvedPath;\n\t\t} else {\n\t\t\treturn '.';\n\t\t}\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0 && !isAbsolute) {\n\t\t\tpath = '.';\n\t\t}\n\t\tif (path.length > 0 && trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\tif (isAbsolute) {\n\t\t\treturn '/' + path;\n\t\t}\n\t\treturn path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = arguments[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '/' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 1;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 1;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toEnd = to.length;\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t} else if (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t\t// For example: from='/foo'; to='/'\n\t\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '/..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + to.slice(toStart + lastCommonSep);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn to.slice(toStart);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('/', pathObject);\n\t},\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\t\tret.base = ret.name = path.slice(1, end);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\tret.name = path.slice(1, startDot);\n\t\t\t\tret.base = path.slice(1, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t}\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * The empty string.\n */\nexport const empty = '';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\n/**\n * @returns the provided number with the given number of preceding zeros.\n */\nexport function pad(n: number, l: number, char: string = '0'): string {\n\tconst str = '' + n;\n\tconst r = [str];\n\n\tfor (let i = str.length; i < l; i++) {\n\t\tr.push(char);\n\t}\n\n\treturn r.reverse().join('');\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\n/**\n * Determines if haystack starts with needle.\n */\nexport function startsWith(haystack: string, needle: string): boolean {\n\tif (haystack.length < needle.length) {\n\t\treturn false;\n\t}\n\n\tif (haystack === needle) {\n\t\treturn true;\n\t}\n\n\tfor (let i = 0; i < needle.length; i++) {\n\t\tif (haystack[i] !== needle[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack: string, needle: string): boolean {\n\tconst diff = haystack.length - needle.length;\n\tif (diff > 0) {\n\t\treturn haystack.indexOf(needle, diff) === diff;\n\t} else if (diff === 0) {\n\t\treturn haystack === needle;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && <any>regexp.lastIndex === 0);\n}\n\nexport function regExpContainsBackreference(regexpValue: string): boolean {\n\treturn !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\n\nexport function regExpFlags(regexp: RegExp): string {\n\treturn (regexp.global ? 'g' : '')\n\t\t+ (regexp.ignoreCase ? 'i' : '')\n\t\t+ (regexp.multiline ? 'm' : '')\n\t\t+ ((regexp as any).unicode ? 'u' : '');\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\tconst len = Math.min(a.length, b.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tlet codeA = a.charCodeAt(i);\n\t\tlet codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeA)) {\n\t\t\tcodeA += 32;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeB)) {\n\t\t\tcodeB += 32;\n\t\t}\n\n\t\tconst diff = codeA - codeB;\n\n\t\tif (diff === 0) {\n\t\t\t// equal -> ignoreCase\n\t\t\tcontinue;\n\n\t\t} else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n\t\t\t//\n\t\t\treturn diff;\n\n\t\t} else {\n\t\t\treturn compare(a.toLowerCase(), b.toLowerCase());\n\t\t}\n\t}\n\n\tif (a.length < b.length) {\n\t\treturn -1;\n\t} else if (a.length > b.length) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nfunction isAsciiLetter(code: number): boolean {\n\treturn isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\tconst len1 = a ? a.length : 0;\n\tconst len2 = b ? b.length : 0;\n\n\tif (len1 !== len2) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(a, b);\n}\n\nfunction doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {\n\tif (typeof a !== 'string' || typeof b !== 'string') {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < stopAt; i++) {\n\t\tconst codeA = a.charCodeAt(i);\n\t\tconst codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// a-z A-Z\n\t\tif (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n\t\t\tconst diff = Math.abs(codeA - codeB);\n\t\t\tif (diff !== 0 && diff !== 32) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Any other charcode\n\t\telse {\n\t\t\tif (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nfunction substrEquals(a: string, aStart: number, aEnd: number, b: string, bStart: number, bEnd: number): boolean {\n\twhile (aStart < aEnd && bStart < bEnd) {\n\t\tif (a[aStart] !== b[bStart]) {\n\t\t\treturn false;\n\t\t}\n\t\taStart += 1;\n\t\tbStart += 1;\n\t}\n\treturn true;\n}\n\n/**\n * Return the overlap between the suffix of `a` and the prefix of `b`.\n * For instance `overlap(\"foobar\", \"arr, I'm a pirate\") === 2`.\n */\nexport function overlap(a: string, b: string): number {\n\tconst aEnd = a.length;\n\tlet bEnd = b.length;\n\tlet aStart = aEnd - bEnd;\n\n\tif (aStart === 0) {\n\t\treturn a === b ? aEnd : 0;\n\t} else if (aStart < 0) {\n\t\tbEnd += aStart;\n\t\taStart = 0;\n\t}\n\n\twhile (aStart < aEnd && bEnd > 0) {\n\t\tif (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {\n\t\t\treturn bEnd;\n\t\t}\n\t\tbEnd -= 1;\n\t\taStart += 1;\n\t}\n\treturn 0;\n}\n\n// --- unicode\n// http://en.wikipedia.org/wiki/Surrogate_pair\n// Returns the code point starting at a specified index in a string\n// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n// Code points U+10000 to U+10FFFF are represented on two consecutive characters\n//export function getUnicodePoint(str:string, index:number, len:number):number {\n//\tconst chrCode = str.charCodeAt(index);\n//\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n//\t\tconst nextChrCode = str.charCodeAt(index + 1);\n//\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n//\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n//\t\t}\n//\t}\n//\treturn chrCode;\n//}\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\treturn CONTAINS_RTL.test(str);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nconst CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEF8]|\\uD83E[\\uDD00-\\uDDE6])/;\n\nexport function containsEmoji(str: string): boolean {\n\treturn CONTAINS_EMOJI.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport function containsFullWidthCharacter(str: string): boolean {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tif (isFullWidthCharacter(str.charCodeAt(i))) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80  2EFF   CJK Radicals Supplement\n\t//          2F00  2FDF   Kangxi Radicals\n\t//          2FF0  2FFF   Ideographic Description Characters\n\t//          3000  303F   CJK Symbols and Punctuation\n\t//          3040  309F   Hiragana\n\t//          30A0  30FF   Katakana\n\t//          3100  312F   Bopomofo\n\t//          3130  318F   Hangul Compatibility Jamo\n\t//          3190  319F   Kanbun\n\t//          31A0  31BF   Bopomofo Extended\n\t//          31F0  31FF   Katakana Phonetic Extensions\n\t//          3200  32FF   Enclosed CJK Letters and Months\n\t//          3300  33FF   CJK Compatibility\n\t//          3400  4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0  4DFF   Yijing Hexagram Symbols\n\t//          4E00  9FFF   CJK Unified Ideographs\n\t//          A000  A48F   Yi Syllables\n\t//          A490  A4CF   Yi Radicals\n\t//          AC00  D7AF   Hangul Syllables\n\t// [IGNORE] D800  DB7F   High Surrogates\n\t// [IGNORE] DB80  DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00  DFFF   Low Surrogates\n\t// [IGNORE] E000  F8FF   Private Use Area\n\t//          F900  FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00  FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50  FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00  FE0F   Variation Selectors\n\t// [IGNORE] FE20  FE2F   Combining Half Marks\n\t// [IGNORE] FE30  FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50  FE6F   Small Form Variants\n\t// [IGNORE] FE70  FEFF   Arabic Presentation Forms-B\n\t//          FF00  FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0  FFFF   Specials\n\tcharCode = +charCode; // @perf\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nexport function lcut(text: string, n: number) {\n\tif (text.length < n) {\n\t\treturn text;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(text)) {\n\t\tif (text.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\treturn text.substring(i).replace(/^\\s/, empty);\n}\n\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nconst EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nconst COLOR_START = /\\x1b\\[\\d+m/g; // Color\nconst COLOR_END = /\\x1b\\[0?m/g; // Color\n\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(EL, '');\n\t\tstr = str.replace(COLOR_START, '');\n\t\tstr = str.replace(COLOR_END, '');\n\t}\n\n\treturn str;\n}\n\nexport const removeAccents: (str: string) => string = (function () {\n\tif (typeof (String.prototype as any).normalize !== 'function') {\n\t\t//  no ES6 features...\n\t\treturn function (str: string) { return str; };\n\t} else {\n\t\t// transform into NFD form and remove accents\n\t\t// see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n\t\tconst regex = /[\\u0300-\\u036f]/g;\n\t\treturn function (str: string) {\n\t\t\treturn (str as any).normalize('NFD').replace(regex, empty);\n\t\t};\n\t}\n})();\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\nexport function safeBtoa(str: string): string {\n\treturn btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n}\n\nexport function repeat(s: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\treturn idx >= 0 ?\n\t\tstr.substr(0, idx) :\n\t\tstr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix } from 'vs/base/common/path';\n\nfunction isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst INVALID_FILE_CHARS = isWindows ? /[\\\\/:\\*\\?\"<>\\|]/g : /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])$/i;\nexport function isValidBasename(name: string | null | undefined): boolean {\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tINVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development\n\tif (INVALID_FILE_CHARS.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindows && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindows && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 lenth\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(path: string, candidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (path === candidate) {\n\t\treturn true;\n\t}\n\n\tif (!path || !candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(path, candidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (candidate.length === path.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = candidate.length;\n\t\tif (candidate.charAt(candidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn path.charAt(sepOffset) === separator;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== separator) {\n\t\tcandidate += separator;\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst _typeof = {\n\tnumber: 'number',\n\tstring: 'string',\n\tundefined: 'undefined',\n\tobject: 'object',\n\tfunction: 'function'\n};\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\nexport function isArray(array: any): array is any[] {\n\tif (Array.isArray) {\n\t\treturn Array.isArray(array);\n\t}\n\n\tif (array && typeof (array.length) === _typeof.number && array.constructor === Array) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: any): str is string {\n\tif (typeof (str) === _typeof.string || str instanceof String) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: any): value is string[] {\n\treturn isArray(value) && (<any[]>value).every(elem => isString(elem));\n}\n\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: any): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === _typeof.object\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: any): obj is number {\n\tif ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: any): obj is boolean {\n\treturn obj === true || obj === false;\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: any): obj is undefined {\n\treturn typeof (obj) === _typeof.undefined;\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: any): obj is undefined | null {\n\treturn isUndefined(obj) || obj === null;\n}\n\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: any): obj is any {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (let key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: any): obj is Function {\n\treturn typeof obj === _typeof.function;\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: any[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: any[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: any, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch{\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Creates a new object of the provided class and will call the constructor with\n * any additional argument supplied.\n */\nexport function create(ctor: Function, ...args: any[]): any {\n\tif (isNativeClass(ctor)) {\n\t\treturn new (ctor as any)(...args);\n\t} else {\n\t\tconst obj = Object.create(ctor.prototype);\n\t\tctor.apply(obj, args);\n\t\treturn obj;\n\t}\n}\n\n// https://stackoverflow.com/a/32235645/1499159\nfunction isNativeClass(thing): boolean {\n\treturn typeof thing === 'function'\n\t\t&& thing.hasOwnProperty('prototype')\n\t\t&& !thing.hasOwnProperty('arguments');\n}\n\nexport function getAllPropertyNames(obj: object): string[] {\n\tlet res: string[] = [];\n\tlet proto = Object.getPrototypeOf(obj);\n\twhile (Object.prototype !== proto) {\n\t\tres = res.concat(Object.getOwnPropertyNames(proto));\n\t\tproto = Object.getPrototypeOf(proto);\n\t}\n\treturn res;\n}\n\n/**\n * Converts null to undefined, passes all other values through.\n */\nexport function withNullAsUndefined<T>(x: T | null): T | undefined {\n\treturn x === null ? undefined : x;\n}\n\n/**\n * Converts undefined to null, passes all other values through.\n */\nexport function withUndefinedAsNull<T>(x: T | undefined): T | null {\n\treturn typeof x === 'undefined' ? null : x;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isObject, isUndefinedOrNull, isArray } from 'vs/base/common/types';\n\nexport function deepClone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tif (obj instanceof RegExp) {\n\t\t// See https://github.com/Microsoft/TypeScript/issues/10990\n\t\treturn obj as any;\n\t}\n\tconst result: any = Array.isArray(obj) ? [] : {};\n\tObject.keys(obj).forEach((key: string) => {\n\t\tif (obj[key] && typeof obj[key] === 'object') {\n\t\t\tresult[key] = deepClone(obj[key]);\n\t\t} else {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function deepFreeze<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tconst stack: any[] = [obj];\n\twhile (stack.length > 0) {\n\t\tconst obj = stack.shift();\n\t\tObject.freeze(obj);\n\t\tfor (const key in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, key)) {\n\t\t\t\tconst prop = obj[key];\n\t\t\t\tif (typeof prop === 'object' && !Object.isFrozen(prop)) {\n\t\t\t\t\tstack.push(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function cloneAndChange(obj: any, changer: (orig: any) => any): any {\n\treturn _cloneAndChange(obj, changer, new Set());\n}\n\nfunction _cloneAndChange(obj: any, changer: (orig: any) => any, seen: Set<any>): any {\n\tif (isUndefinedOrNull(obj)) {\n\t\treturn obj;\n\t}\n\n\tconst changed = changer(obj);\n\tif (typeof changed !== 'undefined') {\n\t\treturn changed;\n\t}\n\n\tif (isArray(obj)) {\n\t\tconst r1: any[] = [];\n\t\tfor (const e of obj) {\n\t\t\tr1.push(_cloneAndChange(e, changer, seen));\n\t\t}\n\t\treturn r1;\n\t}\n\n\tif (isObject(obj)) {\n\t\tif (seen.has(obj)) {\n\t\t\tthrow new Error('Cannot clone recursive data-structure');\n\t\t}\n\t\tseen.add(obj);\n\t\tconst r2 = {};\n\t\tfor (let i2 in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, i2)) {\n\t\t\t\t(r2 as any)[i2] = _cloneAndChange(obj[i2], changer, seen);\n\t\t\t}\n\t\t}\n\t\tseen.delete(obj);\n\t\treturn r2;\n\t}\n\n\treturn obj;\n}\n\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination: any, source: any, overwrite: boolean = true): any {\n\tif (!isObject(destination)) {\n\t\treturn source;\n\t}\n\n\tif (isObject(source)) {\n\t\tObject.keys(source).forEach(key => {\n\t\t\tif (key in destination) {\n\t\t\t\tif (overwrite) {\n\t\t\t\t\tif (isObject(destination[key]) && isObject(source[key])) {\n\t\t\t\t\t\tmixin(destination[key], source[key], overwrite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn destination;\n}\n\nexport function assign<T>(destination: T): T;\nexport function assign<T, U>(destination: T, u: U): T & U;\nexport function assign<T, U, V>(destination: T, u: U, v: V): T & U & V;\nexport function assign<T, U, V, W>(destination: T, u: U, v: V, w: W): T & U & V & W;\nexport function assign(destination: any, ...sources: any[]): any {\n\tsources.forEach(source => Object.keys(source).forEach(key => destination[key] = source[key]));\n\treturn destination;\n}\n\nexport function equals(one: any, other: any): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\tif (one === null || one === undefined || other === null || other === undefined) {\n\t\treturn false;\n\t}\n\tif (typeof one !== typeof other) {\n\t\treturn false;\n\t}\n\tif (typeof one !== 'object') {\n\t\treturn false;\n\t}\n\tif ((Array.isArray(one)) !== (Array.isArray(other))) {\n\t\treturn false;\n\t}\n\n\tlet i: number;\n\tlet key: string;\n\n\tif (Array.isArray(one)) {\n\t\tif (one.length !== other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < one.length; i++) {\n\t\t\tif (!equals(one[i], other[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst oneKeys: string[] = [];\n\n\t\tfor (key in one) {\n\t\t\toneKeys.push(key);\n\t\t}\n\t\toneKeys.sort();\n\t\tconst otherKeys: string[] = [];\n\t\tfor (key in other) {\n\t\t\totherKeys.push(key);\n\t\t}\n\t\totherKeys.sort();\n\t\tif (!equals(oneKeys, otherKeys)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < oneKeys.length; i++) {\n\t\t\tif (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction arrayToHash(array: string[]): { [name: string]: true } {\n\tconst result: any = {};\n\tfor (const e of array) {\n\t\tresult[e] = true;\n\t}\n\treturn result;\n}\n\n/**\n * Given an array of strings, returns a function which, given a string\n * returns true or false whether the string is in that array.\n */\nexport function createKeywordMatcher(arr: string[], caseInsensitive: boolean = false): (str: string) => boolean {\n\tif (caseInsensitive) {\n\t\tarr = arr.map(function (x) { return x.toLowerCase(); });\n\t}\n\tconst hash = arrayToHash(arr);\n\tif (caseInsensitive) {\n\t\treturn function (word) {\n\t\t\treturn hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n\t\t};\n\t} else {\n\t\treturn function (word) {\n\t\t\treturn hash[word] !== undefined && hash.hasOwnProperty(word);\n\t\t};\n\t}\n}\n\n/**\n * Calls JSON.Stringify with a replacer to break apart any circular references.\n * This prevents JSON.stringify from throwing the exception\n *  \"Uncaught TypeError: Converting circular structure to JSON\"\n */\nexport function safeStringify(obj: any): string {\n\tconst seen: any[] = [];\n\treturn JSON.stringify(obj, (key, value) => {\n\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\tif (seen.indexOf(value) !== -1) {\n\t\t\t\treturn '[Circular]';\n\t\t\t} else {\n\t\t\t\tseen.push(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport function getOrDefault<T, R>(obj: T, fn: (obj: T) => R | undefined, defaultValue: R): R {\n\tconst result = fn(obj);\n\treturn typeof result === 'undefined' ? defaultValue : result;\n}\n\ntype obj = { [key: string]: any; };\n/**\n * Returns an object that has keys for each value that is different in the base object. Keys\n * that do not exist in the target but in the base object are not considered.\n *\n * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting\n * object if they differ.\n *\n * @param base the object to diff against\n * @param obj the object to use for diffing\n */\nexport function distinct(base: obj, target: obj): obj {\n\tconst result = Object.create(null);\n\n\tif (!base || !target) {\n\t\treturn result;\n\t}\n\n\tconst targetKeys = Object.keys(target);\n\ttargetKeys.forEach(k => {\n\t\tconst baseValue = base[k];\n\t\tconst targetValue = target[k];\n\n\t\tif (!equals(baseValue, targetValue)) {\n\t\t\tresult[k] = targetValue;\n\t\t}\n\t});\n\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nlet _throwOnMissingSchema: boolean = true;\n\n/**\n * @internal\n */\nexport function setUriThrowOnMissingScheme(value: boolean): boolean {\n\tconst old = _throwOnMissingSchema;\n\t_throwOnMissingSchema = value;\n\treturn old;\n}\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme) {\n\t\tif (_strict || _throwOnMissingSchema) {\n\t\t\t// console.error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t\t} else {\n\t\t\tconsole.warn(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t\t}\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (_strict || _throwOnMissingSchema) {\n\t\treturn scheme || _empty;\n\t}\n\tif (!scheme) {\n\t\tconsole.trace('BAD uri lacks scheme, falling back to file-scheme.');\n\t\tscheme = 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'function'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn _makeFsPath(this);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\tpublic with(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new _URI(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tpublic static parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new _URI(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new _URI(\n\t\t\tmatch[2] || _empty,\n\t\t\tdecodeURIComponent(match[4] || _empty),\n\t\t\tdecodeURIComponent(match[5] || _empty),\n\t\t\tdecodeURIComponent(match[7] || _empty),\n\t\t\tdecodeURIComponent(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tpublic static file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new _URI('file', authority, path, _empty, _empty);\n\t}\n\n\tpublic static from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\treturn new _URI(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\tpublic toJSON(): object {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | any): URI {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new _URI(data);\n\t\t\tresult._fsPath = (<UriState>data).fsPath;\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\tfsPath: string;\n\texternal: string;\n}\n\n\n// tslint:disable-next-line:class-name\nclass _URI extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\tget fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = _makeFsPath(this);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\ttoJSON(): object {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (allowSlash && code === CharCode.Slash)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nfunction _makeFsPath(uri: URI): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\t// windows drive letter: file:///c:/far/boo\n\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.indexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n\t}\n\treturn res;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport function getPathFromAmdModule(requirefn: typeof require, relativePath: string): string {\n\treturn URI.parse(requirefn.toUrl(relativePath)).fsPath;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Iterator, IteratorResult, FIN } from './iterator';\n\nexport function values<V = any>(set: Set<V>): V[];\nexport function values<K = any, V = any>(map: Map<K, V>): V[];\nexport function values<V>(forEachable: { forEach(callback: (value: V, ...more: any[]) => any): void }): V[] {\n\tconst result: V[] = [];\n\tforEachable.forEach(value => result.push(value));\n\treturn result;\n}\n\nexport function keys<K, V>(map: Map<K, V>): K[] {\n\tconst result: K[] = [];\n\tmap.forEach((value, key) => result.push(key));\n\n\treturn result;\n}\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport function mapToSerializable(map: Map<string, string>): [string, string][] {\n\tconst serializable: [string, string][] = [];\n\n\tmap.forEach((value, key) => {\n\t\tserializable.push([key, value]);\n\t});\n\n\treturn serializable;\n}\n\nexport function serializableToMap(serializable: [string, string][]): Map<string, string> {\n\tconst items = new Map<string, string>();\n\n\tfor (const [key, value] of serializable) {\n\t\titems.set(key, value);\n\t}\n\n\treturn items;\n}\n\nexport interface IKeyIterator {\n\treset(key: string): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class PathIterator implements IKeyIterator {\n\n\tprivate _value: string;\n\tprivate _from: number;\n\tprivate _to: number;\n\n\treset(key: string): this {\n\t\tthis._value = key.replace(/\\\\$|\\/$/, '');\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\n\t\tlet aPos = 0;\n\t\tconst aLen = a.length;\n\t\tlet thisPos = this._from;\n\n\t\twhile (aPos < aLen && thisPos < this._to) {\n\t\t\tconst cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n\t\t\tif (cmp !== 0) {\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t\taPos += 1;\n\t\t\tthisPos += 1;\n\t\t}\n\n\t\tif (aLen === this._to - this._from) {\n\t\t\treturn 0;\n\t\t} else if (aPos < aLen) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nclass TernarySearchTreeNode<E> {\n\tsegment: string;\n\tvalue: E | undefined;\n\tkey: string;\n\tleft: TernarySearchTreeNode<E> | undefined;\n\tmid: TernarySearchTreeNode<E> | undefined;\n\tright: TernarySearchTreeNode<E> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n}\n\nexport class TernarySearchTree<E> {\n\n\tstatic forPaths<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new PathIterator());\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<E> {\n\t\treturn new TernarySearchTree<E>(new StringIterator());\n\t}\n\n\tprivate _iter: IKeyIterator;\n\tprivate _root: TernarySearchTreeNode<E> | undefined;\n\n\tconstructor(segments: IKeyIterator) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\tset(key: string, element: E): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<E>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<E>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<E>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\t\treturn oldElement;\n\t}\n\n\tget(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node ? node.value : undefined;\n\t}\n\n\tdelete(key: string): void {\n\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [-1 | 0 | 1, TernarySearchTreeNode<E>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find and unset node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([1, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([-1, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([0, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// remove element\n\t\t\t\tnode.value = undefined;\n\n\t\t\t\t// clean up empty nodes\n\t\t\t\twhile (stack.length > 0 && node.isEmpty()) {\n\t\t\t\t\tlet [dir, parent] = stack.pop()!;\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase 1: parent.left = undefined; break;\n\t\t\t\t\t\tcase 0: parent.mid = undefined; break;\n\t\t\t\t\t\tcase -1: parent.right = undefined; break;\n\t\t\t\t\t}\n\t\t\t\t\tnode = parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindSubstr(key: string): E | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: E | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: string): Iterator<E> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._nodeIterator(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _nodeIterator(node: TernarySearchTreeNode<E>): Iterator<E> {\n\t\tlet res: { done: false; value: E; };\n\t\tlet idx: number;\n\t\tlet data: E[];\n\t\tconst next = (): IteratorResult<E> => {\n\t\t\tif (!data) {\n\t\t\t\t// lazy till first invocation\n\t\t\t\tdata = [];\n\t\t\t\tidx = 0;\n\t\t\t\tthis._forEach(node, value => data.push(value));\n\t\t\t}\n\t\t\tif (idx >= data.length) {\n\t\t\t\treturn FIN;\n\t\t\t}\n\n\t\t\tif (!res) {\n\t\t\t\tres = { done: false, value: data[idx++] };\n\t\t\t} else {\n\t\t\t\tres.value = data[idx++];\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t\treturn { next };\n\t}\n\n\tforEach(callback: (value: E, index: string) => any) {\n\t\tthis._forEach(this._root, callback);\n\t}\n\n\tprivate _forEach(node: TernarySearchTreeNode<E> | undefined, callback: (value: E, index: string) => any) {\n\t\tif (node) {\n\t\t\t// left\n\t\t\tthis._forEach(node.left, callback);\n\n\t\t\t// node\n\t\t\tif (node.value) {\n\t\t\t\t// callback(node.value, this._iter.join(parts));\n\t\t\t\tcallback(node.value, node.key);\n\t\t\t}\n\t\t\t// mid\n\t\t\tthis._forEach(node.mid, callback);\n\n\t\t\t// right\n\t\t\tthis._forEach(node.right, callback);\n\t\t}\n\t}\n}\n\nexport class ResourceMap<T> {\n\n\tprotected readonly map: Map<string, T>;\n\tprotected readonly ignoreCase?: boolean;\n\n\tconstructor() {\n\t\tthis.map = new Map<string, T>();\n\t\tthis.ignoreCase = false; // in the future this should be an uri-comparator\n\t}\n\n\tset(resource: URI, value: T): void {\n\t\tthis.map.set(this.toKey(resource), value);\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource));\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T) => void): void {\n\t\tthis.map.forEach(clb);\n\t}\n\n\tvalues(): T[] {\n\t\treturn values(this.map);\n\t}\n\n\tprivate toKey(resource: URI): string {\n\t\tlet key = resource.toString();\n\t\tif (this.ignoreCase) {\n\t\t\tkey = key.toLowerCase();\n\t\t}\n\n\t\treturn key;\n\t}\n\n\tkeys(): URI[] {\n\t\treturn keys(this.map).map(k => URI.parse(k));\n\t}\n\n\tclone(): ResourceMap<T> {\n\t\tconst resourceMap = new ResourceMap<T>();\n\n\t\tthis.map.forEach((value, key) => resourceMap.map.set(key, value));\n\n\t\treturn resourceMap;\n\t}\n}\n\n// We should fold BoundedMap and LinkedMap. See https://github.com/Microsoft/vscode/issues/28496\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> {\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): void {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tvalues(): V[] {\n\t\tconst result: V[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.value);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\tkeys(): K[] {\n\t\tconst result: K[] = [];\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tresult.push(current.key);\n\t\t\tcurrent = current.next;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n\tkeys(): IterableIterator<K> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<K> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext():IteratorResult<V> {\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\t*/\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happend if size === 1 which is handle\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn super.get(key, Touch.AsNew);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\tset(key: K, value: V): void {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as strings from 'vs/base/common/strings';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { LRUCache } from 'vs/base/common/map';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isThenable } from 'vs/base/common/async';\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause | any;\n}\n\nexport interface IRelativePattern {\n\tbase: string;\n\tpattern: string;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tfor (const char of segment) {\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t// range operator\n\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\tres = char;\n\t\t\t\t\t}\n\n\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\tres = '^';\n\t\t\t\t\t}\n\n\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n\t\t\t// a folder called \"something\" to match as well.\n\t\t\t// However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n\t\t\t// is to match 0-N segments.\n\t\t\tif (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t   \t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t   \t\t\t// **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; \t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t   \t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t   \t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The ParsedExpression returns a Promise iff hasSibling returns a Promise.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\nexport interface IGlobOptions {\n\t/**\n\t * Simplify patterns for use as exclusion filters during tree traversal to skip entire subtrees. Cannot be used outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\ninterface ParsedExpressionPattern {\n\t(path: string, basename: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle IRelativePattern\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivias\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n\t\tconst base = pattern.substr(4); // '**/*'.length === 4\n\t\tparsedPattern = function (path, basename) {\n\t\t\treturn typeof path === 'string' && strings.endsWith(path, base) ? pattern : null;\n\t\t};\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\treturn function (path, basename) {\n\t\tif (!extpath.isEqualOrParent(path, arg2.base)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn parsedPattern(paths.relative(arg2.base, path), basename);\n\t};\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, originalPattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\tconst parsedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (basename) {\n\t\t\treturn basename === base ? originalPattern : null;\n\t\t}\n\t\treturn path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n\t};\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [originalPattern];\n\tparsedPattern.allBasenames = basenames;\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\tif (n === 1) {\n\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t}\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif ((<ParsedStringPattern>parsedPatterns[i])(path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n\tconst nativePathEnd = paths.sep + nativePath;\n\tconst parsedPattern: ParsedStringPattern = matchPathEnds ? function (path, basename) {\n\t\treturn typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n\t} : function (path, basename) {\n\t\treturn typeof path === 'string' && path === nativePath ? pattern : null;\n\t};\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string, basename: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): any {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(<IExpression>arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): any {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1 as string | IRelativePattern, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst resultPattern = function (path: string, basename: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\t\tif (parsedPattern.allBasenames) {\n\t\t\t(<ParsedStringPattern><any>resultPattern).allBasenames = parsedPattern.allBasenames;\n\t\t}\n\t\tif (parsedPattern.allPaths) {\n\t\t\t(<ParsedStringPattern><any>resultPattern).allPaths = parsedPattern.allPaths;\n\t\t}\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function hasSiblingPromiseFn(siblingsFn?: () => Promise<string[]>) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Promise<Record<string, true>>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tsiblings = (siblingsFn() || Promise.resolve([]))\n\t\t\t\t.then(list => list ? listToMap(list) : {});\n\t\t}\n\t\treturn siblings.then(map => !!map[name]);\n\t};\n}\n\nexport function hasSiblingFn(siblingsFn?: () => string[]) {\n\tif (!siblingsFn) {\n\t\treturn undefined;\n\t}\n\n\tlet siblings: Record<string, true>;\n\treturn (name: string) => {\n\t\tif (!siblings) {\n\t\t\tconst list = siblingsFn();\n\t\t\tsiblings = list ? listToMap(list) : {};\n\t\t}\n\t\treturn !!siblings[name];\n\t};\n}\n\nfunction listToMap(list: string[]) {\n\tconst map: Record<string, true> = {};\n\tfor (const key of list) {\n\t\tmap[key] = true;\n\t}\n\treturn map;\n}\n\nexport function isRelativePattern(obj: any): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern;\n\n\treturn rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\n/**\n * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise\n */\nexport function parseToAsync(expression: IExpression, options?: IGlobOptions): ParsedExpression {\n\tconst parsedExpression = parse(expression, options);\n\treturn (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> => {\n\t\tconst result = parsedExpression(path, basename, hasSibling);\n\t\treturn isThenable(result) ? result : Promise.resolve(result);\n\t};\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst n = parsedPatterns.length;\n\tif (!n) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (n === 1) {\n\t\t\treturn <ParsedStringPattern>parsedPatterns[0];\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string) {\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\t// Pattern matches path\n\t\t\t\tconst result = (<ParsedStringPattern>parsedPatterns[i])(path, basename);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, basename: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = paths.basename(path);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = basename.substr(0, basename.length - paths.extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result = parsedPattern(path, basename, name, hasSibling);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = arrays.first(parsedPatterns, pattern => !!(<ParsedStringPattern>pattern).allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = (<ParsedStringPattern>withBasenames).allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, <string[]>[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = (<SiblingClause>value).when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename: string, name: string, hasSibling: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(m => m ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\t\t\tresult.requiresSiblings = true;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is Anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, <string[]>[]);\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, <string[]>[]);\n\t}\n\tconst aggregate: ParsedStringPattern = function (path, basename) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbasename = path.substr(i);\n\t\t}\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\treturn aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCache } from 'vs/base/common/map';\n\n/**\n * The normalize() method returns the Unicode Normalization Form of a given string. The form will be\n * the Normalization Form Canonical Composition.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}\n */\nexport const canNormalize = typeof ((<any>'').normalize) === 'function';\n\nconst nfcCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFC(str: string): string {\n\treturn normalize(str, 'NFC', nfcCache);\n}\n\nconst nfdCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFD(str: string): string {\n\treturn normalize(str, 'NFD', nfdCache);\n}\n\nconst nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nfunction normalize(str: string, form: string, normalizedCache: LRUCache<string, string>): string {\n\tif (!canNormalize || !str) {\n\t\treturn str;\n\t}\n\n\tconst cached = normalizedCache.get(str);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tlet res: string;\n\tif (nonAsciiCharactersPattern.test(str)) {\n\t\tres = (<any>str).normalize(form);\n\t} else {\n\t\tres = str;\n\t}\n\n\t// Use the cache for fast lookup\n\tnormalizedCache.set(str, res);\n\n\treturn res;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { equalsIgnoreCase } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ParsedExpression, IExpression, parse } from 'vs/base/common/glob';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport function getComparisonKey(resource: URI): string {\n\treturn hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();\n}\n\nexport function hasToIgnoreCase(resource: URI | undefined): boolean {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\n\nexport function basenameOrAuthority(resource: URI): string {\n\treturn basename(resource) || resource.authority;\n}\n\n/**\n * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n * @param base A uri which is \"longer\"\n * @param parentCandidate A uri which is \"shorter\" then `base`\n */\nexport function isEqualOrParent(base: URI, parentCandidate: URI, ignoreCase = hasToIgnoreCase(base)): boolean {\n\tif (base.scheme === parentCandidate.scheme) {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase);\n\t\t}\n\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Tests wheter the two authorities are the same\n */\nexport function isEqualAuthority(a1: string, a2: string) {\n\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n}\n\nexport function isEqual(first: URI | undefined, second: URI | undefined, ignoreCase = hasToIgnoreCase(first)): boolean {\n\tif (first === second) {\n\t\treturn true;\n\t}\n\n\tif (!first || !second) {\n\t\treturn false;\n\t}\n\n\tif (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n\t\treturn false;\n\t}\n\n\tconst p1 = first.path || '/', p2 = second.path || '/';\n\treturn p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\n}\n\nexport function basename(resource: URI): string {\n\treturn paths.posix.basename(resource.path);\n}\n\nexport function extname(resource: URI): string {\n\treturn paths.posix.extname(resource.path);\n}\n\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\nexport function dirname(resource: URI): URI {\n\tif (resource.path.length === 0) {\n\t\treturn resource;\n\t}\n\tif (resource.scheme === Schemas.file) {\n\t\treturn URI.file(paths.dirname(originalFSPath(resource)));\n\t}\n\tlet dirname = paths.posix.dirname(resource.path);\n\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t}\n\treturn resource.with({\n\t\tpath: dirname\n\t});\n}\n\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\nexport function joinPath(resource: URI, ...pathFragment: string[]): URI {\n\tlet joinedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tjoinedPath = URI.file(paths.join(originalFSPath(resource), ...pathFragment)).path;\n\t} else {\n\t\tjoinedPath = paths.posix.join(resource.path || '/', ...pathFragment);\n\t}\n\treturn resource.with({\n\t\tpath: joinedPath\n\t});\n}\n\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\nexport function normalizePath(resource: URI): URI {\n\tif (!resource.path.length) {\n\t\treturn resource;\n\t}\n\tlet normalizedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t} else {\n\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t}\n\treturn resource.with({\n\t\tpath: normalizedPath\n\t});\n}\n\n/**\n * Returns the fsPath of an URI where the drive letter is not normalized.\n * See #56403.\n */\nexport function originalFSPath(uri: URI): string {\n\tlet value: string;\n\tconst uriPath = uri.path;\n\tif (uri.authority && uriPath.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uriPath}`;\n\t} else if (\n\t\tisWindows\n\t\t&& uriPath.charCodeAt(0) === CharCode.Slash\n\t\t&& extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n\t\t&& uriPath.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tvalue = uriPath.substr(1);\n\t} else {\n\t\t// other path\n\t\tvalue = uriPath;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Returns true if the URI path is absolute.\n */\nexport function isAbsolutePath(resource: URI): boolean {\n\treturn !!resource.path && resource.path[0] === '/';\n}\n\n/**\n * Returns true if the URI path has a trailing path separator\n */\nexport function hasTrailingPathSeparator(resource: URI): boolean {\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === paths.sep;\n\t} else {\n\t\tconst p = resource.path;\n\t\treturn p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash; // ignore the slash at offset 0\n\t}\n}\n\n\n/**\n * Removes a trailing path seperator, if theres one.\n * Important: Doesn't remove the first slash, it would make the URI invalid\n */\nexport function removeTrailingPathSeparator(resource: URI): URI {\n\tif (hasTrailingPathSeparator(resource)) {\n\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t}\n\treturn resource;\n}\n\n\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\nexport function relativePath(from: URI, to: URI): string | undefined {\n\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\treturn undefined;\n\t}\n\tif (from.scheme === Schemas.file) {\n\t\tconst relativePath = paths.relative(from.path, to.path);\n\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t}\n\treturn paths.posix.relative(from.path || '/', to.path || '/');\n}\n\n/**\n * Resolves a absolute or relative path against a base URI.\n */\nexport function resolvePath(base: URI, path: string): URI {\n\tlet resolvedPath: string;\n\tif (base.scheme === Schemas.file) {\n\t\tresolvedPath = URI.file(paths.resolve(originalFSPath(base), path)).path;\n\t} else {\n\t\tresolvedPath = paths.posix.resolve(base.path, path);\n\t}\n\treturn base.with({\n\t\tpath: resolvedPath\n\t});\n}\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\n\nexport class ResourceGlobMatcher {\n\n\tprivate readonly globalExpression: ParsedExpression;\n\tprivate readonly expressionsByRoot: TernarySearchTree<{ root: URI, expression: ParsedExpression }> = TernarySearchTree.forPaths<{ root: URI, expression: ParsedExpression }>();\n\n\tconstructor(\n\t\tglobalExpression: IExpression,\n\t\trootExpressions: { root: URI, expression: IExpression }[]\n\t) {\n\t\tthis.globalExpression = parse(globalExpression);\n\t\tfor (const expression of rootExpressions) {\n\t\t\tthis.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: parse(expression.expression) });\n\t\t}\n\t}\n\n\tmatches(resource: URI): boolean {\n\t\tconst rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n\t\tif (rootExpression) {\n\t\t\tconst path = relativePath(rootExpression.root, resource);\n\t\t\tif (path && !!rootExpression.expression(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn !!this.globalExpression(resource.path);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents a UUID as defined by rfc4122.\n */\nexport interface UUID {\n\n\t/**\n\t * @returns the canonical representation in sets of hexadecimal numbers separated by dashes.\n\t */\n\tasHex(): string;\n}\n\nclass ValueUUID implements UUID {\n\n\tconstructor(public _value: string) {\n\t\t// empty\n\t}\n\n\tpublic asHex(): string {\n\t\treturn this._value;\n\t}\n}\n\nclass V4UUID extends ValueUUID {\n\n\tprivate static readonly _chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\tprivate static readonly _timeHighBits = ['8', '9', 'a', 'b'];\n\n\tprivate static _oneOf(array: string[]): string {\n\t\treturn array[Math.floor(array.length * Math.random())];\n\t}\n\n\tprivate static _randomHex(): string {\n\t\treturn V4UUID._oneOf(V4UUID._chars);\n\t}\n\n\tconstructor() {\n\t\tsuper([\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\t'4',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._oneOf(V4UUID._timeHighBits),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t].join(''));\n\t}\n}\n\nexport function v4(): UUID {\n\treturn new V4UUID();\n}\n\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\nexport function isUUID(value: string): boolean {\n\treturn _UUIDPattern.test(value);\n}\n\n/**\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\n * @param value A uuid string.\n */\nexport function parse(value: string): UUID {\n\tif (!isUUID(value)) {\n\t\tthrow new Error('invalid uuid');\n\t}\n\n\treturn new ValueUUID(value);\n}\n\nexport function generateUuid(): string {\n\treturn v4().asHex();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IRemoteConsoleLog {\n\ttype: string;\n\tseverity: string;\n\targuments: string;\n}\n\ninterface IStackArgument {\n\t__$stack: string;\n}\n\nexport interface IStackFrame {\n\turi: URI;\n\tline: number;\n\tcolumn: number;\n}\n\nexport function isRemoteConsoleLog(obj: any): obj is IRemoteConsoleLog {\n\tconst entry = obj as IRemoteConsoleLog;\n\n\treturn entry && typeof entry.type === 'string' && typeof entry.severity === 'string';\n}\n\nexport function parse(entry: IRemoteConsoleLog): { args: any[], stack?: string } {\n\tconst args: any[] = [];\n\tlet stack: string | undefined;\n\n\t// Parse Entry\n\ttry {\n\t\tconst parsedArguments: any[] = JSON.parse(entry.arguments);\n\n\t\t// Check for special stack entry as last entry\n\t\tconst stackArgument = parsedArguments[parsedArguments.length - 1] as IStackArgument;\n\t\tif (stackArgument && stackArgument.__$stack) {\n\t\t\tparsedArguments.pop(); // stack is handled specially\n\t\t\tstack = stackArgument.__$stack;\n\t\t}\n\n\t\targs.push(...parsedArguments);\n\t} catch (error) {\n\t\targs.push('Unable to log remote console arguments', entry.arguments);\n\t}\n\n\treturn { args, stack };\n}\n\nexport function getFirstFrame(entry: IRemoteConsoleLog): IStackFrame | undefined;\nexport function getFirstFrame(stack: string | undefined): IStackFrame | undefined;\nexport function getFirstFrame(arg0: IRemoteConsoleLog | string | undefined): IStackFrame | undefined {\n\tif (typeof arg0 !== 'string') {\n\t\treturn getFirstFrame(parse(arg0!).stack);\n\t}\n\n\t// Parse a source information out of the stack if we have one. Format can be:\n\t// at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)\n\t// or\n\t// at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17\n\t// or\n\t// at c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17\n\t// or\n\t// at e.$executeContributedCommand(c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17)\n\tconst stack = arg0;\n\tif (stack) {\n\t\tconst topFrame = findFirstFrame(stack);\n\n\t\t// at [^\\/]* => line starts with \"at\" followed by any character except '/' (to not capture unix paths too late)\n\t\t// (?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\) => windows drive letter OR unix root OR unc root\n\t\t// (?:.+) => simple pattern for the path, only works because of the line/col pattern after\n\t\t// :(?:\\d+):(?:\\d+) => :line:column data\n\t\tconst matches = /at [^\\/]*((?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\))(?:.+)):(\\d+):(\\d+)/.exec(topFrame || '');\n\t\tif (matches && matches.length === 4) {\n\t\t\treturn {\n\t\t\t\turi: URI.file(matches[1]),\n\t\t\t\tline: Number(matches[2]),\n\t\t\t\tcolumn: Number(matches[3])\n\t\t\t} as IStackFrame;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction findFirstFrame(stack: string | undefined): string | undefined {\n\tif (!stack) {\n\t\treturn stack;\n\t}\n\n\tconst newlineIndex = stack.indexOf('\\n');\n\tif (newlineIndex === -1) {\n\t\treturn stack;\n\t}\n\n\treturn stack.substring(0, newlineIndex);\n}\n\nexport function log(entry: IRemoteConsoleLog, label: string): void {\n\tconst { args, stack } = parse(entry);\n\n\tconst isOneStringArg = typeof args[0] === 'string' && args.length === 1;\n\n\tlet topFrame = findFirstFrame(stack);\n\tif (topFrame) {\n\t\ttopFrame = `(${topFrame.trim()})`;\n\t}\n\n\tlet consoleArgs: string[] = [];\n\n\t// First arg is a string\n\tif (typeof args[0] === 'string') {\n\t\tif (topFrame && isOneStringArg) {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color('black'), color('grey')];\n\t\t} else {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color('black'), ...args.slice(1)];\n\t\t}\n\t}\n\n\t// First arg is something else, just apply all\n\telse {\n\t\tconsoleArgs = [`%c[${label}]%`, color('blue'), ...args];\n\t}\n\n\t// Stack: add to args unless already aded\n\tif (topFrame && !isOneStringArg) {\n\t\tconsoleArgs.push(topFrame);\n\t}\n\n\t// Log it\n\tconsole[entry.severity].apply(console, consoleArgs);\n}\n\nfunction color(color: string): string {\n\treturn `color: ${color}`;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as sd from 'string_decoder';\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * Convenient way to iterate over output line by line. This helper accommodates for the fact that\n * a buffer might not end with new lines all the way.\n *\n * To use:\n * - call the write method\n * - forEach() over the result to get the lines\n */\nexport class LineDecoder {\n\tprivate stringDecoder: sd.NodeStringDecoder;\n\tprivate remaining: string | null;\n\n\tconstructor(encoding: string = 'utf8') {\n\t\tthis.stringDecoder = new sd.StringDecoder(encoding);\n\t\tthis.remaining = null;\n\t}\n\n\tpublic write(buffer: Buffer): string[] {\n\t\tconst result: string[] = [];\n\t\tconst value = this.remaining\n\t\t\t? this.remaining + this.stringDecoder.write(buffer)\n\t\t\t: this.stringDecoder.write(buffer);\n\n\t\tif (value.length < 1) {\n\t\t\treturn result;\n\t\t}\n\t\tlet start = 0;\n\t\tlet ch: number;\n\t\tlet idx = start;\n\t\twhile (idx < value.length) {\n\t\t\tch = value.charCodeAt(idx);\n\t\t\tif (ch === CharCode.CarriageReturn || ch === CharCode.LineFeed) {\n\t\t\t\tresult.push(value.substring(start, idx));\n\t\t\t\tidx++;\n\t\t\t\tif (idx < value.length) {\n\t\t\t\t\tconst lastChar = ch;\n\t\t\t\t\tch = value.charCodeAt(idx);\n\t\t\t\t\tif ((lastChar === CharCode.CarriageReturn && ch === CharCode.LineFeed) || (lastChar === CharCode.LineFeed && ch === CharCode.CarriageReturn)) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = idx;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tthis.remaining = start < value.length ? value.substr(start) : null;\n\t\treturn result;\n\t}\n\n\tpublic end(): string | null {\n\t\treturn this.remaining;\n\t}\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as assert from 'assert';\n\n/**\n * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as\n * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.\n */\nexport function parallel<T, E>(list: T[], fn: (item: T, callback: (err: Error | null, result: E | null) => void) => void, callback: (err: Array<Error | null> | null, result: E[]) => void): void {\n\tconst results = new Array(list.length);\n\tconst errors = new Array<Error | null>(list.length);\n\tlet didErrorOccur = false;\n\tlet doneCount = 0;\n\n\tif (list.length === 0) {\n\t\treturn callback(null, []);\n\t}\n\n\tlist.forEach((item, index) => {\n\t\tfn(item, (error, result) => {\n\t\t\tif (error) {\n\t\t\t\tdidErrorOccur = true;\n\t\t\t\tresults[index] = null;\n\t\t\t\terrors[index] = error;\n\t\t\t} else {\n\t\t\t\tresults[index] = result;\n\t\t\t\terrors[index] = null;\n\t\t\t}\n\n\t\t\tif (++doneCount === list.length) {\n\t\t\t\treturn callback(didErrorOccur ? errors : null, results);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Executes the given function (fn) over the given array of items (param) in sequential order and returns the first occurred error or the result as\n * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function. The first param can\n * either be a function that returns an array of results to loop in async fashion or be an array of items already.\n */\nexport function loop<T, E>(param: (callback: (error: Error, result: T[]) => void) => void, fn: (item: T, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void;\nexport function loop<T, E>(param: T[], fn: (item: T, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void;\nexport function loop<E>(param: any, fn: (item: any, callback: (error: Error | null, result: E | null) => void, index: number, total: number) => void, callback: (error: Error | null, result: E[] | null) => void): void {\n\n\t// Assert\n\tassert.ok(param, 'Missing first parameter');\n\tassert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');\n\tassert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');\n\n\t// Param is function, execute to retrieve array\n\tif (typeof (param) === 'function') {\n\t\ttry {\n\t\t\tparam((error: Error, result: E[]) => {\n\t\t\t\tif (error) {\n\t\t\t\t\tcallback(error, null);\n\t\t\t\t} else {\n\t\t\t\t\tloop(result, fn, callback);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tcallback(error, null);\n\t\t}\n\t}\n\n\t// Expect the param to be an array and loop over it\n\telse {\n\t\tconst results: E[] = [];\n\n\t\tconst looper: (i: number) => void = function (i: number): void {\n\n\t\t\t// Still work to do\n\t\t\tif (i < param.length) {\n\n\t\t\t\t// Execute function on array element\n\t\t\t\ttry {\n\t\t\t\t\tfn(param[i], (error: any, result: E) => {\n\n\t\t\t\t\t\t// A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n\t\t\t\t\t\tif (error === true || error === false) {\n\t\t\t\t\t\t\tresult = error;\n\t\t\t\t\t\t\terror = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Quit looping on error\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\tcallback(error, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise push result on stack and continue looping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (result) { //Could be that provided function is not returning a result\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\t\t\t\tlooper(i + 1);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, i, param.length);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcallback(error, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Done looping, pass back results too callback function\n\t\t\telse {\n\t\t\t\tcallback(null, results);\n\t\t\t}\n\t\t};\n\n\t\t// Start looping with first element in array\n\t\tlooper(0);\n\t}\n}\n\nfunction Sequence(sequences: { (...param: any[]): void; }[]): void {\n\n\t// Assert\n\tassert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');\n\tsequences.forEach((sequence) => {\n\t\tassert.ok(typeof (sequence) === 'function');\n\t});\n\n\t// Execute in Loop\n\tconst errorHandler = sequences.splice(0, 1)[0]; //Remove error handler\n\tlet sequenceResult: any = null;\n\n\tloop(sequences, (sequence, clb) => {\n\t\tconst sequenceFunction = function (error: any, result: any): void {\n\n\t\t\t// A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully\n\t\t\tif (error === true || error === false) {\n\t\t\t\tresult = error;\n\t\t\t\terror = null;\n\t\t\t}\n\n\t\t\t// Handle Error and Result\n\t\t\tif (error) {\n\t\t\t\tclb(error, null);\n\t\t\t} else {\n\t\t\t\tsequenceResult = result; //Remember result of sequence\n\t\t\t\tclb(null, null); //Don't pass on result to Looper as we are not aggregating it\n\t\t\t}\n\t\t};\n\n\t\t// We call the sequence function setting \"this\" to be the callback we define here\n\t\t// and we pass in the \"sequenceResult\" as first argument. Doing all this avoids having\n\t\t// to pass in a callback to the sequence because the callback is already \"this\".\n\t\ttry {\n\t\t\tsequence.call(sequenceFunction, sequenceResult);\n\t\t} catch (error) {\n\t\t\tclb(error, null);\n\t\t}\n\t}, (error, result) => {\n\t\tif (error) {\n\t\t\terrorHandler(error);\n\t\t}\n\t});\n}\n\n/**\n * Takes a variable list of functions to execute in sequence. The first function must be the error handler and the\n * following functions can do arbitrary work. \"this\" must be used as callback value for async functions to continue\n * through the sequence:\n * \tsequence(\n * \t\tfunction errorHandler(error) {\n * \t\t\tclb(error, null);\n * \t\t},\n *\n * \t\tfunction doSomethingAsync() {\n * \t\t\tfs.doAsync(path, this);\n * \t\t},\n *\n * \t\tfunction done(result) {\n * \t\t\tclb(null, result);\n * \t\t}\n * \t);\n */\nexport function sequence(errorHandler: (error: Error) => void, ...sequences: Function[]): void;\nexport function sequence(sequences: Function[]): void;\nexport function sequence(sequences: any): void {\n\tSequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\n\nexport interface ReadResult {\n\tbuffer: Buffer | null;\n\tbytesRead: number;\n}\n\n/**\n * Reads totalBytes from the provided file.\n */\nexport function readExactlyByFile(file: string, totalBytes: number): Promise<ReadResult> {\n\treturn new Promise<ReadResult>((resolve, reject) => {\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, resultBuffer: Buffer | null, bytesRead: number): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ buffer: resultBuffer, bytesRead });\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(totalBytes);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, totalBytes - offset, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tif (offset === totalBytes) {\n\t\t\t\t\t\treturn end(null, buffer, offset);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t});\n\t});\n}\n\n/**\n * Reads a file until a matching string is found.\n *\n * @param file The file to read.\n * @param matchingString The string to search for.\n * @param chunkBytes The number of bytes to read each iteration.\n * @param maximumBytesToRead The maximum number of bytes to read before giving up.\n * @param callback The finished callback.\n */\nexport function readToMatchingString(file: string, matchingString: string, chunkBytes: number, maximumBytesToRead: number): Promise<string | null> {\n\treturn new Promise<string | null>((resolve, reject) =>\n\t\tfs.open(file, 'r', null, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\tfunction end(err: Error | null, result: string | null): void {\n\t\t\t\tfs.close(fd, closeError => {\n\t\t\t\t\tif (closeError) {\n\t\t\t\t\t\treturn reject(closeError);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err && (<any>err).code === 'EISDIR') {\n\t\t\t\t\t\treturn reject(err); // we want to bubble this error up (file is actually a folder)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve(result);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst buffer = Buffer.allocUnsafe(maximumBytesToRead);\n\t\t\tlet offset = 0;\n\n\t\t\tfunction readChunk(): void {\n\t\t\t\tfs.read(fd, buffer, offset, chunkBytes, null, (err, bytesRead) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn end(err, null);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bytesRead === 0) {\n\t\t\t\t\t\treturn end(null, null);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bytesRead;\n\n\t\t\t\t\tconst newLineIndex = buffer.indexOf(matchingString);\n\t\t\t\t\tif (newLineIndex >= 0) {\n\t\t\t\t\t\treturn end(null, buffer.toString('utf8').substr(0, newLineIndex));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (offset >= maximumBytesToRead) {\n\t\t\t\t\t\treturn end(new Error(`Could not find ${matchingString} in first ${maximumBytesToRead} bytes of ${file}`), null);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn readChunk();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treadChunk();\n\t\t})\n\t);\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as stream from 'vs/base/node/stream';\nimport * as iconv from 'iconv-lite';\nimport { isLinux, isMacintosh } from 'vs/base/common/platform';\nimport { exec } from 'child_process';\nimport { Readable, Writable } from 'stream';\n\nexport const UTF8 = 'utf8';\nexport const UTF8_with_bom = 'utf8bom';\nexport const UTF16be = 'utf16be';\nexport const UTF16le = 'utf16le';\n\nexport interface IDecodeStreamOptions {\n\tguessEncoding?: boolean;\n\tminBytesRequiredForDetection?: number;\n\toverwriteEncoding?(detectedEncoding: string | null): string;\n}\n\nexport function toDecodeStream(readable: Readable, options: IDecodeStreamOptions): Promise<{ detected: IDetectedEncodingResult, stream: NodeJS.ReadableStream }> {\n\tif (!options.minBytesRequiredForDetection) {\n\t\toptions.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;\n\t}\n\n\tif (!options.overwriteEncoding) {\n\t\toptions.overwriteEncoding = detected => detected || UTF8;\n\t}\n\n\treturn new Promise<{ detected: IDetectedEncodingResult, stream: NodeJS.ReadableStream }>((resolve, reject) => {\n\n\t\treadable.on('error', reject);\n\n\t\treadable.pipe(new class extends Writable {\n\n\t\t\tprivate _decodeStream: NodeJS.ReadWriteStream;\n\t\t\tprivate _decodeStreamConstruction: Promise<any>;\n\t\t\tprivate _buffer: Buffer[] = [];\n\t\t\tprivate _bytesBuffered = 0;\n\n\t\t\t_write(chunk: any, encoding: string, callback: Function): void {\n\t\t\t\tif (!Buffer.isBuffer(chunk)) {\n\t\t\t\t\tcallback(new Error('data must be a buffer'));\n\t\t\t\t}\n\n\t\t\t\tif (this._decodeStream) {\n\t\t\t\t\t// just a forwarder now\n\t\t\t\t\tthis._decodeStream.write(chunk, callback);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._buffer.push(chunk);\n\t\t\t\tthis._bytesBuffered += chunk.length;\n\n\t\t\t\tif (this._decodeStreamConstruction) {\n\t\t\t\t\t// waiting for the decoder to be ready\n\t\t\t\t\tthis._decodeStreamConstruction.then(_ => callback(), err => callback(err));\n\n\t\t\t\t} else if (typeof options.minBytesRequiredForDetection === 'number' && this._bytesBuffered >= options.minBytesRequiredForDetection) {\n\t\t\t\t\t// buffered enough data, create stream and forward data\n\t\t\t\t\tthis._startDecodeStream(callback);\n\n\t\t\t\t} else {\n\t\t\t\t\t// only buffering\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_startDecodeStream(callback: Function): void {\n\n\t\t\t\tthis._decodeStreamConstruction = Promise.resolve(detectEncodingFromBuffer({\n\t\t\t\t\tbuffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered\n\t\t\t\t}, options.guessEncoding)).then(detected => {\n\t\t\t\t\tif (options.overwriteEncoding) {\n\t\t\t\t\t\tdetected.encoding = options.overwriteEncoding(detected.encoding);\n\t\t\t\t\t}\n\t\t\t\t\tthis._decodeStream = decodeStream(detected.encoding);\n\t\t\t\t\tfor (const buffer of this._buffer) {\n\t\t\t\t\t\tthis._decodeStream.write(buffer);\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t\tresolve({ detected, stream: this._decodeStream });\n\n\t\t\t\t}, err => {\n\t\t\t\t\tthis.emit('error', err);\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_final(callback: (err?: any) => any) {\n\t\t\t\tif (this._decodeStream) {\n\t\t\t\t\t// normal finish\n\t\t\t\t\tthis._decodeStream.end(callback);\n\t\t\t\t} else {\n\t\t\t\t\t// we were still waiting for data...\n\t\t\t\t\tthis._startDecodeStream(() => this._decodeStream.end(callback));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport function bomLength(encoding: string): number {\n\tswitch (encoding) {\n\t\tcase UTF8:\n\t\t\treturn 3;\n\t\tcase UTF16be:\n\t\tcase UTF16le:\n\t\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n\nexport function decode(buffer: Buffer, encoding: string): string {\n\treturn iconv.decode(buffer, toNodeEncoding(encoding));\n}\n\nexport function encode(content: string | Buffer, encoding: string, options?: { addBOM?: boolean }): Buffer {\n\treturn iconv.encode(content, toNodeEncoding(encoding), options);\n}\n\nexport function encodingExists(encoding: string): boolean {\n\treturn iconv.encodingExists(toNodeEncoding(encoding));\n}\n\nexport function decodeStream(encoding: string | null): NodeJS.ReadWriteStream {\n\treturn iconv.decodeStream(toNodeEncoding(encoding));\n}\n\nexport function encodeStream(encoding: string, options?: { addBOM?: boolean }): NodeJS.ReadWriteStream {\n\treturn iconv.encodeStream(toNodeEncoding(encoding), options);\n}\n\nfunction toNodeEncoding(enc: string | null): string {\n\tif (enc === UTF8_with_bom || enc === null) {\n\t\treturn UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n\t}\n\n\treturn enc;\n}\n\nexport function detectEncodingByBOMFromBuffer(buffer: Buffer | null, bytesRead: number): string | null {\n\tif (!buffer || bytesRead < 2) {\n\t\treturn null;\n\t}\n\n\tconst b0 = buffer.readUInt8(0);\n\tconst b1 = buffer.readUInt8(1);\n\n\t// UTF-16 BE\n\tif (b0 === 0xFE && b1 === 0xFF) {\n\t\treturn UTF16be;\n\t}\n\n\t// UTF-16 LE\n\tif (b0 === 0xFF && b1 === 0xFE) {\n\t\treturn UTF16le;\n\t}\n\n\tif (bytesRead < 3) {\n\t\treturn null;\n\t}\n\n\tconst b2 = buffer.readUInt8(2);\n\n\t// UTF-8\n\tif (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {\n\t\treturn UTF8;\n\t}\n\n\treturn null;\n}\n\n/**\n * Detects the Byte Order Mark in a given file.\n * If no BOM is detected, null will be passed to callback.\n */\nexport function detectEncodingByBOM(file: string): Promise<string | null> {\n\treturn stream.readExactlyByFile(file, 3).then(({ buffer, bytesRead }) => detectEncodingByBOMFromBuffer(buffer, bytesRead));\n}\n\nconst MINIMUM_THRESHOLD = 0.2;\nconst IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];\n\n/**\n * Guesses the encoding from buffer.\n */\nexport function guessEncodingByBuffer(buffer: Buffer): Promise<string | null> {\n\treturn import('jschardet').then(jschardet => {\n\t\tjschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;\n\n\t\tconst guessed = jschardet.detect(buffer);\n\t\tif (!guessed || !guessed.encoding) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst enc = guessed.encoding.toLowerCase();\n\n\t\t// Ignore encodings that cannot guess correctly\n\t\t// (http://chardet.readthedocs.io/en/latest/supported-encodings.html)\n\t\tif (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn toIconvLiteEncoding(guessed.encoding);\n\t});\n}\n\nconst JSCHARDET_TO_ICONV_ENCODINGS: { [name: string]: string } = {\n\t'ibm866': 'cp866',\n\t'big5': 'cp950'\n};\n\nfunction toIconvLiteEncoding(encodingName: string): string {\n\tconst normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n\tconst mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];\n\n\treturn mapped || normalizedEncodingName;\n}\n\n/**\n * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.\n * See https://encoding.spec.whatwg.org/#names-and-labels\n * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.\n */\nexport function toCanonicalName(enc: string): string {\n\tswitch (enc) {\n\t\tcase 'shiftjis':\n\t\t\treturn 'shift-jis';\n\t\tcase 'utf16le':\n\t\t\treturn 'utf-16le';\n\t\tcase 'utf16be':\n\t\t\treturn 'utf-16be';\n\t\tcase 'big5hkscs':\n\t\t\treturn 'big5-hkscs';\n\t\tcase 'eucjp':\n\t\t\treturn 'euc-jp';\n\t\tcase 'euckr':\n\t\t\treturn 'euc-kr';\n\t\tcase 'koi8r':\n\t\t\treturn 'koi8-r';\n\t\tcase 'koi8u':\n\t\t\treturn 'koi8-u';\n\t\tcase 'macroman':\n\t\t\treturn 'x-mac-roman';\n\t\tcase 'utf8bom':\n\t\t\treturn 'utf8';\n\t\tdefault:\n\t\t\tconst m = enc.match(/windows(\\d+)/);\n\t\t\tif (m) {\n\t\t\t\treturn 'windows-' + m[1];\n\t\t\t}\n\n\t\t\treturn enc;\n\t}\n}\n\nconst ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not\nconst NO_GUESS_BUFFER_MAX_LEN = 512; \t\t\t// when not auto guessing the encoding, small number of bytes are enough\nconst AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; \t\t// with auto guessing we want a lot more content to be read for guessing\n\nexport interface IDetectedEncodingResult {\n\tencoding: string | null;\n\tseemsBinary: boolean;\n}\n\nexport function detectEncodingFromBuffer(readResult: stream.ReadResult, autoGuessEncoding?: false): IDetectedEncodingResult;\nexport function detectEncodingFromBuffer(readResult: stream.ReadResult, autoGuessEncoding?: boolean): Promise<IDetectedEncodingResult>;\nexport function detectEncodingFromBuffer({ buffer, bytesRead }: stream.ReadResult, autoGuessEncoding?: boolean): Promise<IDetectedEncodingResult> | IDetectedEncodingResult {\n\n\t// Always first check for BOM to find out about encoding\n\tlet encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n\t// Detect 0 bytes to see if file is binary or UTF-16 LE/BE\n\t// unless we already know that this file has a UTF-16 encoding\n\tlet seemsBinary = false;\n\tif (encoding !== UTF16be && encoding !== UTF16le && buffer) {\n\t\tlet couldBeUTF16LE = true; // e.g. 0xAA 0x00\n\t\tlet couldBeUTF16BE = true; // e.g. 0x00 0xAA\n\t\tlet containsZeroByte = false;\n\n\t\t// This is a simplified guess to detect UTF-16 BE or LE by just checking if\n\t\t// the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n\t\t// this would be the odd byte index and for UTF-16 BE the even one.\n\t\t// Note: this can produce false positives (a binary file that uses a 2-byte\n\t\t// encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n\t\t// that is using 4 bytes to encode a character).\n\t\tfor (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n\t\t\tconst isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n\t\t\tconst isZeroByte = (buffer.readInt8(i) === 0);\n\n\t\t\tif (isZeroByte) {\n\t\t\t\tcontainsZeroByte = true;\n\t\t\t}\n\n\t\t\t// UTF-16 LE: expect e.g. 0xAA 0x00\n\t\t\tif (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n\t\t\t\tcouldBeUTF16LE = false;\n\t\t\t}\n\n\t\t\t// UTF-16 BE: expect e.g. 0x00 0xAA\n\t\t\tif (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n\t\t\t\tcouldBeUTF16BE = false;\n\t\t\t}\n\n\t\t\t// Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n\t\t\tif (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Handle case of 0-byte included\n\t\tif (containsZeroByte) {\n\t\t\tif (couldBeUTF16LE) {\n\t\t\t\tencoding = UTF16le;\n\t\t\t} else if (couldBeUTF16BE) {\n\t\t\t\tencoding = UTF16be;\n\t\t\t} else {\n\t\t\t\tseemsBinary = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Auto guess encoding if configured\n\tif (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n\t\treturn guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(guessedEncoding => {\n\t\t\treturn {\n\t\t\t\tseemsBinary: false,\n\t\t\t\tencoding: guessedEncoding\n\t\t\t};\n\t\t});\n\t}\n\n\treturn { seemsBinary, encoding };\n}\n\n// https://ss64.com/nt/chcp.html\nconst windowsTerminalEncodings = {\n\t'437': 'cp437', // United States\n\t'850': 'cp850', // Multilingual(Latin I)\n\t'852': 'cp852', // Slavic(Latin II)\n\t'855': 'cp855', // Cyrillic(Russian)\n\t'857': 'cp857', // Turkish\n\t'860': 'cp860', // Portuguese\n\t'861': 'cp861', // Icelandic\n\t'863': 'cp863', // Canadian - French\n\t'865': 'cp865', // Nordic\n\t'866': 'cp866', // Russian\n\t'869': 'cp869', // Modern Greek\n\t'936': 'cp936', // Simplified Chinese\n\t'1252': 'cp1252' // West European Latin\n};\n\nexport function resolveTerminalEncoding(verbose?: boolean): Promise<string> {\n\tlet rawEncodingPromise: Promise<string>;\n\n\t// Support a global environment variable to win over other mechanics\n\tconst cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];\n\tif (cliEncodingEnv) {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Found VSCODE_CLI_ENCODING variable: ${cliEncodingEnv}`);\n\t\t}\n\n\t\trawEncodingPromise = Promise.resolve(cliEncodingEnv);\n\t}\n\n\t// Linux/Mac: use \"locale charmap\" command\n\telse if (isLinux || isMacintosh) {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"locale charmap\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('locale charmap', (err, stdout, stderr) => resolve(stdout));\n\t\t});\n\t}\n\n\t// Windows: educated guess\n\telse {\n\t\trawEncodingPromise = new Promise<string>(resolve => {\n\t\t\tif (verbose) {\n\t\t\t\tconsole.log('Running \"chcp\" to detect terminal encoding...');\n\t\t\t}\n\n\t\t\texec('chcp', (err, stdout, stderr) => {\n\t\t\t\tif (stdout) {\n\t\t\t\t\tconst windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);\n\t\t\t\t\tfor (const key of windowsTerminalEncodingKeys) {\n\t\t\t\t\t\tif (stdout.indexOf(key) >= 0) {\n\t\t\t\t\t\t\treturn resolve(windowsTerminalEncodings[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resolve(undefined);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn rawEncodingPromise.then(rawEncoding => {\n\t\tif (verbose) {\n\t\t\tconsole.log(`Detected raw terminal encoding: ${rawEncoding}`);\n\t\t}\n\n\t\tif (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === UTF8) {\n\t\t\treturn UTF8;\n\t\t}\n\n\t\tconst iconvEncoding = toIconvLiteEncoding(rawEncoding);\n\t\tif (iconv.encodingExists(iconvEncoding)) {\n\t\t\treturn iconvEncoding;\n\t\t}\n\n\t\tif (verbose) {\n\t\t\tconsole.log('Unsupported terminal encoding, falling back to UTF-8.');\n\t\t}\n\n\t\treturn UTF8;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as paths from 'vs/base/common/path';\nimport { nfcall } from 'vs/base/common/async';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport * as platform from 'vs/base/common/platform';\nimport * as strings from 'vs/base/common/strings';\nimport * as uuid from 'vs/base/common/uuid';\nimport { encode, encodeStream } from 'vs/base/node/encoding';\nimport * as flow from 'vs/base/node/flow';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IDisposable, toDisposable, Disposable } from 'vs/base/common/lifecycle';\n\nconst loop = flow.loop;\n\nexport function readdirSync(path: string): string[] {\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\treturn fs.readdirSync(path).map(c => normalizeNFC(c));\n\t}\n\n\treturn fs.readdirSync(path);\n}\n\nexport function readdir(path: string, callback: (error: Error | null, files: string[]) => void): void {\n\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t// See also https://github.com/nodejs/node/issues/2165\n\tif (platform.isMacintosh) {\n\t\treturn fs.readdir(path, (error, children) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(error, []);\n\t\t\t}\n\n\t\t\treturn callback(null, children.map(c => normalizeNFC(c)));\n\t\t});\n\t}\n\n\treturn fs.readdir(path, callback);\n}\n\nexport interface IStatAndLink {\n\tstat: fs.Stats;\n\tisSymbolicLink: boolean;\n}\n\nexport function statLink(path: string, callback: (error: Error | null, statAndIsLink: IStatAndLink | null) => void): void {\n\tfs.lstat(path, (error, lstat) => {\n\t\tif (error || lstat.isSymbolicLink()) {\n\t\t\tfs.stat(path, (error, stat) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn callback(error, null);\n\t\t\t\t}\n\n\t\t\t\tcallback(null, { stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });\n\t\t\t});\n\t\t} else {\n\t\t\tcallback(null, { stat: lstat, isSymbolicLink: false });\n\t\t}\n\t});\n}\n\nexport function copy(source: string, target: string, callback: (error: Error | null) => void, copiedSourcesIn?: { [path: string]: boolean }): void {\n\tconst copiedSources = copiedSourcesIn ? copiedSourcesIn : Object.create(null);\n\n\tfs.stat(source, (error, stat) => {\n\t\tif (error) {\n\t\t\treturn callback(error);\n\t\t}\n\n\t\tif (!stat.isDirectory()) {\n\t\t\treturn doCopyFile(source, target, stat.mode & 511, callback);\n\t\t}\n\n\t\tif (copiedSources[source]) {\n\t\t\treturn callback(null); // escape when there are cycles (can happen with symlinks)\n\t\t}\n\n\t\tcopiedSources[source] = true; // remember as copied\n\n\t\tconst proceed = function () {\n\t\t\treaddir(source, (err, files) => {\n\t\t\t\tloop(files, (file: string, clb: (error: Error | null, result: string[]) => void) => {\n\t\t\t\t\tcopy(paths.join(source, file), paths.join(target, file), (error: Error) => clb(error, []), copiedSources);\n\t\t\t\t}, callback);\n\t\t\t});\n\t\t};\n\n\t\tmkdirp(target, stat.mode & 511).then(proceed, proceed);\n\t});\n}\n\nfunction doCopyFile(source: string, target: string, mode: number, callback: (error: Error) => void): void {\n\tconst reader = fs.createReadStream(source);\n\tconst writer = fs.createWriteStream(target, { mode });\n\n\tlet finished = false;\n\tconst finish = (error?: Error) => {\n\t\tif (!finished) {\n\t\t\tfinished = true;\n\n\t\t\t// in error cases, pass to callback\n\t\t\tif (error) {\n\t\t\t\tcallback(error);\n\t\t\t}\n\n\t\t\t// we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104\n\t\t\telse {\n\t\t\t\tfs.chmod(target, mode, callback);\n\t\t\t}\n\t\t}\n\t};\n\n\t// handle errors properly\n\treader.once('error', error => finish(error));\n\twriter.once('error', error => finish(error));\n\n\t// we are done (underlying fd has been closed)\n\twriter.once('close', () => finish());\n\n\t// start piping\n\treader.pipe(writer);\n}\n\nexport function mkdirp(path: string, mode?: number, token?: CancellationToken): Promise<boolean> {\n\tconst mkdir = (): Promise<null> => {\n\t\treturn nfcall(fs.mkdir, path, mode).then(undefined, (mkdirErr: NodeJS.ErrnoException) => {\n\n\t\t\t// ENOENT: a parent folder does not exist yet\n\t\t\tif (mkdirErr.code === 'ENOENT') {\n\t\t\t\treturn Promise.reject(mkdirErr);\n\t\t\t}\n\n\t\t\t// Any other error: check if folder exists and\n\t\t\t// return normally in that case if its a folder\n\t\t\treturn nfcall(fs.stat, path).then((stat: fs.Stats) => {\n\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\treturn Promise.reject(new Error(`'${path}' exists and is not a directory.`));\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}, statErr => {\n\t\t\t\treturn Promise.reject(mkdirErr); // bubble up original mkdir error\n\t\t\t});\n\t\t});\n\t};\n\n\t// stop at root\n\tif (path === paths.dirname(path)) {\n\t\treturn Promise.resolve(true);\n\t}\n\n\t// recursively mkdir\n\treturn mkdir().then(undefined, (err: NodeJS.ErrnoException) => {\n\n\t\t// Respect cancellation\n\t\tif (token && token.isCancellationRequested) {\n\t\t\treturn Promise.resolve(false);\n\t\t}\n\n\t\t// ENOENT: a parent folder does not exist yet, continue\n\t\t// to create the parent folder and then try again.\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn mkdirp(paths.dirname(path), mode).then(mkdir);\n\t\t}\n\n\t\t// Any other error\n\t\treturn Promise.reject(err);\n\t});\n}\n\n// Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because\n// after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation\n// will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.\n// However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164\nexport function del(path: string, tmpFolder: string, callback: (error: Error | null) => void, done?: (error: Error | null) => void): void {\n\tfs.exists(path, exists => {\n\t\tif (!exists) {\n\t\t\treturn callback(null);\n\t\t}\n\n\t\tfs.stat(path, (err, stat) => {\n\t\t\tif (err || !stat) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\t// Special windows workaround: A file or folder that ends with a \".\" cannot be moved to another place\n\t\t\t// because it is not a valid file name. In this case, we really have to do the deletion without prior move.\n\t\t\tif (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\\\')) {\n\t\t\t\treturn rmRecursive(path, callback);\n\t\t\t}\n\n\t\t\tconst pathInTemp = paths.join(tmpFolder, uuid.generateUuid());\n\t\t\tfs.rename(path, pathInTemp, (error: Error | null) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treturn rmRecursive(path, callback); // if rename fails, delete without tmp dir\n\t\t\t\t}\n\n\t\t\t\t// Return early since the move succeeded\n\t\t\t\tcallback(null);\n\n\t\t\t\t// do the heavy deletion outside the callers callback\n\t\t\t\trmRecursive(pathInTemp, error => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tdone(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction rmRecursive(path: string, callback: (error: Error | null) => void): void {\n\tif (path === paths.win32.sep || path === paths.posix.sep) {\n\t\treturn callback(new Error('Will not delete root!'));\n\t}\n\n\tfs.exists(path, exists => {\n\t\tif (!exists) {\n\t\t\tcallback(null);\n\t\t} else {\n\t\t\tfs.lstat(path, (err, stat) => {\n\t\t\t\tif (err || !stat) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {\n\t\t\t\t\tconst mode = stat.mode;\n\t\t\t\t\tif (!(mode & 128)) { // 128 === 0200\n\t\t\t\t\t\tfs.chmod(path, mode | 128, (err: Error) => { // 128 === 0200\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfs.unlink(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs.unlink(path, callback);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treaddir(path, (err, children) => {\n\t\t\t\t\t\tif (err || !children) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else if (children.length === 0) {\n\t\t\t\t\t\t\tfs.rmdir(path, callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet firstError: Error | null = null;\n\t\t\t\t\t\t\tlet childrenLeft = children.length;\n\t\t\t\t\t\t\tchildren.forEach(child => {\n\t\t\t\t\t\t\t\trmRecursive(paths.join(path, child), (err: Error) => {\n\t\t\t\t\t\t\t\t\tchildrenLeft--;\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tfirstError = firstError || err;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (childrenLeft === 0) {\n\t\t\t\t\t\t\t\t\t\tif (firstError) {\n\t\t\t\t\t\t\t\t\t\t\tcallback(firstError);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tfs.rmdir(path, callback);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nexport function delSync(path: string): void {\n\tif (path === paths.win32.sep || path === paths.posix.sep) {\n\t\tthrow new Error('Will not delete root!');\n\t}\n\n\ttry {\n\t\tconst stat = fs.lstatSync(path);\n\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\treaddirSync(path).forEach(child => delSync(paths.join(path, child)));\n\t\t\tfs.rmdirSync(path);\n\t\t} else {\n\t\t\tfs.unlinkSync(path);\n\t\t}\n\t} catch (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\treturn; // not found\n\t\t}\n\n\t\tthrow err;\n\t}\n}\n\nexport function mv(source: string, target: string, callback: (error: Error | null) => void): void {\n\tif (source === target) {\n\t\treturn callback(null);\n\t}\n\n\tfunction updateMtime(err: Error | null): void {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tfs.stat(target, (error, stat) => {\n\t\t\tif (error) {\n\t\t\t\treturn callback(error);\n\t\t\t}\n\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\treturn callback(null);\n\t\t\t}\n\n\t\t\tfs.open(target, 'a', null, (err: Error, fd: number) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tfs.futimes(fd, stat.atime, new Date(), (err: Error) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tfs.close(fd, callback);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t// Try native rename()\n\tfs.rename(source, target, (err: Error) => {\n\t\tif (!err) {\n\t\t\treturn updateMtime(null);\n\t\t}\n\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (err && source.toLowerCase() !== target.toLowerCase() && ((<any>err).code === 'EXDEV') || strings.endsWith(source, '.')) {\n\t\t\treturn copy(source, target, (err: Error) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\trmRecursive(source, updateMtime);\n\t\t\t});\n\t\t}\n\n\t\treturn callback(err);\n\t});\n}\n\nexport interface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n\tencoding?: {\n\t\tcharset: string;\n\t\taddBOM: boolean;\n\t};\n}\n\nlet canFlush = true;\nexport function writeFileAndFlush(path: string, data: string | Buffer | NodeJS.ReadableStream, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\toptions = ensureOptions(options);\n\n\tif (typeof data === 'string' || Buffer.isBuffer(data)) {\n\t\tdoWriteFileAndFlush(path, data, options, callback);\n\t} else {\n\t\tdoWriteFileStreamAndFlush(path, data, options, callback);\n\t}\n}\n\nfunction doWriteFileStreamAndFlush(path: string, reader: NodeJS.ReadableStream, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\tif (process.env.isBrowser) {\n\t\tlet content = '';\n\t\tlet chunk = reader.read();\n\t\twhile (chunk !== null) {\n\t\t\tcontent += chunk;\n\t\t\tchunk = reader.read();\n\t\t}\n\t\tfs.writeFile(path, content, 'utf-8', function (error) {\n\t\t\tif (error) {\n\t\t\t\tcallback(error);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\treturn;\n\t}\n\t// finish only once\n\tlet finished = false;\n\tconst finish = (error?: Error) => {\n\t\tif (!finished) {\n\t\t\tfinished = true;\n\n\t\t\t// in error cases we need to manually close streams\n\t\t\t// if the write stream was successfully opened\n\t\t\tif (error) {\n\t\t\t\tif (isOpen) {\n\t\t\t\t\twriter.once('close', () => callback(error));\n\t\t\t\t\twriter.destroy();\n\t\t\t\t} else {\n\t\t\t\t\tcallback(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise just return without error\n\t\t\telse {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t};\n\n\t// create writer to target. we set autoClose: false because we want to use the streams\n\t// file descriptor to call fs.fdatasync to ensure the data is flushed to disk\n\tconst writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });\n\n\t// Event: 'open'\n\t// Purpose: save the fd for later use and start piping\n\t// Notes: will not be called when there is an error opening the file descriptor!\n\tlet fd: number;\n\tlet isOpen: boolean;\n\twriter.once('open', descriptor => {\n\t\tfd = descriptor;\n\t\tisOpen = true;\n\n\t\t// if an encoding is provided, we need to pipe the stream through\n\t\t// an encoder stream and forward the encoding related options\n\t\tif (options.encoding) {\n\t\t\treader = reader.pipe(encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));\n\t\t}\n\n\t\t// start data piping only when we got a successful open. this ensures that we do\n\t\t// not consume the stream when an error happens and helps to fix this issue:\n\t\t// https://github.com/Microsoft/vscode/issues/42542\n\t\treader.pipe(writer);\n\t});\n\n\t// Event: 'error'\n\t// Purpose: to return the error to the outside and to close the write stream (does not happen automatically)\n\treader.once('error', error => finish(error));\n\twriter.once('error', error => finish(error));\n\n\t// Event: 'finish'\n\t// Purpose: use fs.fdatasync to flush the contents to disk\n\t// Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()\n\t// because we have created the WriteStream with autoClose: false\n\twriter.once('finish', () => {\n\n\t\t// flush to disk\n\t\tif (canFlush && isOpen) {\n\t\t\tfs.fdatasync(fd, (syncError: Error) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\twriter.destroy();\n\t\t\t});\n\t\t} else {\n\t\t\twriter.destroy();\n\t\t}\n\t});\n\n\t// Event: 'close'\n\t// Purpose: signal we are done to the outside\n\t// Notes: event is called when the writer's filedescriptor is closed\n\twriter.once('close', () => finish());\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer, options: IWriteFileOptions, callback: (error?: Error) => void): void {\n\tif (options.encoding) {\n\t\tdata = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n\t}\n\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(/** Desktop fd */path, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\tfs.fdatasync(fd, (syncError: Error) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tcanFlush = false;\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\nexport function writeFileAndFlushSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\toptions = ensureOptions(options);\n\n\tif (options.encoding) {\n\t\tdata = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });\n\t}\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, typeof options.flag === 'string' ? options.flag : 'r', options.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(path, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd);\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tcanFlush = false;\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureOptions(options?: IWriteFileOptions): IWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666, flag: 'w' };\n\t}\n\n\tconst ensuredOptions: IWriteFileOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };\n\n\tif (typeof ensuredOptions.mode !== 'number') {\n\t\tensuredOptions.mode = 0o666;\n\t}\n\n\tif (typeof ensuredOptions.flag !== 'string') {\n\t\tensuredOptions.flag = 'w';\n\t}\n\n\treturn ensuredOptions;\n}\n\n/**\n * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport function realcaseSync(path: string): string | null {\n\tconst dir = paths.dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = readdirSync(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn paths.join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn paths.join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nexport function realpath(path: string, callback: (error: Error | null, realpath: string) => void): void {\n\treturn fs.realpath(path, (error, realpath) => {\n\t\tif (!error) {\n\t\t\treturn callback(null, realpath);\n\t\t}\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\treturn fs.access(normalizedPath, fs.constants.R_OK, error => {\n\t\t\treturn callback(error, normalizedPath);\n\t\t});\n\t});\n}\n\nfunction normalizePath(path: string): string {\n\treturn strings.rtrim(paths.normalize(path), paths.sep);\n}\n\nexport function watch(path: string, onChange: (type: string, path?: string) => void, onError: (error: string) => void): IDisposable {\n\ttry {\n\t\tconst watcher = fs.watch(path);\n\n\t\twatcher.on('change', (type, raw) => {\n\t\t\tlet file: string | undefined;\n\t\t\tif (raw) { // https://github.com/Microsoft/vscode/issues/38191\n\t\t\t\tfile = raw.toString();\n\t\t\t\tif (platform.isMacintosh) {\n\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\tfile = normalizeNFC(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tonChange(type, file);\n\t\t});\n\n\t\twatcher.on('error', (code: number, signal: string) => onError(`Failed to watch ${path} for changes (${code}, ${signal})`));\n\n\t\treturn toDisposable(() => {\n\t\t\twatcher.removeAllListeners();\n\t\t\twatcher.close();\n\t\t});\n\t} catch (error) {\n\t\tfs.exists(path, exists => {\n\t\t\tif (exists) {\n\t\t\t\tonError(`Failed to watch ${path} for changes (${error.toString()})`);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn Disposable.None;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (platform.isWindows && strings.endsWith(candidate, ':')) {\n\t\tcandidate += paths.sep;\n\t}\n\n\t// Ensure absolute\n\tif (!paths.isAbsolute(candidate)) {\n\t\tcandidate = paths.join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = paths.normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (platform.isWindows) {\n\t\tcandidate = strings.rtrim(candidate, paths.sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (strings.endsWith(candidate, ':')) {\n\t\t\tcandidate += paths.sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = strings.rtrim(candidate, paths.sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = paths.sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable, toDisposable, combinedDisposable } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, Relay } from 'vs/base/common/event';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any; };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel, id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any; };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose, id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string, name: string, stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: Buffer): void;\n\tonMessage: Event<Buffer>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the couter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidChangeConnections: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): Buffer;\n}\n\ninterface IWriter {\n\twrite(buffer: Buffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: Buffer) { }\n\n\tread(bytes: number): Buffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.length;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: Buffer[] = [];\n\n\tget buffer(): Buffer {\n\t\treturn Buffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: Buffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tArray = 3,\n\tObject = 4\n}\n\nfunction createSizeBuffer(size: number): Buffer {\n\tconst result = Buffer.allocUnsafe(4);\n\tresult.writeUInt32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUInt32BE(0);\n}\n\nconst BufferPresets = {\n\tUndefined: Buffer.alloc(1, DataType.Undefined),\n\tString: Buffer.alloc(1, DataType.String),\n\tBuffer: Buffer.alloc(1, DataType.Buffer),\n\tArray: Buffer.alloc(1, DataType.Array),\n\tObject: Buffer.alloc(1, DataType.Object)\n};\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = Buffer.from(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t} else if (Buffer.isBuffer(data)) {\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(data.length));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = Buffer.from(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.send([response.type]);\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.send([response.type, response.id], response.data);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(d => d.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\n\tprivate _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = createCancelablePromise(_ => this.whenInitialized());\n\t\t\tuninitializedPromise.then(() => {\n\t\t\t\tuninitializedPromise = null;\n\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t});\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable([toDisposable(cancel), cancellationTokenListener]);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => this.activeRequests.delete(disposable));\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawEventFireResponse) => emitter.fire(res.data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.send([request.type, request.id]);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onBuffer(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\tif (handler) {\n\t\t\thandler(response);\n\t\t}\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn Event.toPromise(this.onDidInitialize);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(p => p.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate _onDidChangeConnections = new Emitter<Connection<TContext>>();\n\treadonly onDidChangeConnections: Event<Connection<TContext>> = this._onDidChangeConnections.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidChangeConnections.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tconst channelPromise = router.routeCall(that, command, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tconst channelPromise = router.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidChangeConnections.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidChangeConnections);\n\t\treturn await this.route(hub);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport * as nls from 'vs/nls';\nimport * as Types from 'vs/base/common/types';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as Objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as Platform from 'vs/base/common/platform';\nimport { LineDecoder } from 'vs/base/node/decoder';\nimport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode, Executable } from 'vs/base/common/processes';\nimport { getPathFromAmdModule } from 'vs/base/common/amd';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value?: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport interface LineData {\n\tline: string;\n\tsource: Source;\n}\n\nfunction getWindowsCode(status: number): TerminateResponseCode {\n\tswitch (status) {\n\t\tcase 0:\n\t\t\treturn TerminateResponseCode.Success;\n\t\tcase 1:\n\t\t\treturn TerminateResponseCode.AccessDenied;\n\t\tcase 128:\n\t\t\treturn TerminateResponseCode.ProcessNotFound;\n\t\tdefault:\n\t\t\treturn TerminateResponseCode.Unknown;\n\t}\n}\n\nexport function terminateProcess(process: cp.ChildProcess, cwd?: string): TerminateResponse {\n\tif (Platform.isWindows) {\n\t\ttry {\n\t\t\tconst options: any = {\n\t\t\t\tstdio: ['pipe', 'pipe', 'ignore']\n\t\t\t};\n\t\t\tif (cwd) {\n\t\t\t\toptions.cwd = cwd;\n\t\t\t}\n\t\t\tcp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err, code: err.status ? getWindowsCode(err.status) : TerminateResponseCode.Unknown };\n\t\t}\n\t} else if (Platform.isLinux || Platform.isMacintosh) {\n\t\ttry {\n\t\t\tconst cmd = getPathFromAmdModule(require, 'vs/base/node/terminateProcess.sh');\n\t\t\tconst result = cp.spawnSync(cmd, [process.pid.toString()]);\n\t\t\tif (result.error) {\n\t\t\t\treturn { success: false, error: result.error };\n\t\t\t}\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err };\n\t\t}\n\t} else {\n\t\tprocess.kill('SIGKILL');\n\t}\n\treturn { success: true };\n}\n\nexport function getWindowsShell(): string {\n\treturn process.env['comspec'] || 'cmd.exe';\n}\n\nexport abstract class AbstractProcess<TProgressData> {\n\tprivate cmd: string;\n\tprivate args: string[];\n\tprivate options: CommandOptions | ForkOptions;\n\tprotected shell: boolean;\n\n\tprivate childProcess: cp.ChildProcess | null;\n\tprotected childProcessPromise: Promise<cp.ChildProcess> | null;\n\tprivate pidResolve?: ValueCallback<number>;\n\tprotected terminateRequested: boolean;\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[] | undefined, shell: boolean, options: CommandOptions | undefined);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean, arg4?: CommandOptions) {\n\t\tif (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n\t\t\tthis.cmd = <string>arg1;\n\t\t\tthis.args = arg2;\n\t\t\tthis.shell = arg3;\n\t\t\tthis.options = arg4;\n\t\t} else {\n\t\t\tconst executable = <Executable>arg1;\n\t\t\tthis.cmd = executable.command;\n\t\t\tthis.shell = executable.isShellCommand;\n\t\t\tthis.args = executable.args.slice(0);\n\t\t\tthis.options = executable.options || {};\n\t\t}\n\n\t\tthis.childProcess = null;\n\t\tthis.terminateRequested = false;\n\n\t\tif (this.options.env) {\n\t\t\tconst newEnv: IStringDictionary<string> = Object.create(null);\n\t\t\tObject.keys(process.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = process.env[key]!;\n\t\t\t});\n\t\t\tObject.keys(this.options.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = this.options.env![key]!;\n\t\t\t});\n\t\t\tthis.options.env = newEnv;\n\t\t}\n\t}\n\n\tpublic getSanitizedCommand(): string {\n\t\tlet result = this.cmd.toLowerCase();\n\t\tconst index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (AbstractProcess.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tpublic start(pp: ProgressCallback<TProgressData>): Promise<SuccessData> {\n\t\tif (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n\t\t\treturn Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n\t\t}\n\t\treturn this.useExec().then((useExec) => {\n\t\t\tlet cc: ValueCallback<SuccessData>;\n\t\t\tlet ee: ErrorCallback;\n\t\t\tconst result = new Promise<any>((c, e) => {\n\t\t\t\tcc = c;\n\t\t\t\tee = e;\n\t\t\t});\n\n\t\t\tif (useExec) {\n\t\t\t\tlet cmd: string = this.cmd;\n\t\t\t\tif (this.args) {\n\t\t\t\t\tcmd = cmd + ' ' + this.args.join(' ');\n\t\t\t\t}\n\t\t\t\tthis.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tconst err: any = error;\n\t\t\t\t\t// This is tricky since executing a command shell reports error back in case the executed command return an\n\t\t\t\t\t// error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n\t\t\t\t\t// always parse the output and report success unless the job got killed.\n\t\t\t\t\tif (err && err.killed) {\n\t\t\t\t\t\tee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleExec(cc, pp, error, stdout as any, stderr as any);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet childProcess: cp.ChildProcess | null = null;\n\t\t\t\tconst closeHandler = (data: any) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tthis.childProcessPromise = null;\n\t\t\t\t\tthis.handleClose(data, cc, pp, ee);\n\t\t\t\t\tconst result: SuccessData = {\n\t\t\t\t\t\tterminated: this.terminateRequested\n\t\t\t\t\t};\n\t\t\t\t\tif (Types.isNumber(data)) {\n\t\t\t\t\t\tresult.cmdCode = <number>data;\n\t\t\t\t\t}\n\t\t\t\t\tcc(result);\n\t\t\t\t};\n\t\t\t\tif (this.shell && Platform.isWindows) {\n\t\t\t\t\tconst options: any = Objects.deepClone(this.options);\n\t\t\t\t\toptions.windowsVerbatimArguments = true;\n\t\t\t\t\toptions.detached = false;\n\t\t\t\t\tlet quotedCommand: boolean = false;\n\t\t\t\t\tlet quotedArg: boolean = false;\n\t\t\t\t\tconst commandLine: string[] = [];\n\t\t\t\t\tlet quoted = this.ensureQuotes(this.cmd);\n\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\tquotedCommand = quoted.quoted;\n\t\t\t\t\tif (this.args) {\n\t\t\t\t\t\tthis.args.forEach((elem) => {\n\t\t\t\t\t\t\tquoted = this.ensureQuotes(elem);\n\t\t\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\t\t\tquotedArg = quotedArg && quoted.quoted;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconst args: string[] = [\n\t\t\t\t\t\t'/s',\n\t\t\t\t\t\t'/c',\n\t\t\t\t\t];\n\t\t\t\t\tif (quotedCommand) {\n\t\t\t\t\t\tif (quotedArg) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine.join(' ') + '\"');\n\t\t\t\t\t\t} else if (commandLine.length > 1) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push(commandLine.join(' '));\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess = cp.spawn(getWindowsShell(), args, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.cmd) {\n\t\t\t\t\t\tchildProcess = cp.spawn(this.cmd, this.args, this.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (childProcess) {\n\t\t\t\t\tthis.childProcess = childProcess;\n\t\t\t\t\tthis.childProcessPromise = Promise.resolve(childProcess);\n\t\t\t\t\tif (this.pidResolve) {\n\t\t\t\t\t\tthis.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n\t\t\t\t\t\tthis.pidResolve = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess.on('error', (error: Error) => {\n\t\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\t\tee({ terminated: this.terminateRequested, error: error });\n\t\t\t\t\t});\n\t\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\t\tthis.childProcess.on('close', closeHandler);\n\t\t\t\t\t\tthis.handleSpawn(childProcess, cc!, pp, ee!, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tprotected abstract handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, error: Error | null, stdout: Buffer, stderr: Buffer): void;\n\tprotected abstract handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback, sync: boolean): void;\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback): void {\n\t\t// Default is to do nothing.\n\t}\n\n\tprivate static readonly regexp = /^[^\"].* .*[^\"]/;\n\tprivate ensureQuotes(value: string) {\n\t\tif (AbstractProcess.regexp.test(value)) {\n\t\t\treturn {\n\t\t\t\tvalue: '\"' + value + '\"', //`\"${value}\"`,\n\t\t\t\tquoted: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tquoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic get pid(): Promise<number> {\n\t\tif (this.childProcessPromise) {\n\t\t\treturn this.childProcessPromise.then(childProcess => childProcess.pid, err => -1);\n\t\t} else {\n\t\t\treturn new Promise<number>((resolve) => {\n\t\t\t\tthis.pidResolve = resolve;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic terminate(): Promise<TerminateResponse> {\n\t\tif (!this.childProcessPromise) {\n\t\t\treturn Promise.resolve<TerminateResponse>({ success: true });\n\t\t}\n\t\treturn this.childProcessPromise.then((childProcess) => {\n\t\t\tthis.terminateRequested = true;\n\t\t\tconst result = terminateProcess(childProcess, this.options.cwd);\n\t\t\tif (result.success) {\n\t\t\t\tthis.childProcess = null;\n\t\t\t}\n\t\t\treturn result;\n\t\t}, (err) => {\n\t\t\treturn { success: true };\n\t\t});\n\t}\n\n\tprivate useExec(): Promise<boolean> {\n\t\treturn new Promise<boolean>((c, e) => {\n\t\t\tif (!this.shell || !Platform.isWindows) {\n\t\t\t\treturn c(false);\n\t\t\t}\n\t\t\tconst cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n\t\t\tcmdShell.on('error', (error: Error) => {\n\t\t\t\treturn c(true);\n\t\t\t});\n\t\t\tcmdShell.on('exit', (data: any) => {\n\t\t\t\treturn c(false);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class LineProcess extends AbstractProcess<LineData> {\n\n\tprivate stdoutLineDecoder: LineDecoder;\n\tprivate stderrLineDecoder: LineDecoder;\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[], shell: boolean, options: CommandOptions);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean | ForkOptions, arg4?: CommandOptions) {\n\t\tsuper(<any>arg1, arg2, <any>arg3, arg4);\n\t}\n\n\tprotected handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, error: Error, stdout: Buffer, stderr: Buffer) {\n\t\t[stdout, stderr].forEach((buffer: Buffer, index: number) => {\n\t\t\tconst lineDecoder = new LineDecoder();\n\t\t\tconst lines = lineDecoder.write(buffer);\n\t\t\tlines.forEach((line) => {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t});\n\t\t\tconst line = lineDecoder.end();\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t\tcc({ terminated: this.terminateRequested, error: error });\n\t}\n\n\tprotected handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback, sync: boolean): void {\n\t\tthis.stdoutLineDecoder = new LineDecoder();\n\t\tthis.stderrLineDecoder = new LineDecoder();\n\t\tchildProcess.stdout.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stdoutLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stdout }));\n\t\t});\n\t\tchildProcess.stderr.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stderrLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stderr }));\n\t\t});\n\t}\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback): void {\n\t\t[this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach((line, index) => {\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport function findExecutable(command: string, cwd?: string, paths?: string[]): string {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env.PATH)) {\n\t\t\tpaths = process.env.PATH.split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (let pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (fs.existsSync(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, fork, ForkOptions } from 'child_process';\nimport { IDisposable, toDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Delayer, createCancelablePromise } from 'vs/base/common/async';\nimport { deepClone, assign } from 'vs/base/common/objects';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { createQueuedSender } from 'vs/base/node/processes';\nimport { ChannelServer as IPCServer, ChannelClient as IPCClient, IChannelClient, IChannel } from 'vs/base/parts/ipc/node/ipc';\nimport { isRemoteConsoleLog, log } from 'vs/base/node/console';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper({\n\t\t\tsend: r => {\n\t\t\t\ttry {\n\t\t\t\t\tif (process.send) {\n\t\t\t\t\t\tprocess.send(r.toString('base64'));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /* not much to do */ }\n\t\t\t},\n\t\t\tonMessage: Event.fromNodeEventEmitter(process, 'message', msg => Buffer.from(msg, 'base64'))\n\t\t}, ctx);\n\n\t\tprocess.once('disconnect', () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * See https://github.com/Microsoft/vscode/issues/27665\n\t * Allows to pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.\n\t * e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host\n\t * results in the forked process inheriting `--inspect-brk=xxx`.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\n\tprivate disposeDelayer: Delayer<void>;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate _onDidProcessExit = new Emitter<{ code: number, signal: string }>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(private modulePath: string, private options: IIPCOptions) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error('disposed'));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise(token => channel.call<T>(name, arg, token));\n\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(channelName: string, name: string, arg?: any): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args = this.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = assign(deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = assign(forkOpts.env, this.options.env);\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n\t\t\t}\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<Buffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n\n\t\t\tonRawMessage(msg => {\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(Buffer.from(msg, 'base64'));\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue ? createQueuedSender(this.child) : this.child;\n\t\t\tconst send = (r: Buffer) => this.child && (process.env.isBrowser ? true : this.child.connected) && sender.send(r.toString('base64'));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once('exit', onExit);\n\n\t\t\tthis.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n\n\t\t\tthis.child.on('exit', (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener('exit', onExit);\n\n\t\t\t\tthis.activeRequests.forEach(r => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== 'SIGTERM') {\n\t\t\t\t\tconsole.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n\t\t\t\t}\n\n\t\t\t\tif (this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.cancel();\n\t\t\t\t}\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tthis.disposeDelayer.cancel();\n\t\tthis.disposeDelayer = null!; // StrictNullOverride: nulling out ok in dispose\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ServiceCollection } from './serviceCollection';\nimport * as descriptors from './descriptors';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>, index: number, optional: boolean }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport interface IConstructorSignature0<T> {\n\tnew(...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature1<A1, T> {\n\tnew(first: A1, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature2<A1, A2, T> {\n\tnew(first: A1, second: A2, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature3<A1, A2, A3, T> {\n\tnew(first: A1, second: A2, third: A3, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature4<A1, A2, A3, A4, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature5<A1, A2, A3, A4, A5, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature6<A1, A2, A3, A4, A5, A6, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>, isOptional?: typeof optional): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\nexport interface IInstantiationService {\n\n\t_serviceBrand: any;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by\n\t * the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<A1, T>(descriptor: descriptors.SyncDescriptor1<A1, T>, a1: A1): T;\n\tcreateInstance<A1, A2, T>(descriptor: descriptors.SyncDescriptor2<A1, A2, T>, a1: A1, a2: A2): T;\n\tcreateInstance<A1, A2, A3, T>(descriptor: descriptors.SyncDescriptor3<A1, A2, A3, T>, a1: A1, a2: A2, a3: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(descriptor: descriptors.SyncDescriptor4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3, a4: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(descriptor: descriptors.SyncDescriptor5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(descriptor: descriptors.SyncDescriptor6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(descriptor: descriptors.SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(descriptor: descriptors.SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;\n\n\tcreateInstance<T>(ctor: IConstructorSignature0<T>): T;\n\tcreateInstance<A1, T>(ctor: IConstructorSignature1<A1, T>, first: A1): T;\n\tcreateInstance<A1, A2, T>(ctor: IConstructorSignature2<A1, A2, T>, first: A1, second: A2): T;\n\tcreateInstance<A1, A2, A3, T>(ctor: IConstructorSignature3<A1, A2, A3, T>, first: A1, second: A2, third: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(ctor: IConstructorSignature4<A1, A2, A3, A4, T>, first: A1, second: A2, third: A3, fourth: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(ctor: IConstructorSignature5<A1, A2, A3, A4, A5, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(ctor: IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(ctor: IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8): T;\n\n\t/**\n\t *\n\t */\n\tinvokeFunction<R, TS extends any[]=[]>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherts all current services\n\t * and adds/overwrites the given services\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type T\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void {\n\tif (target[_util.DI_TARGET] === target) {\n\t\ttarget[_util.DI_DEPENDENCIES].push({ id, index, optional });\n\t} else {\n\t\ttarget[_util.DI_DEPENDENCIES] = [{ id, index, optional }];\n\t\ttarget[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * A *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): { (...args: any[]): void; type: T; } {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index, false);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\n/**\n * Mark a service dependency as optional.\n */\nexport function optional<T>(serviceIdentifier: ServiceIdentifier<T>) {\n\n\treturn function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@optional-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(serviceIdentifier, target, index, true);\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { sep } from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport * as glob from 'vs/base/common/glob';\nimport { isLinux } from 'vs/base/common/platform';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { Event } from 'vs/base/common/event';\nimport { startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { isEqualOrParent, isEqual } from 'vs/base/common/resources';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\n\nexport const IFileService = createDecorator<IFileService>('fileService');\n\nexport interface IResourceEncodings {\n\tgetWriteEncoding(resource: URI, preferredEncoding?: string): IResourceEncoding;\n}\n\nexport interface IResourceEncoding {\n\tencoding: string;\n\thasBOM: boolean;\n}\n\nexport interface IFileService {\n\t_serviceBrand: any;\n\n\t/**\n\t * Helper to determine read/write encoding for resources.\n\t */\n\tencoding: IResourceEncodings;\n\n\t/**\n\t * Allows to listen for file changes. The event will fire for every file within the opened workspace\n\t * (if any) as well as all files that have been watched explicitly using the #watchFileChanges() API.\n\t */\n\tonFileChanges: Event<FileChangesEvent>;\n\n\t/**\n\t * An event that is fired upon successful completion of a certain file operation.\n\t */\n\tonAfterOperation: Event<FileOperationEvent>;\n\n\t/**\n\t * An event that is fired when a file system provider is added or removed\n\t */\n\tonDidChangeFileSystemProviderRegistrations: Event<IFileSystemProviderRegistrationEvent>;\n\n\t/**\n\t * Registers a file system provider for a certain scheme.\n\t */\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable;\n\n\t/**\n\t * Tries to activate a provider with the given scheme.\n\t */\n\tactivateProvider(scheme: string): Promise<void>;\n\n\t/**\n\t * Checks if this file service can handle the given resource.\n\t */\n\tcanHandleResource(resource: URI): boolean;\n\n\t/**\n\t * Resolve the properties of a file identified by the resource.\n\t *\n\t * If the optional parameter \"resolveTo\" is specified in options, the stat service is asked\n\t * to provide a stat object that should contain the full graph of folders up to all of the\n\t * target resources.\n\t *\n\t * If the optional parameter \"resolveSingleChildDescendants\" is specified in options,\n\t * the stat service is asked to automatically resolve child folders that only\n\t * contain a single element.\n\t */\n\tresolveFile(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\n\t/**\n\t * Same as resolveFile but supports resolving multiple resources in parallel.\n\t * If one of the resolve targets fails to resolve returns a fake IFileStat instead of making the whole call fail.\n\t */\n\tresolveFiles(toResolve: { resource: URI, options?: IResolveFileOptions }[]): Promise<IResolveFileResult[]>;\n\n\t/**\n\t * Finds out if a file identified by the resource exists.\n\t */\n\texistsFile(resource: URI): Promise<boolean>;\n\n\t/**\n\t * Resolve the contents of a file identified by the resource.\n\t *\n\t * The returned object contains properties of the file and the full value as string.\n\t */\n\tresolveContent(resource: URI, options?: IResolveContentOptions): Promise<IContent>;\n\n\t/**\n\t * Resolve the contents of a file identified by the resource.\n\t *\n\t * The returned object contains properties of the file and the value as a readable stream.\n\t */\n\tresolveStreamContent(resource: URI, options?: IResolveContentOptions): Promise<IStreamContent>;\n\n\t/**\n\t * Updates the content replacing its previous value.\n\t */\n\tupdateContent(resource: URI, value: string | ITextSnapshot, options?: IUpdateContentOptions): Promise<IFileStat>;\n\n\t/**\n\t * Moves the file to a new path identified by the resource.\n\t *\n\t * The optional parameter overwrite can be set to replace an existing file at the location.\n\t */\n\tmoveFile(source: URI, target: URI, overwrite?: boolean): Promise<IFileStat>;\n\n\t/**\n\t * Copies the file to a path identified by the resource.\n\t *\n\t * The optional parameter overwrite can be set to replace an existing file at the location.\n\t */\n\tcopyFile(source: URI, target: URI, overwrite?: boolean): Promise<IFileStat>;\n\n\t/**\n\t * Creates a new file with the given path. The returned promise\n\t * will have the stat model object as a result.\n\t *\n\t * The optional parameter content can be used as value to fill into the new file.\n\t */\n\tcreateFile(resource: URI, content?: string, options?: ICreateFileOptions): Promise<IFileStat>;\n\n\t/**\n\t * Reads a folder's content with the given path. The returned promise\n\t * will have the list of children as a result.\n\t */\n\treadFolder(resource: URI): Promise<string[]>;\n\n\t/**\n\t * Creates a new folder with the given path. The returned promise\n\t * will have the stat model object as a result.\n\t */\n\tcreateFolder(resource: URI): Promise<IFileStat>;\n\n\t/**\n\t * Deletes the provided file. The optional useTrash parameter allows to\n\t * move the file to trash. The optional recursive parameter allows to delete\n\t * non-empty folders recursively.\n\t */\n\tdel(resource: URI, options?: { useTrash?: boolean, recursive?: boolean }): Promise<void>;\n\n\t/**\n\t * Allows to start a watcher that reports file change events on the provided resource.\n\t */\n\twatchFileChanges(resource: URI): void;\n\n\t/**\n\t * Allows to stop a watcher on the provided resource or absolute fs path.\n\t */\n\tunwatchFileChanges(resource: URI): void;\n\n\t/**\n\t * Frees up any resources occupied by this service.\n\t */\n\tdispose(): void;\n}\n\nexport interface FileOverwriteOptions {\n\toverwrite: boolean;\n}\n\nexport interface FileWriteOptions {\n\toverwrite: boolean;\n\tcreate: boolean;\n}\n\nexport interface FileOpenOptions {\n\tcreate: boolean;\n}\n\nexport interface FileDeleteOptions {\n\trecursive: boolean;\n}\n\nexport enum FileType {\n\tUnknown = 0,\n\tFile = 1,\n\tDirectory = 2,\n\tSymbolicLink = 64\n}\n\nexport interface IStat {\n\ttype: FileType;\n\tmtime: number;\n\tctime: number;\n\tsize: number;\n}\n\nexport interface IWatchOptions {\n\trecursive: boolean;\n\texcludes: string[];\n}\n\nexport const enum FileSystemProviderCapabilities {\n\tFileReadWrite = 1 << 1,\n\tFileOpenReadWriteClose = 1 << 2,\n\tFileFolderCopy = 1 << 3,\n\n\tPathCaseSensitive = 1 << 10,\n\tReadonly = 1 << 11\n}\n\nexport interface IFileSystemProvider {\n\n\treadonly capabilities: FileSystemProviderCapabilities;\n\tonDidChangeCapabilities: Event<void>;\n\n\tonDidChangeFile: Event<IFileChange[]>;\n\twatch(resource: URI, opts: IWatchOptions): IDisposable;\n\n\tstat(resource: URI): Promise<IStat>;\n\tmkdir(resource: URI): Promise<void>;\n\treaddir(resource: URI): Promise<[string, FileType][]>;\n\tdelete(resource: URI, opts: FileDeleteOptions): Promise<void>;\n\n\trename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\tcopy?(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n\treadFile?(resource: URI): Promise<Uint8Array>;\n\twriteFile?(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n\n\topen?(resource: URI, opts: FileOpenOptions): Promise<number>;\n\tclose?(fd: number): Promise<void>;\n\tread?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\twrite?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport interface IFileSystemProviderRegistrationEvent {\n\tadded: boolean;\n\tscheme: string;\n\tprovider?: IFileSystemProvider;\n}\n\nexport const enum FileOperation {\n\tCREATE,\n\tDELETE,\n\tMOVE,\n\tCOPY\n}\n\nexport class FileOperationEvent {\n\n\tconstructor(private _resource: URI, private _operation: FileOperation, private _target?: IFileStat) {\n\t}\n\n\tget resource(): URI {\n\t\treturn this._resource;\n\t}\n\n\tget target(): IFileStat | undefined {\n\t\treturn this._target;\n\t}\n\n\tget operation(): FileOperation {\n\t\treturn this._operation;\n\t}\n}\n\n/**\n * Possible changes that can occur to a file.\n */\nexport const enum FileChangeType {\n\tUPDATED = 0,\n\tADDED = 1,\n\tDELETED = 2\n}\n\n/**\n * Identifies a single change in a file.\n */\nexport interface IFileChange {\n\n\t/**\n\t * The type of change that occurred to the file.\n\t */\n\ttype: FileChangeType;\n\n\t/**\n\t * The unified resource identifier of the file that changed.\n\t */\n\tresource: URI;\n}\n\nexport class FileChangesEvent {\n\n\tprivate _changes: IFileChange[];\n\n\tconstructor(changes: IFileChange[]) {\n\t\tthis._changes = changes;\n\t}\n\n\tget changes() {\n\t\treturn this._changes;\n\t}\n\n\t/**\n\t * Returns true if this change event contains the provided file with the given change type (if provided). In case of\n\t * type DELETED, this method will also return true if a folder got deleted that is the parent of the\n\t * provided file path.\n\t */\n\tcontains(resource: URI, type?: FileChangeType): boolean {\n\t\tif (!resource) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst checkForChangeType = !isUndefinedOrNull(type);\n\n\t\treturn this._changes.some(change => {\n\t\t\tif (checkForChangeType && change.type !== type) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// For deleted also return true when deleted folder is parent of target path\n\t\t\tif (change.type === FileChangeType.DELETED) {\n\t\t\t\treturn isEqualOrParent(resource, change.resource, !isLinux /* ignorecase */);\n\t\t\t}\n\n\t\t\treturn isEqual(resource, change.resource, !isLinux /* ignorecase */);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the changes that describe added files.\n\t */\n\tgetAdded(): IFileChange[] {\n\t\treturn this.getOfType(FileChangeType.ADDED);\n\t}\n\n\t/**\n\t * Returns if this event contains added files.\n\t */\n\tgotAdded(): boolean {\n\t\treturn this.hasType(FileChangeType.ADDED);\n\t}\n\n\t/**\n\t * Returns the changes that describe deleted files.\n\t */\n\tgetDeleted(): IFileChange[] {\n\t\treturn this.getOfType(FileChangeType.DELETED);\n\t}\n\n\t/**\n\t * Returns if this event contains deleted files.\n\t */\n\tgotDeleted(): boolean {\n\t\treturn this.hasType(FileChangeType.DELETED);\n\t}\n\n\t/**\n\t * Returns the changes that describe updated files.\n\t */\n\tgetUpdated(): IFileChange[] {\n\t\treturn this.getOfType(FileChangeType.UPDATED);\n\t}\n\n\t/**\n\t * Returns if this event contains updated files.\n\t */\n\tgotUpdated(): boolean {\n\t\treturn this.hasType(FileChangeType.UPDATED);\n\t}\n\n\tprivate getOfType(type: FileChangeType): IFileChange[] {\n\t\treturn this._changes.filter(change => change.type === type);\n\t}\n\n\tprivate hasType(type: FileChangeType): boolean {\n\t\treturn this._changes.some(change => {\n\t\t\treturn change.type === type;\n\t\t});\n\t}\n}\n\nexport function isParent(path: string, candidate: string, ignoreCase?: boolean): boolean {\n\tif (!path || !candidate || path === candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== sep) {\n\t\tcandidate += sep;\n\t}\n\n\tif (ignoreCase) {\n\t\treturn startsWithIgnoreCase(path, candidate);\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport interface IBaseStat {\n\n\t/**\n\t * The unified resource identifier of this file or folder.\n\t */\n\tresource: URI;\n\n\t/**\n\t * The name which is the last segement\n\t * of the {{path}}.\n\t */\n\tname: string;\n\n\t/**\n\t * The last modifictaion date represented\n\t * as millis from unix epoch.\n\t */\n\tmtime: number;\n\n\t/**\n\t * A unique identifier thet represents the\n\t * current state of the file or directory.\n\t */\n\tetag?: string;\n\n\t/**\n\t * The resource is readonly.\n\t */\n\tisReadonly?: boolean;\n}\n\n/**\n * A file resource with meta information.\n */\nexport interface IFileStat extends IBaseStat {\n\n\t/**\n\t * The resource is a directory. if {{true}}\n\t * {{encoding}} has no meaning.\n\t */\n\tisDirectory: boolean;\n\n\t/**\n\t * The resource is a symbolic link.\n\t */\n\tisSymbolicLink?: boolean;\n\n\t/**\n\t * The children of the file stat or undefined if none.\n\t */\n\tchildren?: IFileStat[];\n\n\t/**\n\t * The size of the file if known.\n\t */\n\tsize?: number;\n}\n\nexport interface IResolveFileResult {\n\tstat?: IFileStat;\n\tsuccess: boolean;\n}\n\n/**\n * Content and meta information of a file.\n */\nexport interface IContent extends IBaseStat {\n\n\t/**\n\t * The content of a text file.\n\t */\n\tvalue: string;\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\tencoding: string;\n}\n\n// this should eventually replace IContent such\n// that we have a clear separation between content\n// and metadata (TODO@Joh, TODO@Ben)\nexport interface IContentData {\n\tencoding: string;\n\tstream: IStringStream;\n}\n\n/**\n * A Stream emitting strings.\n */\nexport interface IStringStream {\n\ton(event: 'data', callback: (chunk: string) => void): void;\n\ton(event: 'error', callback: (err: any) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: string, callback: any): void;\n}\n\n/**\n * Text snapshot that works like an iterator.\n * Will try to return chunks of roughly ~64KB size.\n * Will return null when finished.\n */\nexport interface ITextSnapshot {\n\tread(): string | null;\n}\n\nexport class StringSnapshot implements ITextSnapshot {\n\tprivate _value: string | null;\n\tconstructor(value: string) {\n\t\tthis._value = value;\n\t}\n\tread(): string | null {\n\t\tlet ret = this._value;\n\t\tthis._value = null;\n\t\treturn ret;\n\t}\n}\n/**\n * Helper method to convert a snapshot into its full string form.\n */\nexport function snapshotToString(snapshot: ITextSnapshot): string {\n\tconst chunks: string[] = [];\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn chunks.join('');\n}\n\n/**\n * Streamable content and meta information of a file.\n */\nexport interface IStreamContent extends IBaseStat {\n\n\t/**\n\t * The streamable content of a text file.\n\t */\n\tvalue: IStringStream;\n\n\t/**\n\t * The encoding of the content if known.\n\t */\n\tencoding: string;\n}\n\nexport interface IResolveContentOptions {\n\n\t/**\n\t * The optional acceptTextOnly parameter allows to fail this request early if the file\n\t * contents are not textual.\n\t */\n\tacceptTextOnly?: boolean;\n\n\t/**\n\t * The optional etag parameter allows to return early from resolving the resource if\n\t * the contents on disk match the etag. This prevents accumulated reading of resources\n\t * that have been read already with the same etag.\n\t * It is the task of the caller to makes sure to handle this error case from the promise.\n\t */\n\tetag?: string;\n\n\t/**\n\t * The optional encoding parameter allows to specify the desired encoding when resolving\n\t * the contents of the file.\n\t */\n\tencoding?: string;\n\n\t/**\n\t * The optional guessEncoding parameter allows to guess encoding from content of the file.\n\t */\n\tautoGuessEncoding?: boolean;\n\n\t/**\n\t * Is an integer specifying where to begin reading from in the file. If position is null,\n\t * data will be read from the current file position.\n\t */\n\tposition?: number;\n}\n\nexport interface IUpdateContentOptions {\n\n\t/**\n\t * The encoding to use when updating a file.\n\t */\n\tencoding?: string;\n\n\t/**\n\t * If set to true, will enforce the selected encoding and not perform any detection using BOMs.\n\t */\n\toverwriteEncoding?: boolean;\n\n\t/**\n\t * Whether to overwrite a file even if it is readonly.\n\t */\n\toverwriteReadonly?: boolean;\n\n\t/**\n\t * Wether to write to the file as elevated (admin) user. When setting this option a prompt will\n\t * ask the user to authenticate as super user.\n\t */\n\twriteElevated?: boolean;\n\n\t/**\n\t * The last known modification time of the file. This can be used to prevent dirty writes.\n\t */\n\tmtime?: number;\n\n\t/**\n\t * The etag of the file. This can be used to prevent dirty writes.\n\t */\n\tetag?: string;\n\n\t/**\n\t * Run mkdirp before saving.\n\t */\n\tmkdirp?: boolean;\n}\n\nexport interface IResolveFileOptions {\n\tresolveTo?: URI[];\n\tresolveSingleChildDescendants?: boolean;\n}\n\nexport interface ICreateFileOptions {\n\n\t/**\n\t * Overwrite the file to create if it already exists on disk. Otherwise\n\t * an error will be thrown (FILE_MODIFIED_SINCE).\n\t */\n\toverwrite?: boolean;\n}\n\nexport class FileOperationError extends Error {\n\tconstructor(message: string, public fileOperationResult: FileOperationResult, public options?: IResolveContentOptions & IUpdateContentOptions & ICreateFileOptions) {\n\t\tsuper(message);\n\t}\n\n\tstatic isFileOperationError(obj: any): obj is FileOperationError {\n\t\treturn obj instanceof Error && !isUndefinedOrNull((obj as FileOperationError).fileOperationResult);\n\t}\n}\n\nexport const enum FileOperationResult {\n\tFILE_IS_BINARY,\n\tFILE_IS_DIRECTORY,\n\tFILE_NOT_FOUND,\n\tFILE_NOT_MODIFIED_SINCE,\n\tFILE_MODIFIED_SINCE,\n\tFILE_MOVE_CONFLICT,\n\tFILE_READ_ONLY,\n\tFILE_PERMISSION_DENIED,\n\tFILE_TOO_LARGE,\n\tFILE_INVALID_PATH,\n\tFILE_EXCEED_MEMORY_LIMIT\n}\n\nexport const AutoSaveConfiguration = {\n\tOFF: 'off',\n\tAFTER_DELAY: 'afterDelay',\n\tON_FOCUS_CHANGE: 'onFocusChange',\n\tON_WINDOW_CHANGE: 'onWindowChange'\n};\n\nexport const HotExitConfiguration = {\n\tOFF: 'off',\n\tON_EXIT: 'onExit',\n\tON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'\n};\n\nexport const CONTENT_CHANGE_EVENT_BUFFER_DELAY = 1000;\n\nexport const FILES_ASSOCIATIONS_CONFIG = 'files.associations';\nexport const FILES_EXCLUDE_CONFIG = 'files.exclude';\n\nexport interface IFilesConfiguration {\n\tfiles: {\n\t\tassociations: { [filepattern: string]: string };\n\t\texclude: glob.IExpression;\n\t\twatcherExclude: { [filepattern: string]: boolean };\n\t\tencoding: string;\n\t\tautoGuessEncoding: boolean;\n\t\tdefaultLanguage: string;\n\t\ttrimTrailingWhitespace: boolean;\n\t\tautoSave: string;\n\t\tautoSaveDelay: number;\n\t\teol: string;\n\t\thotExit: string;\n\t\tuseExperimentalFileWatcher: boolean;\n\t};\n}\n\nexport const SUPPORTED_ENCODINGS: { [encoding: string]: { labelLong: string; labelShort: string; order: number; encodeOnly?: boolean; alias?: string } } = {\n\tutf8: {\n\t\tlabelLong: 'UTF-8',\n\t\tlabelShort: 'UTF-8',\n\t\torder: 1,\n\t\talias: 'utf8bom'\n\t},\n\tutf8bom: {\n\t\tlabelLong: 'UTF-8 with BOM',\n\t\tlabelShort: 'UTF-8 with BOM',\n\t\tencodeOnly: true,\n\t\torder: 2,\n\t\talias: 'utf8'\n\t},\n\tutf16le: {\n\t\tlabelLong: 'UTF-16 LE',\n\t\tlabelShort: 'UTF-16 LE',\n\t\torder: 3\n\t},\n\tutf16be: {\n\t\tlabelLong: 'UTF-16 BE',\n\t\tlabelShort: 'UTF-16 BE',\n\t\torder: 4\n\t},\n\twindows1252: {\n\t\tlabelLong: 'Western (Windows 1252)',\n\t\tlabelShort: 'Windows 1252',\n\t\torder: 5\n\t},\n\tiso88591: {\n\t\tlabelLong: 'Western (ISO 8859-1)',\n\t\tlabelShort: 'ISO 8859-1',\n\t\torder: 6\n\t},\n\tiso88593: {\n\t\tlabelLong: 'Western (ISO 8859-3)',\n\t\tlabelShort: 'ISO 8859-3',\n\t\torder: 7\n\t},\n\tiso885915: {\n\t\tlabelLong: 'Western (ISO 8859-15)',\n\t\tlabelShort: 'ISO 8859-15',\n\t\torder: 8\n\t},\n\tmacroman: {\n\t\tlabelLong: 'Western (Mac Roman)',\n\t\tlabelShort: 'Mac Roman',\n\t\torder: 9\n\t},\n\tcp437: {\n\t\tlabelLong: 'DOS (CP 437)',\n\t\tlabelShort: 'CP437',\n\t\torder: 10\n\t},\n\twindows1256: {\n\t\tlabelLong: 'Arabic (Windows 1256)',\n\t\tlabelShort: 'Windows 1256',\n\t\torder: 11\n\t},\n\tiso88596: {\n\t\tlabelLong: 'Arabic (ISO 8859-6)',\n\t\tlabelShort: 'ISO 8859-6',\n\t\torder: 12\n\t},\n\twindows1257: {\n\t\tlabelLong: 'Baltic (Windows 1257)',\n\t\tlabelShort: 'Windows 1257',\n\t\torder: 13\n\t},\n\tiso88594: {\n\t\tlabelLong: 'Baltic (ISO 8859-4)',\n\t\tlabelShort: 'ISO 8859-4',\n\t\torder: 14\n\t},\n\tiso885914: {\n\t\tlabelLong: 'Celtic (ISO 8859-14)',\n\t\tlabelShort: 'ISO 8859-14',\n\t\torder: 15\n\t},\n\twindows1250: {\n\t\tlabelLong: 'Central European (Windows 1250)',\n\t\tlabelShort: 'Windows 1250',\n\t\torder: 16\n\t},\n\tiso88592: {\n\t\tlabelLong: 'Central European (ISO 8859-2)',\n\t\tlabelShort: 'ISO 8859-2',\n\t\torder: 17\n\t},\n\tcp852: {\n\t\tlabelLong: 'Central European (CP 852)',\n\t\tlabelShort: 'CP 852',\n\t\torder: 18\n\t},\n\twindows1251: {\n\t\tlabelLong: 'Cyrillic (Windows 1251)',\n\t\tlabelShort: 'Windows 1251',\n\t\torder: 19\n\t},\n\tcp866: {\n\t\tlabelLong: 'Cyrillic (CP 866)',\n\t\tlabelShort: 'CP 866',\n\t\torder: 20\n\t},\n\tiso88595: {\n\t\tlabelLong: 'Cyrillic (ISO 8859-5)',\n\t\tlabelShort: 'ISO 8859-5',\n\t\torder: 21\n\t},\n\tkoi8r: {\n\t\tlabelLong: 'Cyrillic (KOI8-R)',\n\t\tlabelShort: 'KOI8-R',\n\t\torder: 22\n\t},\n\tkoi8u: {\n\t\tlabelLong: 'Cyrillic (KOI8-U)',\n\t\tlabelShort: 'KOI8-U',\n\t\torder: 23\n\t},\n\tiso885913: {\n\t\tlabelLong: 'Estonian (ISO 8859-13)',\n\t\tlabelShort: 'ISO 8859-13',\n\t\torder: 24\n\t},\n\twindows1253: {\n\t\tlabelLong: 'Greek (Windows 1253)',\n\t\tlabelShort: 'Windows 1253',\n\t\torder: 25\n\t},\n\tiso88597: {\n\t\tlabelLong: 'Greek (ISO 8859-7)',\n\t\tlabelShort: 'ISO 8859-7',\n\t\torder: 26\n\t},\n\twindows1255: {\n\t\tlabelLong: 'Hebrew (Windows 1255)',\n\t\tlabelShort: 'Windows 1255',\n\t\torder: 27\n\t},\n\tiso88598: {\n\t\tlabelLong: 'Hebrew (ISO 8859-8)',\n\t\tlabelShort: 'ISO 8859-8',\n\t\torder: 28\n\t},\n\tiso885910: {\n\t\tlabelLong: 'Nordic (ISO 8859-10)',\n\t\tlabelShort: 'ISO 8859-10',\n\t\torder: 29\n\t},\n\tiso885916: {\n\t\tlabelLong: 'Romanian (ISO 8859-16)',\n\t\tlabelShort: 'ISO 8859-16',\n\t\torder: 30\n\t},\n\twindows1254: {\n\t\tlabelLong: 'Turkish (Windows 1254)',\n\t\tlabelShort: 'Windows 1254',\n\t\torder: 31\n\t},\n\tiso88599: {\n\t\tlabelLong: 'Turkish (ISO 8859-9)',\n\t\tlabelShort: 'ISO 8859-9',\n\t\torder: 32\n\t},\n\twindows1258: {\n\t\tlabelLong: 'Vietnamese (Windows 1258)',\n\t\tlabelShort: 'Windows 1258',\n\t\torder: 33\n\t},\n\tgbk: {\n\t\tlabelLong: 'Simplified Chinese (GBK)',\n\t\tlabelShort: 'GBK',\n\t\torder: 34\n\t},\n\tgb18030: {\n\t\tlabelLong: 'Simplified Chinese (GB18030)',\n\t\tlabelShort: 'GB18030',\n\t\torder: 35\n\t},\n\tcp950: {\n\t\tlabelLong: 'Traditional Chinese (Big5)',\n\t\tlabelShort: 'Big5',\n\t\torder: 36\n\t},\n\tbig5hkscs: {\n\t\tlabelLong: 'Traditional Chinese (Big5-HKSCS)',\n\t\tlabelShort: 'Big5-HKSCS',\n\t\torder: 37\n\t},\n\tshiftjis: {\n\t\tlabelLong: 'Japanese (Shift JIS)',\n\t\tlabelShort: 'Shift JIS',\n\t\torder: 38\n\t},\n\teucjp: {\n\t\tlabelLong: 'Japanese (EUC-JP)',\n\t\tlabelShort: 'EUC-JP',\n\t\torder: 39\n\t},\n\teuckr: {\n\t\tlabelLong: 'Korean (EUC-KR)',\n\t\tlabelShort: 'EUC-KR',\n\t\torder: 40\n\t},\n\twindows874: {\n\t\tlabelLong: 'Thai (Windows 874)',\n\t\tlabelShort: 'Windows 874',\n\t\torder: 41\n\t},\n\tiso885911: {\n\t\tlabelLong: 'Latin/Thai (ISO 8859-11)',\n\t\tlabelShort: 'ISO 8859-11',\n\t\torder: 42\n\t},\n\tkoi8ru: {\n\t\tlabelLong: 'Cyrillic (KOI8-RU)',\n\t\tlabelShort: 'KOI8-RU',\n\t\torder: 43\n\t},\n\tkoi8t: {\n\t\tlabelLong: 'Tajik (KOI8-T)',\n\t\tlabelShort: 'KOI8-T',\n\t\torder: 44\n\t},\n\tgb2312: {\n\t\tlabelLong: 'Simplified Chinese (GB 2312)',\n\t\tlabelShort: 'GB 2312',\n\t\torder: 45\n\t},\n\tcp865: {\n\t\tlabelLong: 'Nordic DOS (CP 865)',\n\t\tlabelShort: 'CP 865',\n\t\torder: 46\n\t},\n\tcp850: {\n\t\tlabelLong: 'Western European DOS (CP 850)',\n\t\tlabelShort: 'CP 850',\n\t\torder: 47\n\t}\n};\n\nexport enum FileKind {\n\tFILE,\n\tFOLDER,\n\tROOT_FOLDER\n}\n\nexport const MIN_MAX_MEMORY_SIZE_MB = 2048;\nexport const FALLBACK_MAX_MEMORY_SIZE_MB = 4096;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI as uri } from 'vs/base/common/uri';\nimport { FileChangeType, FileChangesEvent, isParent } from 'vs/platform/files/common/files';\nimport { isLinux } from 'vs/base/common/platform';\n\nexport interface IRawFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport function toFileChangesEvent(changes: IRawFileChange[]): FileChangesEvent {\n\n\t// map to file changes event that talks about URIs\n\treturn new FileChangesEvent(changes.map((c) => {\n\t\treturn {\n\t\t\ttype: c.type,\n\t\t\tresource: uri.file(c.path)\n\t\t};\n\t}));\n}\n\n/**\n * Given events that occurred, applies some rules to normalize the events\n */\nexport function normalize(changes: IRawFileChange[]): IRawFileChange[] {\n\n\t// Build deltas\n\tlet normalizer = new EventNormalizer();\n\tfor (const event of changes) {\n\t\tnormalizer.processEvent(event);\n\t}\n\n\treturn normalizer.normalize();\n}\n\nclass EventNormalizer {\n\tprivate normalized: IRawFileChange[];\n\tprivate mapPathToChange: { [path: string]: IRawFileChange };\n\n\tconstructor() {\n\t\tthis.normalized = [];\n\t\tthis.mapPathToChange = Object.create(null);\n\t}\n\n\tpublic processEvent(event: IRawFileChange): void {\n\n\t\t// Event path already exists\n\t\tlet existingEvent = this.mapPathToChange[event.path];\n\t\tif (existingEvent) {\n\t\t\tlet currentChangeType = existingEvent.type;\n\t\t\tlet newChangeType = event.type;\n\n\t\t\t// ignore CREATE followed by DELETE in one go\n\t\t\tif (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tdelete this.mapPathToChange[event.path];\n\t\t\t\tthis.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n\t\t\t}\n\n\t\t\t// flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) {\n\t\t\t}\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise Store\n\t\telse {\n\t\t\tthis.normalized.push(event);\n\t\t\tthis.mapPathToChange[event.path] = event;\n\t\t}\n\t}\n\n\tpublic normalize(): IRawFileChange[] {\n\t\tlet addedChangeEvents: IRawFileChange[] = [];\n\t\tlet deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn this.normalized.filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddedChangeEvents.push(e);\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(d => isParent(e.path, d, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addedChangeEvents);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChannel, IServerChannel } from 'vs/base/parts/ipc/node/ipc';\nimport { IWatcherRequest, IWatcherService, IWatcherOptions, IWatchError } from './watcher';\nimport { Event } from 'vs/base/common/event';\nimport { IRawFileChange } from 'vs/workbench/services/files/node/watcher/common';\n\nexport class WatcherChannel implements IServerChannel {\n\n\tconstructor(private service: IWatcherService) { }\n\n\tlisten(_, event: string, arg?: any): Event<any> {\n\t\tswitch (event) {\n\t\t\tcase 'watch': return this.service.watch(arg);\n\t\t}\n\n\t\tthrow new Error(`Event not found: ${event}`);\n\t}\n\n\tcall(_, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'setRoots': return this.service.setRoots(arg);\n\t\t\tcase 'setVerboseLogging': return this.service.setVerboseLogging(arg);\n\t\t\tcase 'stop': return this.service.stop();\n\t\t}\n\n\t\tthrow new Error(`Call not found: ${command}`);\n\t}\n}\n\nexport class WatcherChannelClient implements IWatcherService {\n\n\tconstructor(private channel: IChannel) { }\n\n\twatch(options: IWatcherOptions): Event<IRawFileChange[] | IWatchError> {\n\t\treturn this.channel.listen('watch', options);\n\t}\n\n\tsetVerboseLogging(enable: boolean): Promise<void> {\n\t\treturn this.channel.call('setVerboseLogging', enable);\n\t}\n\n\tsetRoots(roots: IWatcherRequest[]): Promise<void> {\n\t\treturn this.channel.call('setRoots', roots);\n\t}\n\n\tstop(): Promise<void> {\n\t\treturn this.channel.call('stop');\n\t}\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as chokidar from 'vscode-chokidar';\n// import * as fs from 'fs';\n// import * as gracefulFs from 'graceful-fs';\n// gracefulFs.gracefulify(fs);\nimport * as extpath from 'vs/base/common/extpath';\nimport * as glob from 'vs/base/common/glob';\nimport { FileChangeType } from 'vs/platform/files/common/files';\nimport { ThrottledDelayer } from 'vs/base/common/async';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { realcaseSync } from 'vs/base/node/extfs';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport * as watcherCommon from 'vs/workbench/services/files/node/watcher/common';\nimport { IWatcherRequest, IWatcherService, IWatcherOptions, IWatchError } from 'vs/workbench/services/files/node/watcher/unix/watcher';\nimport { Emitter, Event } from 'vs/base/common/event';\n\ninterface IWatcher {\n\trequests: ExtendedWatcherRequest[];\n\tstop(): any;\n}\n\nexport interface IChockidarWatcherOptions {\n\tpollingInterval?: number;\n}\n\ninterface ExtendedWatcherRequest extends IWatcherRequest {\n\tparsedPattern?: glob.ParsedPattern;\n}\n\nexport class ChokidarWatcherService implements IWatcherService {\n\n\tprivate static readonly FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n\tprivate static readonly EVENT_SPAM_WARNING_THRESHOLD = 60 * 1000; // warn after certain time span of event spam\n\n\tprivate _watchers: { [watchPath: string]: IWatcher };\n\tprivate _watcherCount: number;\n\n\tprivate _pollingInterval?: number;\n\tprivate _verboseLogging: boolean;\n\n\tprivate spamCheckStartTime: number;\n\tprivate spamWarningLogged: boolean;\n\tprivate enospcErrorLogged: boolean;\n\n\tprivate _onWatchEvent = new Emitter<watcherCommon.IRawFileChange[] | IWatchError>();\n\treadonly onWatchEvent = this._onWatchEvent.event;\n\n\tpublic watch(options: IWatcherOptions & IChockidarWatcherOptions): Event<watcherCommon.IRawFileChange[] | IWatchError> {\n\t\tthis._verboseLogging = options.verboseLogging;\n\t\tthis._pollingInterval = options.pollingInterval;\n\t\tthis._watchers = Object.create(null);\n\t\tthis._watcherCount = 0;\n\t\treturn this.onWatchEvent;\n\t}\n\n\tpublic setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tthis._verboseLogging = enabled;\n\n\t\treturn Promise.resolve();\n\t}\n\n\tpublic setRoots(requests: IWatcherRequest[]): Promise<void> {\n\t\tconst watchers = Object.create(null);\n\t\tconst newRequests: string[] = [];\n\n\t\tconst requestsByBasePath = normalizeRoots(requests);\n\n\t\t// evaluate new & remaining watchers\n\t\tfor (let basePath in requestsByBasePath) {\n\t\t\tlet watcher = this._watchers[basePath];\n\t\t\tif (watcher && isEqualRequests(watcher.requests, requestsByBasePath[basePath])) {\n\t\t\t\twatchers[basePath] = watcher;\n\t\t\t\tdelete this._watchers[basePath];\n\t\t\t} else {\n\t\t\t\tnewRequests.push(basePath);\n\t\t\t}\n\t\t}\n\t\t// stop all old watchers\n\t\tfor (let path in this._watchers) {\n\t\t\tthis._watchers[path].stop();\n\t\t}\n\t\t// start all new watchers\n\t\tfor (let basePath of newRequests) {\n\t\t\tlet requests = requestsByBasePath[basePath];\n\t\t\twatchers[basePath] = this._watch(basePath, requests);\n\t\t}\n\n\t\tthis._watchers = watchers;\n\t\treturn Promise.resolve();\n\t}\n\n\t// for test purposes\n\tpublic get wacherCount() {\n\t\treturn this._watcherCount;\n\t}\n\n\tprivate _watch(basePath: string, requests: IWatcherRequest[]): IWatcher {\n\t\tif (this._verboseLogging) {\n\t\t\tconsole.log(`Start watching: ${basePath}]`);\n\t\t}\n\n\t\tconst pollingInterval = this._pollingInterval || 1000;\n\n\t\tconst watcherOpts: chokidar.IOptions = {\n\t\t\tignoreInitial: true,\n\t\t\tignorePermissionErrors: true,\n\t\t\tfollowSymlinks: true, // this is the default of chokidar and supports file events through symlinks\n\t\t\tinterval: pollingInterval, // while not used in normal cases, if any error causes chokidar to fallback to polling, increase its intervals\n\t\t\tbinaryInterval: pollingInterval,\n\t\t\tdisableGlobbing: true // fix https://github.com/Microsoft/vscode/issues/4586\n\t\t};\n\n\t\t// if there's only one request, use the built-in ignore-filterering\n\t\tconst isSingleFolder = requests.length === 1;\n\t\tif (isSingleFolder) {\n\t\t\twatcherOpts.ignored = requests[0].ignored;\n\t\t}\n\n\t\t// Chokidar fails when the basePath does not match case-identical to the path on disk\n\t\t// so we have to find the real casing of the path and do some path massaging to fix this\n\t\t// see https://github.com/paulmillr/chokidar/issues/418\n\t\tconst realBasePath = isMacintosh ? (realcaseSync(basePath) || basePath) : basePath;\n\t\tconst realBasePathLength = realBasePath.length;\n\t\tconst realBasePathDiffers = (basePath !== realBasePath);\n\n\t\tif (realBasePathDiffers) {\n\t\t\tconsole.warn(`Watcher basePath does not match version on disk and was corrected (original: ${basePath}, real: ${realBasePath})`);\n\t\t}\n\n\t\tlet chokidarWatcher: chokidar.FSWatcher | null = chokidar.watch(realBasePath, watcherOpts);\n\t\tthis._watcherCount++;\n\n\t\t// Detect if for some reason the native watcher library fails to load\n\t\tif (isMacintosh && !chokidarWatcher.options.useFsEvents) {\n\t\t\tconsole.error('Watcher is not using native fsevents library and is falling back to unefficient polling.');\n\t\t}\n\n\t\tlet undeliveredFileEvents: watcherCommon.IRawFileChange[] = [];\n\t\tlet fileEventDelayer: ThrottledDelayer<undefined> | null = new ThrottledDelayer(ChokidarWatcherService.FS_EVENT_DELAY);\n\n\t\tconst watcher: IWatcher = {\n\t\t\trequests,\n\t\t\tstop: () => {\n\t\t\t\ttry {\n\t\t\t\t\tif (this._verboseLogging) {\n\t\t\t\t\t\tconsole.log(`Stop watching: ${basePath}]`);\n\t\t\t\t\t}\n\t\t\t\t\tif (chokidarWatcher) {\n\t\t\t\t\t\tchokidarWatcher.close();\n\t\t\t\t\t\tthis._watcherCount--;\n\t\t\t\t\t\tchokidarWatcher = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (fileEventDelayer) {\n\t\t\t\t\t\tfileEventDelayer.cancel();\n\t\t\t\t\t\tfileEventDelayer = null;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(error.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tchokidarWatcher.on('all', (type: string, path: string) => {\n\t\t\tif (isMacintosh) {\n\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\tpath = normalizeNFC(path);\n\t\t\t}\n\n\t\t\tif (path.indexOf(realBasePath) < 0) {\n\t\t\t\treturn; // we really only care about absolute paths here in our basepath context here\n\t\t\t}\n\n\t\t\t// Make sure to convert the path back to its original basePath form if the realpath is different\n\t\t\tif (realBasePathDiffers) {\n\t\t\t\tpath = basePath + path.substr(realBasePathLength);\n\t\t\t}\n\n\t\t\tlet eventType: FileChangeType;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'change':\n\t\t\t\t\teventType = FileChangeType.UPDATED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'add':\n\t\t\t\tcase 'addDir':\n\t\t\t\t\teventType = FileChangeType.ADDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'unlink':\n\t\t\t\tcase 'unlinkDir':\n\t\t\t\t\teventType = FileChangeType.DELETED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if there's more than one request we need to do\n\t\t\t// extra filtering due to potentially overlapping roots\n\t\t\tif (!isSingleFolder) {\n\t\t\t\tif (isIgnored(path, watcher.requests)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet event = { type: eventType, path };\n\n\t\t\t// Logging\n\t\t\tif (this._verboseLogging) {\n\t\t\t\tconsole.log(`${eventType === FileChangeType.ADDED ? '[ADDED]' : eventType === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${path}`);\n\t\t\t}\n\n\t\t\t// Check for spam\n\t\t\tconst now = Date.now();\n\t\t\tif (undeliveredFileEvents.length === 0) {\n\t\t\t\tthis.spamWarningLogged = false;\n\t\t\t\tthis.spamCheckStartTime = now;\n\t\t\t} else if (!this.spamWarningLogged && this.spamCheckStartTime + ChokidarWatcherService.EVENT_SPAM_WARNING_THRESHOLD < now) {\n\t\t\t\tthis.spamWarningLogged = true;\n\t\t\t\tconsole.warn(`Watcher is busy catching up with ${undeliveredFileEvents.length} file changes in 60 seconds. Latest changed path is \"${event.path}\"`);\n\t\t\t}\n\n\t\t\t// Add to buffer\n\t\t\tundeliveredFileEvents.push(event);\n\n\t\t\tif (fileEventDelayer) {\n\t\t\t\t// Delay and send buffer\n\t\t\t\tfileEventDelayer.trigger(() => {\n\t\t\t\t\tconst events = undeliveredFileEvents;\n\t\t\t\t\tundeliveredFileEvents = [];\n\n\t\t\t\t\t// Broadcast to clients normalized\n\t\t\t\t\tconst res = watcherCommon.normalize(events);\n\t\t\t\t\tthis._onWatchEvent.fire(res);\n\n\t\t\t\t\t// Logging\n\t\t\t\t\tif (this._verboseLogging) {\n\t\t\t\t\t\tres.forEach(r => {\n\t\t\t\t\t\t\tconsole.log(` >> normalized  ${r.type === FileChangeType.ADDED ? '[ADDED]' : r.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${r.path}`);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.resolve(undefined);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tchokidarWatcher.on('error', (error: Error) => {\n\t\t\tif (error) {\n\n\t\t\t\t// Specially handle ENOSPC errors that can happen when\n\t\t\t\t// the watcher consumes so many file descriptors that\n\t\t\t\t// we are running into a limit. We only want to warn\n\t\t\t\t// once in this case to avoid log spam.\n\t\t\t\t// See https://github.com/Microsoft/vscode/issues/7950\n\t\t\t\tif ((<any>error).code === 'ENOSPC') {\n\t\t\t\t\tif (!this.enospcErrorLogged) {\n\t\t\t\t\t\tthis.enospcErrorLogged = true;\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\tthis._onWatchEvent.fire({ message: 'Inotify limit reached (ENOSPC)' });\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(error.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn watcher;\n\t}\n\n\tpublic stop(): Promise<void> {\n\t\tfor (let path in this._watchers) {\n\t\t\tlet watcher = this._watchers[path];\n\t\t\twatcher.stop();\n\t\t}\n\t\tthis._watchers = Object.create(null);\n\t\treturn Promise.resolve();\n\t}\n}\n\nfunction isIgnored(path: string, requests: ExtendedWatcherRequest[]): boolean {\n\tfor (let request of requests) {\n\t\tif (request.basePath === path) {\n\t\t\treturn false;\n\t\t}\n\t\tif (extpath.isEqualOrParent(path, request.basePath)) {\n\t\t\tif (!request.parsedPattern) {\n\t\t\t\tif (request.ignored && request.ignored.length > 0) {\n\t\t\t\t\tlet pattern = `{${request.ignored.join(',')}}`;\n\t\t\t\t\trequest.parsedPattern = glob.parse(pattern);\n\t\t\t\t} else {\n\t\t\t\t\trequest.parsedPattern = () => false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst relPath = path.substr(request.basePath.length + 1);\n\t\t\tif (!request.parsedPattern(relPath)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Normalizes a set of root paths by grouping by the most parent root path.\n * equests with Sub paths are skipped if they have the same ignored set as the parent.\n */\nexport function normalizeRoots(requests: IWatcherRequest[]): { [basePath: string]: IWatcherRequest[] } {\n\trequests = requests.sort((r1, r2) => r1.basePath.localeCompare(r2.basePath));\n\tlet prevRequest: IWatcherRequest | null = null;\n\tlet result: { [basePath: string]: IWatcherRequest[] } = Object.create(null);\n\tfor (let request of requests) {\n\t\tlet basePath = request.basePath;\n\t\tlet ignored = (request.ignored || []).sort();\n\t\tif (prevRequest && (extpath.isEqualOrParent(basePath, prevRequest.basePath))) {\n\t\t\tif (!isEqualIgnore(ignored, prevRequest.ignored)) {\n\t\t\t\tresult[prevRequest.basePath].push({ basePath, ignored });\n\t\t\t}\n\t\t} else {\n\t\t\tprevRequest = { basePath, ignored };\n\t\t\tresult[basePath] = [prevRequest];\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction isEqualRequests(r1: IWatcherRequest[], r2: IWatcherRequest[]) {\n\tif (r1.length !== r2.length) {\n\t\treturn false;\n\t}\n\tfor (let k = 0; k < r1.length; k++) {\n\t\tif (r1[k].basePath !== r2[k].basePath || !isEqualIgnore(r1[k].ignored, r2[k].ignored)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction isEqualIgnore(i1: string[], i2: string[]) {\n\tif (i1.length !== i2.length) {\n\t\treturn false;\n\t}\n\tfor (let k = 0; k < i1.length; k++) {\n\t\tif (i1[k] !== i2[k]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Server } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { WatcherChannel } from 'vs/workbench/services/files/node/watcher/unix/watcherIpc';\nimport { ChokidarWatcherService } from 'vs/workbench/services/files/node/watcher/unix/chokidarWatcherService';\n\nconst server = new Server('watcher');\nconst service = new ChokidarWatcherService();\nconst channel = new WatcherChannel(service);\nserver.registerChannel('watcher', channel);"]}