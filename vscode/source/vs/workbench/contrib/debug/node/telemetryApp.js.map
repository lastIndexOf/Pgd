{"version":3,"sources":["vs/workbench/contrib/debug/node/fake","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/errors.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/functional.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/iterator.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/lifecycle.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/linkedList.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/event.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/cancellation.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/async.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/platform.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/process.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/path.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/strings.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/extpath.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/types.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/objects.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/uri.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/amd.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/console.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/decoder.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/node/processes.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.cp.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/instantiation/common/instantiation.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/log/common/log.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/telemetry/node/appInsightsAppender.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/telemetry/node/telemetryIpc.ts","vs/workbench/contrib/debug/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/workbench/contrib/debug/node/telemetryApp.ts"],"names":["__m","__M","deps","result","i","len","length","isPromiseCanceledError","error","Error","name","canceledName","message","ErrorHandler","[object Object]","this","listeners","unexpectedErrorHandler","e","setTimeout","stack","listener","push","_removeListener","forEach","splice","indexOf","newUnexpectedErrorHandler","emit","exports","errorHandler","setUnexpectedErrorHandler","onUnexpectedError","onUnexpectedExternalError","transformErrorForSerialization","$isError","stacktrace","canceled","illegalArgument","illegalState","readonly","disposed","what","getErrorMessage","err","split","String","once","fn","_this","didCall","apply","arguments","FIN","done","value","undefined","Iterator","iterator","next","_empty","empty","fromArray","array","index","from","elements","Array","isArray","map","element","filter","collect","getSequenceIterator","arg","ArrayIterator","items","start","end","current","Math","min","ArrayNavigator","super","max","MappedIterator","MappedNavigator","navigator","previous","parent","first","last","dispose","rest","d","isDisposable","thing","combinedDisposable","disposables","toDisposable","Disposable","_toDispose","_lifecycle_disposable_isDisposed","toDispose","t","console","warn","None","Object","freeze","ReferenceCollection","references","create","key","reference","counter","object","createReferencedObject","functional_1","destroyReferencedObject","ImmortalReference","Node","LinkedList","_size","size","_first","_last","_insert","atTheEnd","newNode","oldLast","prev","oldFirst","_remove","bind","res","node","candidate","anchor","iterator_1","Event","event","thisArgs","didFire","call","snapshot","each","reduce","merge","initial","output","emitter","Emitter","fire","latch","cache","firstCall","shouldEmit","_disposable","signal","any","events","lifecycle_1","debounce","delay","leading","leakWarningThreshold","subscription","handle","numDebouncedCalls","cur","clearTimeout","_output","stopwatch","Date","getTime","_","buffer","nextTick","_buffer","slice","flush","echo","ChainableEvent","chain","fromNodeEventEmitter","eventName","id","args","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromPromise","promise","then","toPromise","Promise","c","_globalLeakWarningThreshold","setGlobalLeakWarningThreshold","n","oldValue","LeakageMonitor","customThreshold","random","toString","_warnCountdown","_stacks","clear","listenerCount","threshold","Map","join","count","get","set","topStack","topCount","options","_disposed","_options","_leakageMon","_event","_listeners","linkedList_1","firstListener","isEmpty","remove","onFirstListenerDidAdd","onListenerDidAdd","removeMonitor","check","_noop","_deliveryQueue","iter","shift","errors_1","AsyncEmitter","eventFn","_asyncDeliveryQueue","thenables","all","EventMultiplexer","hasListeners","hook","unhook","idx","r","EventBufferer","buffers","pop","Relay","listening","inputEvent","inputEventListener","input","shortcutEvent","callback","context","CancellationToken","isCancellationToken","Cancelled","MutableToken","isCancellationRequested","onCancellationRequested","event_1","_isCancelled","_emitter","CancellationTokenSource","token","_token","cancel","isThenable","obj","createCancelablePromise","source","cancellation_1","thenable","resolve","reject","errors","onfinally","finally","timeout","millis","sequence","promiseFactories","thenHandler","results","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","Sequencer","promiseTask","Delayer","defaultDelay","completionPromise","doResolve","task","cancelTimeout","doReject","ThrottledDelayer","delayer","throttler","trigger","isTriggered","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","timer","ignoreErrors","shouldStop","defaultValue","loop","factory","Limiter","maxDegreeOfParalellism","outstandingPromises","runningPromises","_onFinished","onFinished","consume","iLimitedTask","consumed","Queue","ResourceQueue","queues","resource","TimeoutTimer","runner","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","isScheduled","doRun","RunOnceWorker","units","unit","schedule","nfcall","ninvoke","thisArg","requestIdleCallback","cancelIdleCallback","dummyIdle","didTimeout","timeRemaining","runWhenIdle","IdleValue","executor","_executor","_value","_error","_didRun","_handle","LANGUAGE_DEFAULT","_isWindows","_isMacintosh","_isNative","_locale","_language","_translationsConfigFile","isElectronRenderer","process","versions","electron","type","platform","rawNlsConfig","env","nlsConfig","JSON","parse","resolved","availableLanguages","locale","userAgent","language","Platform","PlatformToString","isRealWindows","isWindows","isMacintosh","isLinux","isNative","isWeb","isRootUser","getuid","translationsConfigFile","_globals","self","global","globals","_setImmediate","setImmediate","OperatingSystem","OS","safeProcess","cwd","platform_1","validateString","ErrorInvalidArgType","isPathSeparator","code","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","isPosixPathSeparator","isWindowsDeviceRoot","CHAR_UPPERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_A","CHAR_LOWERCASE_Z","normalizeString","path","allowAboveRoot","separator","lastSegmentLength","lastSlash","dots","charCodeAt","CHAR_DOT","lastSlashIndex","lastIndexOf","_format","sep","pathObject","dir","root","base","ext","expected","actual","determiner","replace","msg","win32","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","toLowerCase","rootEnd","device","isAbsolute","j","firstPart","tail","paths","joined","needsReplace","slashCount","firstLen","normalize","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","resolvedPath","matchedSlash","offset","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","delimiter","posix","trailingSeparator","toNamespacedPath","hasRoot","relative","dirname","basename","extname","format","escapeRegExpCharacters","ltrim","haystack","needle","needleLen","substring","rtrim","haystackLen","compare","a","b","isLowerAsciiLetter","isUpperAsciiLetter","isAsciiLetter","doEqualsIgnoreCase","stopAt","codeA","codeB","diff","abs","fromCharCode","substrEquals","aStart","aEnd","bStart","bEnd","isFullWidthCharacter","charCode","startsWithUTF8BOM","str","isFalsyOrWhitespace","trim","pad","l","char","reverse","_formatRegexp","match","group","parseInt","isNaN","escape","html","convertSimple2RegExpPattern","pattern","stripWildcards","startsWith","endsWith","createRegExp","searchString","isRegex","wholeWord","test","charAt","modifiers","matchCase","multiline","unicode","RegExp","regExpLeadsToEndlessLoop","regexp","exec","lastIndex","regExpContainsBackreference","regexpValue","regExpFlags","ignoreCase","firstNonWhitespaceIndex","chCode","getLeadingWhitespace","lastNonWhitespaceIndex","startIndex","compareIgnoreCase","equalsIgnoreCase","startsWithIgnoreCase","candidateLength","commonPrefixLength","commonSuffixLength","aLastIndex","bLastIndex","overlap","isHighSurrogate","isLowSurrogate","CONTAINS_RTL","containsRTL","CONTAINS_EMOJI","containsEmoji","IS_BASIC_ASCII","isBasicASCII","containsFullWidthCharacter","lcut","text","re","EL","COLOR_START","COLOR_END","removeAnsiEscapeCodes","removeAccents","prototype","regex","UTF8_BOM_CHARACTER","stripUTF8BOM","substr","safeBtoa","btoa","encodeURIComponent","repeat","s","fuzzyContains","target","query","queryLen","targetLower","containsUppercaseCharacter","ignoreEscapedChars","uppercaseFirstLetter","toUpperCase","getNLines","isWindowsDriveLetter","char0","toSlashes","osPath","path_1","getRoot","firstLetter","pos","isUNC","INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","isValidBasename","isEqual","pathA","pathB","identityEquals","strings_1","isEqualOrParent","sepOffset","_typeof","number","constructor","isString","string","isObject","isUndefined","isUndefinedOrNull","isFunction","function","validateConstraint","constraint","_a","isStringArray","every","elem","isNumber","Number","isBoolean","hasOwnProperty","isEmptyObject","areFunctions","objects","validateConstraints","constraints","ctor","isNativeClass","getAllPropertyNames","proto","getPrototypeOf","concat","getOwnPropertyNames","withNullAsUndefined","x","withUndefinedAsNull","deepClone","keys","_cloneAndChange","changer","seen","types_1","changed","r1","has","add","r2","i2","_hasOwnProperty","delete","mixin","destination","overwrite","equals","one","other","oneKeys","sort","otherKeys","deepFreeze","prop","isFrozen","cloneAndChange","Set","assign","sources","createKeywordMatcher","arr","caseInsensitive","hash","arrayToHash","word","safeStringify","stringify","getOrDefault","distinct","k","baseValue","targetValue","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","escaped","encodeTable","_makeFsPath","uri","authority","scheme","_asFormatted","skipEncoding","encoder","fragment","_slash","userinfo","_schemePattern","_singleSlashStart","_doubleSlashStart","_throwOnMissingSchema","setUriThrowOnMissingScheme","old","_regexp","URI","fsPath","with","schemeOrData","_strict","trace","_schemeFix","_referenceResolution","_validateUri","change","_URI","decodeURIComponent","components","data","_fsPath","_formatted","external","$mid","58","47","63","35","91","93","64","33","36","38","39","40","41","42","43","44","59","61","32","getPathFromAmdModule","requirefn","relativePath","uri_1","toUrl","entry","parsedArguments","stackArgument","__$stack","getFirstFrame","arg0","topFrame","findFirstFrame","matches","file","line","column","newlineIndex","color","isRemoteConsoleLog","severity","log","label","isOneStringArg","consoleArgs","LineDecoder","encoding","stringDecoder","sd","StringDecoder","remaining","write","ch","lastChar","createSizeBuffer","Buffer","allocUnsafe","writeUInt32BE","readSizeBuffer","reader","read","readUInt32BE","serialize","writer","BufferPresets","Undefined","isBuffer","el","deserialize","readUInt8","DataType","getDelayedChannel","command","cancellationToken","relay","listen","RequestType","ResponseType","State","BufferReader","bytes","BufferWriter","alloc","ChannelServer","protocol","ctx","channels","activeRequests","protocolListener","onMessage","onRawMessage","sendResponse","channelName","channel","response","send","header","body","sendBuffer","onPromise","onEventListen","disposeActiveRequest","request","cancellationTokenSource","disposable","ChannelClient","state","Uninitialized","handlers","lastRequestId","_onDidInitialize","onDidInitialize","onBuffer","that","requestPromise","requestEvent","uninitializedPromise","async_1","whenInitialized","sendRequest","cancellationTokenListener","onResponse","Idle","p","IPCServer","onDidClientConnect","_connections","_onDidChangeConnections","onDidChangeConnections","onDidClientDisconnect","onFirstMessage","channelServer","channelClient","registerChannel","connection","connections","router","routeCall","getChannel","routeEvent","IPCClient","getNextTickChannel","didTick","StaticRouter","hub","route","define","nls","terminateProcess","stdio","cp","execFileSync","pid","success","status","getWindowsCode","cmd","amd_1","require","spawnSync","kill","getWindowsShell","AbstractProcess","arg1","arg2","arg3","arg4","shell","executable","isShellCommand","childProcess","terminateRequested","newEnv","WellKnowCommands","pp","extpath","localize","useExec","cc","ee","stdout","stderr","killed","handleExec","Objects","windowsVerbatimArguments","detached","quotedCommand","quotedArg","commandLine","quoted","ensureQuotes","spawn","childProcessPromise","pidResolve","Types","terminated","handleClose","cmdCode","handleSpawn","cmdShell","ant","cmake","eslint","gradle","grunt","gulp","jake","jenkins","jshint","make","maven","msbuild","msc","nmake","npm","rake","tsc","xbuild","LineProcess","lineDecoder","decoder_1","sync","stdoutLineDecoder","stderrLineDecoder","createQueuedSender","msgQueue","useQueue","msgQueueCopy","findExecutable","PATH","pathEntry","fullPath","fs","existsSync","withExtension","Server","ipc_1","Client","modulePath","_onDidProcessExit","onDidProcessExit","disposeDelayer","child","_client","getCachedChannel","disposeClient","client","forkOpts","objects_1","VSCODE_PARENT_PID","freshExecArgv","execArgv","debug","debugBrk","child_process_1","fork","onMessageEmitter","console_1","serverName","sender","processes_1","isBrowser","connected","onExit","storeServiceDependency","optional","_util","DI_TARGET","DI_DEPENDENCIES","createDecorator","serviceId","serviceIds","getServiceDependencies","IInstantiationService","serviceIdentifier","now","toISOString","ILogService","instantiation_1","LogLevel","DEFAULT_LOG_LEVEL","Info","AbstractLogService","level","_onDidChangeLogLevel","_register","onDidChangeLogLevel","ConsoleLogMainService","logLevel","setLevel","useColors","getLevel","Trace","Debug","Warning","Critical","ConsoleLogService","MultiplexLogService","logServices","logService","info","critical","DelegatedLogService","NullLogService","getLogLevel","environmentService","verbose","Off","AppInsightsAppender","_eventPrefix","_defaultData","aiKeyOrClientFactory","_logService","_aiClient","aiKey","appInsights","defaultClient","TelemetryClient","setUseDiskRetryCaching","setup","setAutoCollectRequests","setAutoCollectPerformance","setAutoCollectExceptions","setAutoCollectDependencies","setAutoDependencyCorrelation","setAutoCollectConsole","setInternalLogging","config","endpointUrl","getClient","properties","measurements","flat","_flaten","order","prefix","_getData","trackEvent","__decorate","__param","log_1","TelemetryAppenderChannel","appender","TelemetryAppenderClient","appInsightsAppender_1","argv","telemetryIpc_1","ipc_cp_1"],"mappings":"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","file":"telemetryApp.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\tpublic addListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tpublic setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tpublic getUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tpublic onUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tpublic onUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tlet { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): any;\n\tgetTypeName(): string;\n\tgetFunction(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string;\n\tgetLineNumber(): number;\n\tgetColumnNumber(): number;\n\tgetEvalOrigin(): string;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error: any): boolean {\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function disposed(what: string): Error {\n\tconst result = new Error(`${what} has been disposed`);\n\tresult.name = 'DISPOSED';\n\treturn result;\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function once<T extends Function>(this: any, fn: T): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: any;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tresult = fn.apply(_this, arguments);\n\n\t\treturn result;\n\t} as any as T;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IteratorDefinedResult<T> {\n\treadonly done: false;\n\treadonly value: T;\n}\nexport interface IteratorUndefinedResult {\n\treadonly done: true;\n\treadonly value: undefined;\n}\nexport const FIN: IteratorUndefinedResult = { done: true, value: undefined };\nexport type IteratorResult<T> = IteratorDefinedResult<T> | IteratorUndefinedResult;\n\nexport interface Iterator<T> {\n\tnext(): IteratorResult<T>;\n}\n\nexport module Iterator {\n\tconst _empty: Iterator<any> = {\n\t\tnext() {\n\t\t\treturn FIN;\n\t\t}\n\t};\n\n\texport function empty<T>(): Iterator<T> {\n\t\treturn _empty;\n\t}\n\n\texport function fromArray<T>(array: T[], index = 0, length = array.length): Iterator<T> {\n\t\treturn {\n\t\t\tnext(): IteratorResult<T> {\n\t\t\t\tif (index >= length) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\treturn { done: false, value: array[index++] };\n\t\t\t}\n\t\t};\n\t}\n\n\texport function from<T>(elements: Iterator<T> | T[] | undefined): Iterator<T> {\n\t\tif (!elements) {\n\t\t\treturn Iterator.empty();\n\t\t} else if (Array.isArray(elements)) {\n\t\t\treturn Iterator.fromArray(elements);\n\t\t} else {\n\t\t\treturn elements;\n\t\t}\n\t}\n\n\texport function map<T, R>(iterator: Iterator<T>, fn: (t: T) => R): Iterator<R> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tconst element = iterator.next();\n\t\t\t\tif (element.done) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t} else {\n\t\t\t\t\treturn { done: false, value: fn(element.value) };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function filter<T>(iterator: Iterator<T>, fn: (t: T) => boolean): Iterator<T> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst element = iterator.next();\n\t\t\t\t\tif (element.done) {\n\t\t\t\t\t\treturn FIN;\n\t\t\t\t\t}\n\t\t\t\t\tif (fn(element.value)) {\n\t\t\t\t\t\treturn { done: false, value: element.value };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function forEach<T>(iterator: Iterator<T>, fn: (t: T) => void): void {\n\t\tfor (let next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\tfn(next.value);\n\t\t}\n\t}\n\n\texport function collect<T>(iterator: Iterator<T>): T[] {\n\t\tconst result: T[] = [];\n\t\tforEach(iterator, value => result.push(value));\n\t\treturn result;\n\t}\n}\n\nexport type ISequence<T> = Iterator<T> | T[];\n\nexport function getSequenceIterator<T>(arg: Iterator<T> | T[]): Iterator<T> {\n\tif (Array.isArray(arg)) {\n\t\treturn Iterator.fromArray(arg);\n\t} else {\n\t\treturn arg;\n\t}\n}\n\nexport interface INextIterator<T> {\n\tnext(): T | null;\n}\n\nexport class ArrayIterator<T> implements INextIterator<T> {\n\n\tprivate items: T[];\n\tprotected start: number;\n\tprotected end: number;\n\tprotected index: number;\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tthis.items = items;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.index = index;\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic next(): T | null {\n\t\tthis.index = Math.min(this.index + 1, this.end);\n\t\treturn this.current();\n\t}\n\n\tprotected current(): T | null {\n\t\tif (this.index === this.start - 1 || this.index === this.end) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.items[this.index];\n\t}\n}\n\nexport class ArrayNavigator<T> extends ArrayIterator<T> implements INavigator<T> {\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tsuper(items, start, end, index);\n\t}\n\n\tpublic current(): T | null {\n\t\treturn super.current();\n\t}\n\n\tpublic previous(): T | null {\n\t\tthis.index = Math.max(this.index - 1, this.start - 1);\n\t\treturn this.current();\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic last(): T | null {\n\t\tthis.index = this.end - 1;\n\t\treturn this.current();\n\t}\n\n\tpublic parent(): T | null {\n\t\treturn null;\n\t}\n}\n\nexport class MappedIterator<T, R> implements INextIterator<R> {\n\n\tconstructor(protected iterator: INextIterator<T>, protected fn: (item: T | null) => R) {\n\t\t// noop\n\t}\n\n\tnext() { return this.fn(this.iterator.next()); }\n}\n\nexport interface INavigator<T> extends INextIterator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tparent(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport class MappedNavigator<T, R> extends MappedIterator<T, R> implements INavigator<R> {\n\n\tconstructor(protected navigator: INavigator<T>, fn: (item: T) => R) {\n\t\tsuper(navigator, fn);\n\t}\n\n\tcurrent() { return this.fn(this.navigator.current()); }\n\tprevious() { return this.fn(this.navigator.previous()); }\n\tparent() { return this.fn(this.navigator.parent()); }\n\tfirst() { return this.fn(this.navigator.first()); }\n\tlast() { return this.fn(this.navigator.last()); }\n\tnext() { return this.fn(this.navigator.next()); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable><any>thing).dispose === 'function'\n\t\t&& (<IDisposable><any>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(...disposables: Array<T | undefined>): T[];\nexport function dispose<T extends IDisposable>(disposables: T[]): T[];\nexport function dispose<T extends IDisposable>(first: T | T[], ...rest: T[]): T | T[] | undefined {\n\tif (Array.isArray(first)) {\n\t\tfirst.forEach(d => d && d.dispose());\n\t\treturn [];\n\t} else if (rest.length === 0) {\n\t\tif (first) {\n\t\t\tfirst.dispose();\n\t\t\treturn first;\n\t\t}\n\t\treturn undefined;\n\t} else {\n\t\tdispose(first);\n\t\tdispose(rest);\n\t\treturn [];\n\t}\n}\n\nexport function combinedDisposable(disposables: IDisposable[]): IDisposable {\n\treturn { dispose: () => dispose(disposables) };\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn { dispose() { fn(); } };\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected _toDispose: IDisposable[] = [];\n\tprotected get toDispose(): IDisposable[] { return this._toDispose; }\n\n\tprivate _lifecycle_disposable_isDisposed = false;\n\n\tpublic dispose(): void {\n\t\tthis._lifecycle_disposable_isDisposed = true;\n\t\tthis._toDispose = dispose(this._toDispose);\n\t}\n\n\tprotected _register<T extends IDisposable>(t: T): T {\n\t\tif (this._lifecycle_disposable_isDisposed) {\n\t\t\tconsole.warn('Registering disposable on object that has already been disposed.');\n\t\t\tt.dispose();\n\t\t} else {\n\t\t\tthis._toDispose.push(t);\n\t\t}\n\n\t\treturn t;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate references: { [key: string]: { readonly object: T; counter: number; } } = Object.create(null);\n\n\tconstructor() { }\n\n\tacquire(key: string): IReference<T> {\n\t\tlet reference = this.references[key];\n\n\t\tif (!reference) {\n\t\t\treference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tdelete this.references[key];\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterator, IteratorResult, FIN } from 'vs/base/common/iterator';\n\nclass Node<E> {\n\telement: E;\n\tnext: Node<E> | undefined;\n\tprev: Node<E> | undefined;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> | undefined;\n\tprivate _last: Node<E> | undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._first;\n\t}\n\n\tclear(): void {\n\t\tthis._first = undefined;\n\t\tthis._last = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (!this._first) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last!;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\t\treturn this._remove.bind(this, newNode);\n\t}\n\n\n\tshift(): E | undefined {\n\t\tif (!this._first) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (!this._last) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tlet candidate: Node<E> | undefined = this._first;\n\t\twhile (candidate instanceof Node) {\n\t\t\tif (candidate !== node) {\n\t\t\t\tcandidate = candidate.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (candidate.prev && candidate.next) {\n\t\t\t\t// middle\n\t\t\t\tconst anchor = candidate.prev;\n\t\t\t\tanchor.next = candidate.next;\n\t\t\t\tcandidate.next.prev = anchor;\n\n\t\t\t} else if (!candidate.prev && !candidate.next) {\n\t\t\t\t// only node\n\t\t\t\tthis._first = undefined;\n\t\t\t\tthis._last = undefined;\n\n\t\t\t} else if (!candidate.next) {\n\t\t\t\t// last\n\t\t\t\tthis._last = this._last!.prev!;\n\t\t\t\tthis._last.next = undefined;\n\n\t\t\t} else if (!candidate.prev) {\n\t\t\t\t// first\n\t\t\t\tthis._first = this._first!.next!;\n\t\t\t\tthis._first.prev = undefined;\n\t\t\t}\n\n\t\t\t// done\n\t\t\tthis._size -= 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\titerator(): Iterator<E> {\n\t\tlet element: { done: false; value: E; };\n\t\tlet node = this._first;\n\t\treturn {\n\t\t\tnext(): IteratorResult<E> {\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\tif (!element) {\n\t\t\t\t\telement = { done: false, value: node.element };\n\t\t\t\t} else {\n\t\t\t\t\telement.value = node.element;\n\t\t\t\t}\n\t\t\t\tnode = node.next;\n\t\t\t\treturn element;\n\t\t\t}\n\t\t};\n\t}\n\n\ttoArray(): E[] {\n\t\tconst result: E[] = [];\n\t\tfor (let node = this._first; node instanceof Node; node = node.next) {\n\t\t\tresult.push(node.element);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { combinedDisposable, Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n}\n\nexport namespace Event {\n\tconst _disposable = { dispose() { } };\n\texport const None: Event<any> = function () { return _disposable; };\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event and a `map` function, returns another event which maps each element\n\t * throught the mapping function.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n\t}\n\n\t/**\n\t * Given an event and an `each` function, returns another identical event and calls\n\t * the `each` function per each element.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n\t}\n\n\t/**\n\t * Given an event and a `filter` function, returns another event which emits those\n\t * elements for which the `filter` function returns `true`.\n\t */\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * Given an event and a `merge` function, returns another event which maps each element\n\t * and the cummulative result throught the `merge` function. Similar to `map`, but with memory.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Given a chain of event processing functions (filter, map, etc), each\n\t * function will be invoked per event & per listener. Snapshotting an event\n\t * chain allows each function to be invoked just once per event.\n\t */\n\texport function snapshot<T>(event: Event<T>): Event<T> {\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces the provided event, given a `merge` function.\n\t *\n\t * @param event The input event.\n\t * @param merge The reducing function.\n\t * @param delay The debouncing delay in millis.\n\t * @param leading Whether the event should fire in the leading phase of the timeout.\n\t * @param leakWarningThreshold The leak warning threshold override.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst emitter = new Emitter<O>({\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only once and as soon as\n\t * the input event emits. The event data is the number of millis it took for the\n\t * event to fire.\n\t */\n\texport function stopwatch<T>(event: Event<T>): Event<number> {\n\t\tconst start = new Date().getTime();\n\t\treturn map(once(event), _ => new Date().getTime() - start);\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only when the event\n\t * element changes.\n\t */\n\texport function latch<T>(event: Event<T>): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || value !== cache;\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t});\n\t}\n\n\t/**\n\t * Buffers the provided event until a first listener comes\n\t * along, at which point fire all the events at once and\n\t * pipe the event from then on.\n\t *\n\t * ```typescript\n\t * const emitter = new Emitter<number>();\n\t * const event = emitter.event;\n\t * const bufferedEvent = buffer(event);\n\t *\n\t * emitter.fire(1);\n\t * emitter.fire(2);\n\t * emitter.fire(3);\n\t * // nothing...\n\t *\n\t * const listener = bufferedEvent(num => console.log(num));\n\t * // 1, 2, 3\n\t *\n\t * emitter.fire(4);\n\t * // 4\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, nextTick = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.forEach(e => emitter.fire(e));\n\t\t\t}\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (nextTick) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Similar to `buffer` but it buffers indefinitely and repeats\n\t * the buffered events to every new listener.\n\t */\n\texport function echo<T>(event: Event<T>, nextTick = false, buffer: T[] = []): Event<T> {\n\t\tbuffer = buffer.slice();\n\n\t\tevent(e => {\n\t\t\tbuffer.push(e);\n\t\t\temitter.fire(e);\n\t\t});\n\n\t\tconst flush = (listener: (e: T) => any, thisArgs?: any) => buffer.forEach(e => listener.call(thisArgs, e));\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonListenerDidAdd(emitter: Emitter<T>, listener: (e: T) => any, thisArgs?: any) {\n\t\t\t\tif (nextTick) {\n\t\t\t\t\tsetTimeout(() => flush(listener, thisArgs));\n\t\t\t\t} else {\n\t\t\t\t\tflush(listener, thisArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> {\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): this;\n\t\tremoveListener(event: string | symbol, listener: Function): this;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function fromPromise<T = any>(promise: Promise<T>): Event<undefined> {\n\t\tconst emitter = new Emitter<undefined>();\n\t\tlet shouldEmit = false;\n\n\t\tpromise\n\t\t\t.then(undefined, () => null)\n\t\t\t.then(() => {\n\t\t\t\tif (!shouldEmit) {\n\t\t\t\t\tsetTimeout(() => emitter.fire(undefined), 0);\n\t\t\t\t} else {\n\t\t\t\t\temitter.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\tshouldEmit = true;\n\t\treturn emitter.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(c => once(event)(c));\n\t}\n}\n\ntype Listener<T> = [(e: T) => void, any] | ((e: T) => void);\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n\t\tconst count = (this._stacks.get(stack) || 0);\n\t\tthis._stacks.set(stack, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string;\n\t\t\tlet topCount: number = 0;\n\t\t\tthis._stacks.forEach((count, stack) => {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack) || 0);\n\t\t\tthis._stacks!.set(stack, count - 1);\n\t\t};\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static readonly _noop = function () { };\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue: [Listener<T>, T][];\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0\n\t\t\t? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n\t\t\t: undefined;\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tconst remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options && this._options.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, listener, thisArgs);\n\t\t\t\t}\n\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tlet removeMonitor: (() => void) | undefined;\n\t\t\t\tif (this._leakageMon) {\n\t\t\t\t\tremoveMonitor = this._leakageMon.check(this._listeners.size);\n\t\t\t\t}\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (removeMonitor) {\n\t\t\t\t\t\t\tremoveMonitor();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tremove();\n\t\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = [];\n\t\t\t}\n\n\t\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\t\tthis._deliveryQueue.push([e.value, event]);\n\t\t\t}\n\n\t\t\twhile (this._deliveryQueue.length > 0) {\n\t\t\t\tconst [listener, event] = this._deliveryQueue.shift()!;\n\t\t\t\ttry {\n\t\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif (this._listeners) {\n\t\t\tthis._listeners = undefined;\n\t\t}\n\t\tif (this._deliveryQueue) {\n\t\t\tthis._deliveryQueue.length = 0;\n\t\t}\n\t\tif (this._leakageMon) {\n\t\t\tthis._leakageMon.dispose();\n\t\t}\n\t\tthis._disposed = true;\n\t}\n}\n\nexport interface IWaitUntil {\n\twaitUntil(thenable: Promise<any>): void;\n}\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue: [Listener<T>, T, Promise<any>[]][];\n\n\tasync fireAsync(eventFn: (thenables: Promise<any>[], listener: Function) => T): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\t// put all [listener,event]-pairs into delivery queue\n\t\t// then emit all event. an inner/nested event might be\n\t\t// the driver of this\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = [];\n\t\t}\n\n\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\tconst thenables: Promise<void>[] = [];\n\t\t\tthis._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);\n\t\t}\n\n\t\twhile (this._asyncDeliveryQueue.length > 0) {\n\t\t\tconst [listener, event, thenables] = this._asyncDeliveryQueue.shift()!;\n\t\t\ttry {\n\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t} else {\n\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\t\t\tawait Promise.all(thenables);\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null; }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\treadonly isCancellationRequested: boolean;\n\t/**\n\t * An event emitted when cancellation is requested\n\t * @event\n\t */\n\treadonly onCancellationRequested: Event<any>;\n}\n\nconst shortcutEvent = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n} as Event<any>);\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: any): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token: CancellationToken;\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn new class implements CancelablePromise<T> {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: (err: any) => void;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tconst task = this.task!;\n\t\t\t\tthis.task = null;\n\n\t\t\t\treturn task();\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tthis.doResolve!(null);\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject(errors.canceled());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tpublic get onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue {\n\tprivate queues: { [path: string]: Queue<void> };\n\n\tconstructor() {\n\t\tthis.queues = Object.create(null);\n\t}\n\n\tpublic queueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues[key]) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tdelete this.queues[key];\n\t\t\t});\n\n\t\t\tthis.queues[key] = queue;\n\t\t}\n\n\t\treturn this.queues[key];\n\t}\n}\n\nexport class TimeoutTimer extends Disposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tsuper();\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer extends Disposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport function nfcall(fn: Function, ...args: any[]): Promise<any>;\nexport function nfcall<T>(fn: Function, ...args: any[]): Promise<T>;\nexport function nfcall(fn: Function, ...args: any[]): any {\n\treturn new Promise((c, e) => fn(...args, (err: any, result: any) => err ? e(err) : c(result)));\n}\n\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): Promise<any>;\nexport function ninvoke<T>(thisArg: any, fn: Function, ...args: any[]): Promise<T>;\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): any {\n\treturn new Promise((resolve, reject) => fn.call(thisArg, ...args, (err: any, result: any) => err ? reject(err) : resolve(result)));\n}\n\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): DOMHighResTimeStamp;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean;\n\tprivate _value: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\n// let _isLinux = false;\nlet _isNative = false;\n// let _isWeb = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\n\ninterface NLSConfig {\n\tlocale: string;\n\tavailableLanguages: { [key: string]: string; };\n\t_translationsConfigFile: string;\n}\n\nexport interface IProcessEnvironment {\n\t[key: string]: string;\n}\n\ninterface INodeProcess {\n\tplatform: string;\n\tenv: IProcessEnvironment;\n\tgetuid(): number;\n\tnextTick: Function;\n\tversions?: {\n\t\telectron?: string;\n\t};\n\ttype?: string;\n}\ndeclare const process: INodeProcess;\ndeclare const global: any;\n\ninterface INavigator {\n\tuserAgent: string;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\ndeclare const self: any;\n\nconst isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');\n\n// OS detection\nif (typeof navigator === 'object' && !isElectronRenderer) {\n\tconst userAgent = navigator.userAgent;\n\t_isWindows = userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = userAgent.indexOf('Macintosh') >= 0;\n\t// _isLinux = userAgent.indexOf('Linux') >= 0;\n\t// _isWeb = true;\n\t_locale = navigator.language;\n\t_language = _locale;\n} else if (typeof process === 'object') {\n\t_isWindows = (process.platform === 'win32');\n\t_isMacintosh = (process.platform === 'darwin');\n\t// _isLinux = (process.platform === 'linux');\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\tconst resolved = nlsConfig.availableLanguages['*'];\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t// VSCode's default language is 'en'\n\t\t\t_language = resolved ? resolved : LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport function PlatformToString(platform: Platform) {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\n// let _platform: Platform = Platform.Web;\n// if (_isNative) {\n// \tif (_isMacintosh) {\n// \t\t_platform = Platform.Mac;\n// \t} else if (_isWindows) {\n// \t\t_platform = Platform.Windows;\n// \t} else if (_isLinux) {\n// \t\t_platform = Platform.Linux;\n// \t}\n// }\n\nexport const isRealWindows = _isWindows;\nexport const isWindows = false; // _isWindows;\nexport const isMacintosh = true; // _isMacintosh;\nexport const isLinux = false; // _isLinux;\nexport const isNative = false; // _isNative;\nexport const isWeb = false; // _isWeb;\nexport const platform = 1; // _platform;\n\nexport function isRootUser(): boolean {\n\treturn _isNative && !_isWindows && (process.getuid() === 0);\n}\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * The translatios that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nconst _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {} as any);\nexport const globals: any = _globals;\n\nlet _setImmediate: ((callback: (...args: any[]) => void) => number) | null = null;\nexport function setImmediate(callback: (...args: any[]) => void): number {\n\tif (_setImmediate === null) {\n\t\tif (globals.setImmediate) {\n\t\t\t_setImmediate = globals.setImmediate.bind(globals);\n\t\t} else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n\t\t\t_setImmediate = process.nextTick.bind(process);\n\t\t} else {\n\t\t\t_setImmediate = globals.setTimeout.bind(globals);\n\t\t}\n\t}\n\treturn _setImmediate!(callback);\n}\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate } from 'vs/base/common/platform';\n\ninterface IProcess {\n\tplatform: string;\n\tenv: object;\n\n\tcwd(): string;\n\tnextTick(callback: (...args: any[]) => void): number;\n}\n\ndeclare const process: IProcess;\nconst safeProcess: IProcess = (typeof process === 'undefined') ? {\n\tcwd(): string { return '/'; },\n\tenv: Object.create(null),\n\tget platform(): string { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\tnextTick(callback: (...args: any[]) => void): number { return setImmediate(callback); }\n} : process;\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: string) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tlet msg;\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tmsg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\t}\n}\n\nfunction validateString(value: string, name) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (lastSlash !== i - 1 && dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length === 2 || res.length === 1) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tif (res.length > 0) {\n\t\t\t\t\t\tres += `${separator}..`;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = '..';\n\t\t\t\t\t}\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += separator + path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep, pathObject) {\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t((pathObject.name || '') + (pathObject.ext || ''));\n\tif (!dir) {\n\t\treturn base;\n\t}\n\tif (dir === pathObject.root) {\n\t\treturn dir + base;\n\t}\n\treturn dir + sep + base;\n}\n\ninterface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\ninterface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t} else if (!resolvedDevice) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env['=' + resolvedDevice] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 3).toLowerCase() !==\n\t\t\t\t\tresolvedDevice.toLowerCase() + '\\\\') {\n\t\t\t\t\tpath = resolvedDevice + '\\\\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len > 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// Possible UNC root\n\n\t\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\t\tisAbsolute = true;\n\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\t\tlet j = 2;\n\t\t\t\t\t\tlet last = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEnd = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t\t// Possible device root\n\n\t\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\t\trootEnd = 2;\n\t\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator\n\t\t\t\trootEnd = 1;\n\t\t\t\tisAbsolute = true;\n\t\t\t}\n\n\t\t\tif (device.length > 0 &&\n\t\t\t\tresolvedDevice.length > 0 &&\n\t\t\t\tdevice.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length === 0 && device.length > 0) {\n\t\t\t\tresolvedDevice = device;\n\t\t\t}\n\t\t\tif (!resolvedAbsolute) {\n\t\t\t\tresolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length > 0 && resolvedAbsolute) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n\t\t\t'.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t\t// path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t\t// is nothing left to process\n\n\t\t\t\t\t\t\t\treturn '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid unnecessary\n\t\t\t// work\n\t\t\treturn '\\\\';\n\t\t}\n\n\t\tlet tail;\n\t\tif (rootEnd < len) {\n\t\t\ttail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\',\n\t\t\t\tisPathSeparator);\n\t\t} else {\n\t\t\ttail = '';\n\t\t}\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\tif (isAbsolute) {\n\t\t\t\tif (tail.length > 0) {\n\t\t\t\t\treturn '\\\\' + tail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t} else if (tail.length > 0) {\n\t\t\t\treturn tail;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (isAbsolute) {\n\t\t\tif (tail.length > 0) {\n\t\t\t\treturn device + '\\\\' + tail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn device + '\\\\';\n\t\t\t}\n\t\t} else if (tail.length > 0) {\n\t\t\treturn device + tail;\n\t\t} else {\n\t\t\treturn device;\n\t\t}\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\tif (isPathSeparator(code)) {\n\t\t\treturn true;\n\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t// Possible device root\n\n\t\t\tif (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '\\\\' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1) {\n\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t\t++slashCount;\n\t\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\tfor (; slashCount < joined.length; ++slashCount) {\n\t\t\t\tif (!isPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = '\\\\' + joined.slice(slashCount);\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\tfor (; fromEnd - 1 > fromStart; --fromEnd) {\n\t\t\tif (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\tfor (; toEnd - 1 > toStart; --toEnd) {\n\t\t\tif (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length && lastCommonSep === -1) {\n\t\t\treturn toOrig;\n\t\t}\n\n\t\tlet out = '';\n\t\tif (lastCommonSep === -1) {\n\t\t\tlastCommonSep = 0;\n\t\t}\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '\\\\..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + toOrig.slice(toStart + lastCommonSep, toEnd);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn toOrig.slice(toStart, toEnd);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length >= 3) {\n\t\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\t\treturn '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\t\t\treturn '\\\\\\\\?\\\\' + resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = offset = 1;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = offset = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\trootEnd = offset = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn path;\n\t\t}\n\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = rootEnd;\n\t\t\t}\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2) {\n\t\t\tconst drive = path.charCodeAt(0);\n\t\t\tif (isWindowsDeviceRoot(drive)) {\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tstart = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('\\\\', pathObject);\n\t},\n\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = 1;\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\tif (len === 3) {\n\t\t\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\tret.root = ret.dir = path;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t}\n\t\t} else {\n\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\tret.base = path.slice(startPart, end);\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = process.cwd();\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = path + '/' + resolvedPath;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\tif (resolvedPath.length > 0) {\n\t\t\t\treturn '/' + resolvedPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t} else if (resolvedPath.length > 0) {\n\t\t\treturn resolvedPath;\n\t\t} else {\n\t\t\treturn '.';\n\t\t}\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0 && !isAbsolute) {\n\t\t\tpath = '.';\n\t\t}\n\t\tif (path.length > 0 && trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\tif (isAbsolute) {\n\t\t\treturn '/' + path;\n\t\t}\n\t\treturn path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = arguments[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '/' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 1;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 1;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toEnd = to.length;\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t} else if (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t\t// For example: from='/foo'; to='/'\n\t\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '/..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + to.slice(toStart + lastCommonSep);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn to.slice(toStart);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('/', pathObject);\n\t},\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\t\tret.base = ret.name = path.slice(1, end);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\tret.name = path.slice(1, startDot);\n\t\t\t\tret.base = path.slice(1, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t}\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * The empty string.\n */\nexport const empty = '';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\n/**\n * @returns the provided number with the given number of preceding zeros.\n */\nexport function pad(n: number, l: number, char: string = '0'): string {\n\tconst str = '' + n;\n\tconst r = [str];\n\n\tfor (let i = str.length; i < l; i++) {\n\t\tr.push(char);\n\t}\n\n\treturn r.reverse().join('');\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\n/**\n * Determines if haystack starts with needle.\n */\nexport function startsWith(haystack: string, needle: string): boolean {\n\tif (haystack.length < needle.length) {\n\t\treturn false;\n\t}\n\n\tif (haystack === needle) {\n\t\treturn true;\n\t}\n\n\tfor (let i = 0; i < needle.length; i++) {\n\t\tif (haystack[i] !== needle[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack: string, needle: string): boolean {\n\tconst diff = haystack.length - needle.length;\n\tif (diff > 0) {\n\t\treturn haystack.indexOf(needle, diff) === diff;\n\t} else if (diff === 0) {\n\t\treturn haystack === needle;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && <any>regexp.lastIndex === 0);\n}\n\nexport function regExpContainsBackreference(regexpValue: string): boolean {\n\treturn !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\n\nexport function regExpFlags(regexp: RegExp): string {\n\treturn (regexp.global ? 'g' : '')\n\t\t+ (regexp.ignoreCase ? 'i' : '')\n\t\t+ (regexp.multiline ? 'm' : '')\n\t\t+ ((regexp as any).unicode ? 'u' : '');\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\tconst len = Math.min(a.length, b.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tlet codeA = a.charCodeAt(i);\n\t\tlet codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeA)) {\n\t\t\tcodeA += 32;\n\t\t}\n\n\t\tif (isUpperAsciiLetter(codeB)) {\n\t\t\tcodeB += 32;\n\t\t}\n\n\t\tconst diff = codeA - codeB;\n\n\t\tif (diff === 0) {\n\t\t\t// equal -> ignoreCase\n\t\t\tcontinue;\n\n\t\t} else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n\t\t\t//\n\t\t\treturn diff;\n\n\t\t} else {\n\t\t\treturn compare(a.toLowerCase(), b.toLowerCase());\n\t\t}\n\t}\n\n\tif (a.length < b.length) {\n\t\treturn -1;\n\t} else if (a.length > b.length) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nfunction isAsciiLetter(code: number): boolean {\n\treturn isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\tconst len1 = a ? a.length : 0;\n\tconst len2 = b ? b.length : 0;\n\n\tif (len1 !== len2) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(a, b);\n}\n\nfunction doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {\n\tif (typeof a !== 'string' || typeof b !== 'string') {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < stopAt; i++) {\n\t\tconst codeA = a.charCodeAt(i);\n\t\tconst codeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// a-z A-Z\n\t\tif (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n\t\t\tconst diff = Math.abs(codeA - codeB);\n\t\t\tif (diff !== 0 && diff !== 32) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Any other charcode\n\t\telse {\n\t\t\tif (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nfunction substrEquals(a: string, aStart: number, aEnd: number, b: string, bStart: number, bEnd: number): boolean {\n\twhile (aStart < aEnd && bStart < bEnd) {\n\t\tif (a[aStart] !== b[bStart]) {\n\t\t\treturn false;\n\t\t}\n\t\taStart += 1;\n\t\tbStart += 1;\n\t}\n\treturn true;\n}\n\n/**\n * Return the overlap between the suffix of `a` and the prefix of `b`.\n * For instance `overlap(\"foobar\", \"arr, I'm a pirate\") === 2`.\n */\nexport function overlap(a: string, b: string): number {\n\tconst aEnd = a.length;\n\tlet bEnd = b.length;\n\tlet aStart = aEnd - bEnd;\n\n\tif (aStart === 0) {\n\t\treturn a === b ? aEnd : 0;\n\t} else if (aStart < 0) {\n\t\tbEnd += aStart;\n\t\taStart = 0;\n\t}\n\n\twhile (aStart < aEnd && bEnd > 0) {\n\t\tif (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {\n\t\t\treturn bEnd;\n\t\t}\n\t\tbEnd -= 1;\n\t\taStart += 1;\n\t}\n\treturn 0;\n}\n\n// --- unicode\n// http://en.wikipedia.org/wiki/Surrogate_pair\n// Returns the code point starting at a specified index in a string\n// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n// Code points U+10000 to U+10FFFF are represented on two consecutive characters\n//export function getUnicodePoint(str:string, index:number, len:number):number {\n//\tconst chrCode = str.charCodeAt(index);\n//\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n//\t\tconst nextChrCode = str.charCodeAt(index + 1);\n//\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n//\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n//\t\t}\n//\t}\n//\treturn chrCode;\n//}\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\treturn CONTAINS_RTL.test(str);\n}\n\n/**\n * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js\n */\nconst CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEF8]|\\uD83E[\\uDD00-\\uDDE6])/;\n\nexport function containsEmoji(str: string): boolean {\n\treturn CONTAINS_EMOJI.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport function containsFullWidthCharacter(str: string): boolean {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tif (isFullWidthCharacter(str.charCodeAt(i))) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 — 2EFF   CJK Radicals Supplement\n\t//          2F00 — 2FDF   Kangxi Radicals\n\t//          2FF0 — 2FFF   Ideographic Description Characters\n\t//          3000 — 303F   CJK Symbols and Punctuation\n\t//          3040 — 309F   Hiragana\n\t//          30A0 — 30FF   Katakana\n\t//          3100 — 312F   Bopomofo\n\t//          3130 — 318F   Hangul Compatibility Jamo\n\t//          3190 — 319F   Kanbun\n\t//          31A0 — 31BF   Bopomofo Extended\n\t//          31F0 — 31FF   Katakana Phonetic Extensions\n\t//          3200 — 32FF   Enclosed CJK Letters and Months\n\t//          3300 — 33FF   CJK Compatibility\n\t//          3400 — 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 — 4DFF   Yijing Hexagram Symbols\n\t//          4E00 — 9FFF   CJK Unified Ideographs\n\t//          A000 — A48F   Yi Syllables\n\t//          A490 — A4CF   Yi Radicals\n\t//          AC00 — D7AF   Hangul Syllables\n\t// [IGNORE] D800 — DB7F   High Surrogates\n\t// [IGNORE] DB80 — DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 — DFFF   Low Surrogates\n\t// [IGNORE] E000 — F8FF   Private Use Area\n\t//          F900 — FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 — FE0F   Variation Selectors\n\t// [IGNORE] FE20 — FE2F   Combining Half Marks\n\t// [IGNORE] FE30 — FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 — FE6F   Small Form Variants\n\t// [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\n\t//          FF00 — FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 — FFFF   Specials\n\tcharCode = +charCode; // @perf\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nexport function lcut(text: string, n: number) {\n\tif (text.length < n) {\n\t\treturn text;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(text)) {\n\t\tif (text.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\treturn text.substring(i).replace(/^\\s/, empty);\n}\n\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nconst EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nconst COLOR_START = /\\x1b\\[\\d+m/g; // Color\nconst COLOR_END = /\\x1b\\[0?m/g; // Color\n\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(EL, '');\n\t\tstr = str.replace(COLOR_START, '');\n\t\tstr = str.replace(COLOR_END, '');\n\t}\n\n\treturn str;\n}\n\nexport const removeAccents: (str: string) => string = (function () {\n\tif (typeof (String.prototype as any).normalize !== 'function') {\n\t\t// ☹️ no ES6 features...\n\t\treturn function (str: string) { return str; };\n\t} else {\n\t\t// transform into NFD form and remove accents\n\t\t// see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n\t\tconst regex = /[\\u0300-\\u036f]/g;\n\t\treturn function (str: string) {\n\t\t\treturn (str as any).normalize('NFD').replace(regex, empty);\n\t\t};\n\t}\n})();\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\nexport function safeBtoa(str: string): string {\n\treturn btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n}\n\nexport function repeat(s: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\treturn idx >= 0 ?\n\t\tstr.substr(0, idx) :\n\t\tstr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { startsWithIgnoreCase, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { sep, posix } from 'vs/base/common/path';\n\nfunction isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(1);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\tcode = path.charCodeAt(pos + 1);\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst INVALID_FILE_CHARS = isWindows ? /[\\\\/:\\*\\?\"<>\\|]/g : /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])$/i;\nexport function isValidBasename(name: string | null | undefined): boolean {\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tINVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development\n\tif (INVALID_FILE_CHARS.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindows && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindows && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 lenth\n\t}\n\n\treturn true;\n}\n\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\nexport function isEqualOrParent(path: string, candidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (path === candidate) {\n\t\treturn true;\n\t}\n\n\tif (!path || !candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(path, candidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (candidate.length === path.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = candidate.length;\n\t\tif (candidate.charAt(candidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn path.charAt(sepOffset) === separator;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== separator) {\n\t\tcandidate += separator;\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst _typeof = {\n\tnumber: 'number',\n\tstring: 'string',\n\tundefined: 'undefined',\n\tobject: 'object',\n\tfunction: 'function'\n};\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\nexport function isArray(array: any): array is any[] {\n\tif (Array.isArray) {\n\t\treturn Array.isArray(array);\n\t}\n\n\tif (array && typeof (array.length) === _typeof.number && array.constructor === Array) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: any): str is string {\n\tif (typeof (str) === _typeof.string || str instanceof String) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: any): value is string[] {\n\treturn isArray(value) && (<any[]>value).every(elem => isString(elem));\n}\n\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: any): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === _typeof.object\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: any): obj is number {\n\tif ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: any): obj is boolean {\n\treturn obj === true || obj === false;\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: any): obj is undefined {\n\treturn typeof (obj) === _typeof.undefined;\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: any): obj is undefined | null {\n\treturn isUndefined(obj) || obj === null;\n}\n\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: any): obj is any {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (let key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: any): obj is Function {\n\treturn typeof obj === _typeof.function;\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: any[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: any[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: any, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch{\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Creates a new object of the provided class and will call the constructor with\n * any additional argument supplied.\n */\nexport function create(ctor: Function, ...args: any[]): any {\n\tif (isNativeClass(ctor)) {\n\t\treturn new (ctor as any)(...args);\n\t} else {\n\t\tconst obj = Object.create(ctor.prototype);\n\t\tctor.apply(obj, args);\n\t\treturn obj;\n\t}\n}\n\n// https://stackoverflow.com/a/32235645/1499159\nfunction isNativeClass(thing): boolean {\n\treturn typeof thing === 'function'\n\t\t&& thing.hasOwnProperty('prototype')\n\t\t&& !thing.hasOwnProperty('arguments');\n}\n\nexport function getAllPropertyNames(obj: object): string[] {\n\tlet res: string[] = [];\n\tlet proto = Object.getPrototypeOf(obj);\n\twhile (Object.prototype !== proto) {\n\t\tres = res.concat(Object.getOwnPropertyNames(proto));\n\t\tproto = Object.getPrototypeOf(proto);\n\t}\n\treturn res;\n}\n\n/**\n * Converts null to undefined, passes all other values through.\n */\nexport function withNullAsUndefined<T>(x: T | null): T | undefined {\n\treturn x === null ? undefined : x;\n}\n\n/**\n * Converts undefined to null, passes all other values through.\n */\nexport function withUndefinedAsNull<T>(x: T | undefined): T | null {\n\treturn typeof x === 'undefined' ? null : x;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isObject, isUndefinedOrNull, isArray } from 'vs/base/common/types';\n\nexport function deepClone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tif (obj instanceof RegExp) {\n\t\t// See https://github.com/Microsoft/TypeScript/issues/10990\n\t\treturn obj as any;\n\t}\n\tconst result: any = Array.isArray(obj) ? [] : {};\n\tObject.keys(obj).forEach((key: string) => {\n\t\tif (obj[key] && typeof obj[key] === 'object') {\n\t\t\tresult[key] = deepClone(obj[key]);\n\t\t} else {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function deepFreeze<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tconst stack: any[] = [obj];\n\twhile (stack.length > 0) {\n\t\tconst obj = stack.shift();\n\t\tObject.freeze(obj);\n\t\tfor (const key in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, key)) {\n\t\t\t\tconst prop = obj[key];\n\t\t\t\tif (typeof prop === 'object' && !Object.isFrozen(prop)) {\n\t\t\t\t\tstack.push(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function cloneAndChange(obj: any, changer: (orig: any) => any): any {\n\treturn _cloneAndChange(obj, changer, new Set());\n}\n\nfunction _cloneAndChange(obj: any, changer: (orig: any) => any, seen: Set<any>): any {\n\tif (isUndefinedOrNull(obj)) {\n\t\treturn obj;\n\t}\n\n\tconst changed = changer(obj);\n\tif (typeof changed !== 'undefined') {\n\t\treturn changed;\n\t}\n\n\tif (isArray(obj)) {\n\t\tconst r1: any[] = [];\n\t\tfor (const e of obj) {\n\t\t\tr1.push(_cloneAndChange(e, changer, seen));\n\t\t}\n\t\treturn r1;\n\t}\n\n\tif (isObject(obj)) {\n\t\tif (seen.has(obj)) {\n\t\t\tthrow new Error('Cannot clone recursive data-structure');\n\t\t}\n\t\tseen.add(obj);\n\t\tconst r2 = {};\n\t\tfor (let i2 in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, i2)) {\n\t\t\t\t(r2 as any)[i2] = _cloneAndChange(obj[i2], changer, seen);\n\t\t\t}\n\t\t}\n\t\tseen.delete(obj);\n\t\treturn r2;\n\t}\n\n\treturn obj;\n}\n\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination: any, source: any, overwrite: boolean = true): any {\n\tif (!isObject(destination)) {\n\t\treturn source;\n\t}\n\n\tif (isObject(source)) {\n\t\tObject.keys(source).forEach(key => {\n\t\t\tif (key in destination) {\n\t\t\t\tif (overwrite) {\n\t\t\t\t\tif (isObject(destination[key]) && isObject(source[key])) {\n\t\t\t\t\t\tmixin(destination[key], source[key], overwrite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn destination;\n}\n\nexport function assign<T>(destination: T): T;\nexport function assign<T, U>(destination: T, u: U): T & U;\nexport function assign<T, U, V>(destination: T, u: U, v: V): T & U & V;\nexport function assign<T, U, V, W>(destination: T, u: U, v: V, w: W): T & U & V & W;\nexport function assign(destination: any, ...sources: any[]): any {\n\tsources.forEach(source => Object.keys(source).forEach(key => destination[key] = source[key]));\n\treturn destination;\n}\n\nexport function equals(one: any, other: any): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\tif (one === null || one === undefined || other === null || other === undefined) {\n\t\treturn false;\n\t}\n\tif (typeof one !== typeof other) {\n\t\treturn false;\n\t}\n\tif (typeof one !== 'object') {\n\t\treturn false;\n\t}\n\tif ((Array.isArray(one)) !== (Array.isArray(other))) {\n\t\treturn false;\n\t}\n\n\tlet i: number;\n\tlet key: string;\n\n\tif (Array.isArray(one)) {\n\t\tif (one.length !== other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < one.length; i++) {\n\t\t\tif (!equals(one[i], other[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst oneKeys: string[] = [];\n\n\t\tfor (key in one) {\n\t\t\toneKeys.push(key);\n\t\t}\n\t\toneKeys.sort();\n\t\tconst otherKeys: string[] = [];\n\t\tfor (key in other) {\n\t\t\totherKeys.push(key);\n\t\t}\n\t\totherKeys.sort();\n\t\tif (!equals(oneKeys, otherKeys)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < oneKeys.length; i++) {\n\t\t\tif (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction arrayToHash(array: string[]): { [name: string]: true } {\n\tconst result: any = {};\n\tfor (const e of array) {\n\t\tresult[e] = true;\n\t}\n\treturn result;\n}\n\n/**\n * Given an array of strings, returns a function which, given a string\n * returns true or false whether the string is in that array.\n */\nexport function createKeywordMatcher(arr: string[], caseInsensitive: boolean = false): (str: string) => boolean {\n\tif (caseInsensitive) {\n\t\tarr = arr.map(function (x) { return x.toLowerCase(); });\n\t}\n\tconst hash = arrayToHash(arr);\n\tif (caseInsensitive) {\n\t\treturn function (word) {\n\t\t\treturn hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n\t\t};\n\t} else {\n\t\treturn function (word) {\n\t\t\treturn hash[word] !== undefined && hash.hasOwnProperty(word);\n\t\t};\n\t}\n}\n\n/**\n * Calls JSON.Stringify with a replacer to break apart any circular references.\n * This prevents JSON.stringify from throwing the exception\n *  \"Uncaught TypeError: Converting circular structure to JSON\"\n */\nexport function safeStringify(obj: any): string {\n\tconst seen: any[] = [];\n\treturn JSON.stringify(obj, (key, value) => {\n\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\tif (seen.indexOf(value) !== -1) {\n\t\t\t\treturn '[Circular]';\n\t\t\t} else {\n\t\t\t\tseen.push(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport function getOrDefault<T, R>(obj: T, fn: (obj: T) => R | undefined, defaultValue: R): R {\n\tconst result = fn(obj);\n\treturn typeof result === 'undefined' ? defaultValue : result;\n}\n\ntype obj = { [key: string]: any; };\n/**\n * Returns an object that has keys for each value that is different in the base object. Keys\n * that do not exist in the target but in the base object are not considered.\n *\n * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting\n * object if they differ.\n *\n * @param base the object to diff against\n * @param obj the object to use for diffing\n */\nexport function distinct(base: obj, target: obj): obj {\n\tconst result = Object.create(null);\n\n\tif (!base || !target) {\n\t\treturn result;\n\t}\n\n\tconst targetKeys = Object.keys(target);\n\ttargetKeys.forEach(k => {\n\t\tconst baseValue = base[k];\n\t\tconst targetValue = target[k];\n\n\t\tif (!equals(baseValue, targetValue)) {\n\t\t\tresult[k] = targetValue;\n\t\t}\n\t});\n\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nlet _throwOnMissingSchema: boolean = true;\n\n/**\n * @internal\n */\nexport function setUriThrowOnMissingScheme(value: boolean): boolean {\n\tconst old = _throwOnMissingSchema;\n\t_throwOnMissingSchema = value;\n\treturn old;\n}\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme) {\n\t\tif (_strict || _throwOnMissingSchema) {\n\t\t\t// console.error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t\t} else {\n\t\t\tconsole.warn(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t\t}\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (_strict || _throwOnMissingSchema) {\n\t\treturn scheme || _empty;\n\t}\n\tif (!scheme) {\n\t\tconsole.trace('BAD uri lacks scheme, falling back to file-scheme.');\n\t\tscheme = 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'function'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn _makeFsPath(this);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\tpublic with(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new _URI(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tpublic static parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new _URI(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new _URI(\n\t\t\tmatch[2] || _empty,\n\t\t\tdecodeURIComponent(match[4] || _empty),\n\t\t\tdecodeURIComponent(match[5] || _empty),\n\t\t\tdecodeURIComponent(match[7] || _empty),\n\t\t\tdecodeURIComponent(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tpublic static file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new _URI('file', authority, path, _empty, _empty);\n\t}\n\n\tpublic static from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\treturn new _URI(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\tpublic toJSON(): object {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | any): URI {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new _URI(data);\n\t\t\tresult._fsPath = (<UriState>data).fsPath;\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\tfsPath: string;\n\texternal: string;\n}\n\n\n// tslint:disable-next-line:class-name\nclass _URI extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\tget fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = _makeFsPath(this);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\ttoJSON(): object {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (allowSlash && code === CharCode.Slash)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nfunction _makeFsPath(uri: URI): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\t// windows drive letter: file:///c:/far/boo\n\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.indexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n\t}\n\treturn res;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport function getPathFromAmdModule(requirefn: typeof require, relativePath: string): string {\n\treturn URI.parse(requirefn.toUrl(relativePath)).fsPath;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IRemoteConsoleLog {\n\ttype: string;\n\tseverity: string;\n\targuments: string;\n}\n\ninterface IStackArgument {\n\t__$stack: string;\n}\n\nexport interface IStackFrame {\n\turi: URI;\n\tline: number;\n\tcolumn: number;\n}\n\nexport function isRemoteConsoleLog(obj: any): obj is IRemoteConsoleLog {\n\tconst entry = obj as IRemoteConsoleLog;\n\n\treturn entry && typeof entry.type === 'string' && typeof entry.severity === 'string';\n}\n\nexport function parse(entry: IRemoteConsoleLog): { args: any[], stack?: string } {\n\tconst args: any[] = [];\n\tlet stack: string | undefined;\n\n\t// Parse Entry\n\ttry {\n\t\tconst parsedArguments: any[] = JSON.parse(entry.arguments);\n\n\t\t// Check for special stack entry as last entry\n\t\tconst stackArgument = parsedArguments[parsedArguments.length - 1] as IStackArgument;\n\t\tif (stackArgument && stackArgument.__$stack) {\n\t\t\tparsedArguments.pop(); // stack is handled specially\n\t\t\tstack = stackArgument.__$stack;\n\t\t}\n\n\t\targs.push(...parsedArguments);\n\t} catch (error) {\n\t\targs.push('Unable to log remote console arguments', entry.arguments);\n\t}\n\n\treturn { args, stack };\n}\n\nexport function getFirstFrame(entry: IRemoteConsoleLog): IStackFrame | undefined;\nexport function getFirstFrame(stack: string | undefined): IStackFrame | undefined;\nexport function getFirstFrame(arg0: IRemoteConsoleLog | string | undefined): IStackFrame | undefined {\n\tif (typeof arg0 !== 'string') {\n\t\treturn getFirstFrame(parse(arg0!).stack);\n\t}\n\n\t// Parse a source information out of the stack if we have one. Format can be:\n\t// at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)\n\t// or\n\t// at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17\n\t// or\n\t// at c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17\n\t// or\n\t// at e.$executeContributedCommand(c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17)\n\tconst stack = arg0;\n\tif (stack) {\n\t\tconst topFrame = findFirstFrame(stack);\n\n\t\t// at [^\\/]* => line starts with \"at\" followed by any character except '/' (to not capture unix paths too late)\n\t\t// (?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\) => windows drive letter OR unix root OR unc root\n\t\t// (?:.+) => simple pattern for the path, only works because of the line/col pattern after\n\t\t// :(?:\\d+):(?:\\d+) => :line:column data\n\t\tconst matches = /at [^\\/]*((?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\))(?:.+)):(\\d+):(\\d+)/.exec(topFrame || '');\n\t\tif (matches && matches.length === 4) {\n\t\t\treturn {\n\t\t\t\turi: URI.file(matches[1]),\n\t\t\t\tline: Number(matches[2]),\n\t\t\t\tcolumn: Number(matches[3])\n\t\t\t} as IStackFrame;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction findFirstFrame(stack: string | undefined): string | undefined {\n\tif (!stack) {\n\t\treturn stack;\n\t}\n\n\tconst newlineIndex = stack.indexOf('\\n');\n\tif (newlineIndex === -1) {\n\t\treturn stack;\n\t}\n\n\treturn stack.substring(0, newlineIndex);\n}\n\nexport function log(entry: IRemoteConsoleLog, label: string): void {\n\tconst { args, stack } = parse(entry);\n\n\tconst isOneStringArg = typeof args[0] === 'string' && args.length === 1;\n\n\tlet topFrame = findFirstFrame(stack);\n\tif (topFrame) {\n\t\ttopFrame = `(${topFrame.trim()})`;\n\t}\n\n\tlet consoleArgs: string[] = [];\n\n\t// First arg is a string\n\tif (typeof args[0] === 'string') {\n\t\tif (topFrame && isOneStringArg) {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color('black'), color('grey')];\n\t\t} else {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color('black'), ...args.slice(1)];\n\t\t}\n\t}\n\n\t// First arg is something else, just apply all\n\telse {\n\t\tconsoleArgs = [`%c[${label}]%`, color('blue'), ...args];\n\t}\n\n\t// Stack: add to args unless already aded\n\tif (topFrame && !isOneStringArg) {\n\t\tconsoleArgs.push(topFrame);\n\t}\n\n\t// Log it\n\tconsole[entry.severity].apply(console, consoleArgs);\n}\n\nfunction color(color: string): string {\n\treturn `color: ${color}`;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as sd from 'string_decoder';\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * Convenient way to iterate over output line by line. This helper accommodates for the fact that\n * a buffer might not end with new lines all the way.\n *\n * To use:\n * - call the write method\n * - forEach() over the result to get the lines\n */\nexport class LineDecoder {\n\tprivate stringDecoder: sd.NodeStringDecoder;\n\tprivate remaining: string | null;\n\n\tconstructor(encoding: string = 'utf8') {\n\t\tthis.stringDecoder = new sd.StringDecoder(encoding);\n\t\tthis.remaining = null;\n\t}\n\n\tpublic write(buffer: Buffer): string[] {\n\t\tconst result: string[] = [];\n\t\tconst value = this.remaining\n\t\t\t? this.remaining + this.stringDecoder.write(buffer)\n\t\t\t: this.stringDecoder.write(buffer);\n\n\t\tif (value.length < 1) {\n\t\t\treturn result;\n\t\t}\n\t\tlet start = 0;\n\t\tlet ch: number;\n\t\tlet idx = start;\n\t\twhile (idx < value.length) {\n\t\t\tch = value.charCodeAt(idx);\n\t\t\tif (ch === CharCode.CarriageReturn || ch === CharCode.LineFeed) {\n\t\t\t\tresult.push(value.substring(start, idx));\n\t\t\t\tidx++;\n\t\t\t\tif (idx < value.length) {\n\t\t\t\t\tconst lastChar = ch;\n\t\t\t\t\tch = value.charCodeAt(idx);\n\t\t\t\t\tif ((lastChar === CharCode.CarriageReturn && ch === CharCode.LineFeed) || (lastChar === CharCode.LineFeed && ch === CharCode.CarriageReturn)) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = idx;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tthis.remaining = start < value.length ? value.substr(start) : null;\n\t\treturn result;\n\t}\n\n\tpublic end(): string | null {\n\t\treturn this.remaining;\n\t}\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable, toDisposable, combinedDisposable } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, Relay } from 'vs/base/common/event';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any; };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel, id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any; };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose, id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string, name: string, stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: Buffer): void;\n\tonMessage: Event<Buffer>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the couter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidChangeConnections: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): Buffer;\n}\n\ninterface IWriter {\n\twrite(buffer: Buffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: Buffer) { }\n\n\tread(bytes: number): Buffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.length;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: Buffer[] = [];\n\n\tget buffer(): Buffer {\n\t\treturn Buffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: Buffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tArray = 3,\n\tObject = 4\n}\n\nfunction createSizeBuffer(size: number): Buffer {\n\tconst result = Buffer.allocUnsafe(4);\n\tresult.writeUInt32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUInt32BE(0);\n}\n\nconst BufferPresets = {\n\tUndefined: Buffer.alloc(1, DataType.Undefined),\n\tString: Buffer.alloc(1, DataType.String),\n\tBuffer: Buffer.alloc(1, DataType.Buffer),\n\tArray: Buffer.alloc(1, DataType.Array),\n\tObject: Buffer.alloc(1, DataType.Object)\n};\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = Buffer.from(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t} else if (Buffer.isBuffer(data)) {\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(data.length));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = Buffer.from(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.send([response.type]);\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.send([response.type, response.id], response.data);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(d => d.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\n\tprivate _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = createCancelablePromise(_ => this.whenInitialized());\n\t\t\tuninitializedPromise.then(() => {\n\t\t\t\tuninitializedPromise = null;\n\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t});\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable([toDisposable(cancel), cancellationTokenListener]);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => this.activeRequests.delete(disposable));\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawEventFireResponse) => emitter.fire(res.data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.send([request.type, request.id]);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onBuffer(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\tif (handler) {\n\t\t\thandler(response);\n\t\t}\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn Event.toPromise(this.onDidInitialize);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(p => p.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate _onDidChangeConnections = new Emitter<Connection<TContext>>();\n\treadonly onDidChangeConnections: Event<Connection<TContext>> = this._onDidChangeConnections.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidChangeConnections.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tconst channelPromise = router.routeCall(that, command, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tconst channelPromise = router.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidChangeConnections.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidChangeConnections);\n\t\treturn await this.route(hub);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'vs/base/common/path';\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport * as nls from 'vs/nls';\nimport * as Types from 'vs/base/common/types';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as Objects from 'vs/base/common/objects';\nimport * as extpath from 'vs/base/common/extpath';\nimport * as Platform from 'vs/base/common/platform';\nimport { LineDecoder } from 'vs/base/node/decoder';\nimport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode, Executable } from 'vs/base/common/processes';\nimport { getPathFromAmdModule } from 'vs/base/common/amd';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value?: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport interface LineData {\n\tline: string;\n\tsource: Source;\n}\n\nfunction getWindowsCode(status: number): TerminateResponseCode {\n\tswitch (status) {\n\t\tcase 0:\n\t\t\treturn TerminateResponseCode.Success;\n\t\tcase 1:\n\t\t\treturn TerminateResponseCode.AccessDenied;\n\t\tcase 128:\n\t\t\treturn TerminateResponseCode.ProcessNotFound;\n\t\tdefault:\n\t\t\treturn TerminateResponseCode.Unknown;\n\t}\n}\n\nexport function terminateProcess(process: cp.ChildProcess, cwd?: string): TerminateResponse {\n\tif (Platform.isWindows) {\n\t\ttry {\n\t\t\tconst options: any = {\n\t\t\t\tstdio: ['pipe', 'pipe', 'ignore']\n\t\t\t};\n\t\t\tif (cwd) {\n\t\t\t\toptions.cwd = cwd;\n\t\t\t}\n\t\t\tcp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err, code: err.status ? getWindowsCode(err.status) : TerminateResponseCode.Unknown };\n\t\t}\n\t} else if (Platform.isLinux || Platform.isMacintosh) {\n\t\ttry {\n\t\t\tconst cmd = getPathFromAmdModule(require, 'vs/base/node/terminateProcess.sh');\n\t\t\tconst result = cp.spawnSync(cmd, [process.pid.toString()]);\n\t\t\tif (result.error) {\n\t\t\t\treturn { success: false, error: result.error };\n\t\t\t}\n\t\t} catch (err) {\n\t\t\treturn { success: false, error: err };\n\t\t}\n\t} else {\n\t\tprocess.kill('SIGKILL');\n\t}\n\treturn { success: true };\n}\n\nexport function getWindowsShell(): string {\n\treturn process.env['comspec'] || 'cmd.exe';\n}\n\nexport abstract class AbstractProcess<TProgressData> {\n\tprivate cmd: string;\n\tprivate args: string[];\n\tprivate options: CommandOptions | ForkOptions;\n\tprotected shell: boolean;\n\n\tprivate childProcess: cp.ChildProcess | null;\n\tprotected childProcessPromise: Promise<cp.ChildProcess> | null;\n\tprivate pidResolve?: ValueCallback<number>;\n\tprotected terminateRequested: boolean;\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[] | undefined, shell: boolean, options: CommandOptions | undefined);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean, arg4?: CommandOptions) {\n\t\tif (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n\t\t\tthis.cmd = <string>arg1;\n\t\t\tthis.args = arg2;\n\t\t\tthis.shell = arg3;\n\t\t\tthis.options = arg4;\n\t\t} else {\n\t\t\tconst executable = <Executable>arg1;\n\t\t\tthis.cmd = executable.command;\n\t\t\tthis.shell = executable.isShellCommand;\n\t\t\tthis.args = executable.args.slice(0);\n\t\t\tthis.options = executable.options || {};\n\t\t}\n\n\t\tthis.childProcess = null;\n\t\tthis.terminateRequested = false;\n\n\t\tif (this.options.env) {\n\t\t\tconst newEnv: IStringDictionary<string> = Object.create(null);\n\t\t\tObject.keys(process.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = process.env[key]!;\n\t\t\t});\n\t\t\tObject.keys(this.options.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = this.options.env![key]!;\n\t\t\t});\n\t\t\tthis.options.env = newEnv;\n\t\t}\n\t}\n\n\tpublic getSanitizedCommand(): string {\n\t\tlet result = this.cmd.toLowerCase();\n\t\tconst index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (AbstractProcess.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tpublic start(pp: ProgressCallback<TProgressData>): Promise<SuccessData> {\n\t\tif (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n\t\t\treturn Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n\t\t}\n\t\treturn this.useExec().then((useExec) => {\n\t\t\tlet cc: ValueCallback<SuccessData>;\n\t\t\tlet ee: ErrorCallback;\n\t\t\tconst result = new Promise<any>((c, e) => {\n\t\t\t\tcc = c;\n\t\t\t\tee = e;\n\t\t\t});\n\n\t\t\tif (useExec) {\n\t\t\t\tlet cmd: string = this.cmd;\n\t\t\t\tif (this.args) {\n\t\t\t\t\tcmd = cmd + ' ' + this.args.join(' ');\n\t\t\t\t}\n\t\t\t\tthis.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tconst err: any = error;\n\t\t\t\t\t// This is tricky since executing a command shell reports error back in case the executed command return an\n\t\t\t\t\t// error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n\t\t\t\t\t// always parse the output and report success unless the job got killed.\n\t\t\t\t\tif (err && err.killed) {\n\t\t\t\t\t\tee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleExec(cc, pp, error, stdout as any, stderr as any);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet childProcess: cp.ChildProcess | null = null;\n\t\t\t\tconst closeHandler = (data: any) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tthis.childProcessPromise = null;\n\t\t\t\t\tthis.handleClose(data, cc, pp, ee);\n\t\t\t\t\tconst result: SuccessData = {\n\t\t\t\t\t\tterminated: this.terminateRequested\n\t\t\t\t\t};\n\t\t\t\t\tif (Types.isNumber(data)) {\n\t\t\t\t\t\tresult.cmdCode = <number>data;\n\t\t\t\t\t}\n\t\t\t\t\tcc(result);\n\t\t\t\t};\n\t\t\t\tif (this.shell && Platform.isWindows) {\n\t\t\t\t\tconst options: any = Objects.deepClone(this.options);\n\t\t\t\t\toptions.windowsVerbatimArguments = true;\n\t\t\t\t\toptions.detached = false;\n\t\t\t\t\tlet quotedCommand: boolean = false;\n\t\t\t\t\tlet quotedArg: boolean = false;\n\t\t\t\t\tconst commandLine: string[] = [];\n\t\t\t\t\tlet quoted = this.ensureQuotes(this.cmd);\n\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\tquotedCommand = quoted.quoted;\n\t\t\t\t\tif (this.args) {\n\t\t\t\t\t\tthis.args.forEach((elem) => {\n\t\t\t\t\t\t\tquoted = this.ensureQuotes(elem);\n\t\t\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\t\t\tquotedArg = quotedArg && quoted.quoted;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconst args: string[] = [\n\t\t\t\t\t\t'/s',\n\t\t\t\t\t\t'/c',\n\t\t\t\t\t];\n\t\t\t\t\tif (quotedCommand) {\n\t\t\t\t\t\tif (quotedArg) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine.join(' ') + '\"');\n\t\t\t\t\t\t} else if (commandLine.length > 1) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push(commandLine.join(' '));\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess = cp.spawn(getWindowsShell(), args, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.cmd) {\n\t\t\t\t\t\tchildProcess = cp.spawn(this.cmd, this.args, this.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (childProcess) {\n\t\t\t\t\tthis.childProcess = childProcess;\n\t\t\t\t\tthis.childProcessPromise = Promise.resolve(childProcess);\n\t\t\t\t\tif (this.pidResolve) {\n\t\t\t\t\t\tthis.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n\t\t\t\t\t\tthis.pidResolve = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess.on('error', (error: Error) => {\n\t\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\t\tee({ terminated: this.terminateRequested, error: error });\n\t\t\t\t\t});\n\t\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\t\tthis.childProcess.on('close', closeHandler);\n\t\t\t\t\t\tthis.handleSpawn(childProcess, cc!, pp, ee!, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tprotected abstract handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, error: Error | null, stdout: Buffer, stderr: Buffer): void;\n\tprotected abstract handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback, sync: boolean): void;\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback): void {\n\t\t// Default is to do nothing.\n\t}\n\n\tprivate static readonly regexp = /^[^\"].* .*[^\"]/;\n\tprivate ensureQuotes(value: string) {\n\t\tif (AbstractProcess.regexp.test(value)) {\n\t\t\treturn {\n\t\t\t\tvalue: '\"' + value + '\"', //`\"${value}\"`,\n\t\t\t\tquoted: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tquoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic get pid(): Promise<number> {\n\t\tif (this.childProcessPromise) {\n\t\t\treturn this.childProcessPromise.then(childProcess => childProcess.pid, err => -1);\n\t\t} else {\n\t\t\treturn new Promise<number>((resolve) => {\n\t\t\t\tthis.pidResolve = resolve;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic terminate(): Promise<TerminateResponse> {\n\t\tif (!this.childProcessPromise) {\n\t\t\treturn Promise.resolve<TerminateResponse>({ success: true });\n\t\t}\n\t\treturn this.childProcessPromise.then((childProcess) => {\n\t\t\tthis.terminateRequested = true;\n\t\t\tconst result = terminateProcess(childProcess, this.options.cwd);\n\t\t\tif (result.success) {\n\t\t\t\tthis.childProcess = null;\n\t\t\t}\n\t\t\treturn result;\n\t\t}, (err) => {\n\t\t\treturn { success: true };\n\t\t});\n\t}\n\n\tprivate useExec(): Promise<boolean> {\n\t\treturn new Promise<boolean>((c, e) => {\n\t\t\tif (!this.shell || !Platform.isWindows) {\n\t\t\t\treturn c(false);\n\t\t\t}\n\t\t\tconst cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n\t\t\tcmdShell.on('error', (error: Error) => {\n\t\t\t\treturn c(true);\n\t\t\t});\n\t\t\tcmdShell.on('exit', (data: any) => {\n\t\t\t\treturn c(false);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class LineProcess extends AbstractProcess<LineData> {\n\n\tprivate stdoutLineDecoder: LineDecoder;\n\tprivate stderrLineDecoder: LineDecoder;\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[], shell: boolean, options: CommandOptions);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean | ForkOptions, arg4?: CommandOptions) {\n\t\tsuper(<any>arg1, arg2, <any>arg3, arg4);\n\t}\n\n\tprotected handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, error: Error, stdout: Buffer, stderr: Buffer) {\n\t\t[stdout, stderr].forEach((buffer: Buffer, index: number) => {\n\t\t\tconst lineDecoder = new LineDecoder();\n\t\t\tconst lines = lineDecoder.write(buffer);\n\t\t\tlines.forEach((line) => {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t});\n\t\t\tconst line = lineDecoder.end();\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t\tcc({ terminated: this.terminateRequested, error: error });\n\t}\n\n\tprotected handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback, sync: boolean): void {\n\t\tthis.stdoutLineDecoder = new LineDecoder();\n\t\tthis.stderrLineDecoder = new LineDecoder();\n\t\tchildProcess.stdout.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stdoutLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stdout }));\n\t\t});\n\t\tchildProcess.stderr.on('data', (data: Buffer) => {\n\t\t\tconst lines = this.stderrLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stderr }));\n\t\t});\n\t}\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback): void {\n\t\t[this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach((line, index) => {\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport function findExecutable(command: string, cwd?: string, paths?: string[]): string {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env.PATH)) {\n\t\t\tpaths = process.env.PATH.split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (let pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (fs.existsSync(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (fs.existsSync(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, fork, ForkOptions } from 'child_process';\nimport { IDisposable, toDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Delayer, createCancelablePromise } from 'vs/base/common/async';\nimport { deepClone, assign } from 'vs/base/common/objects';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { createQueuedSender } from 'vs/base/node/processes';\nimport { ChannelServer as IPCServer, ChannelClient as IPCClient, IChannelClient, IChannel } from 'vs/base/parts/ipc/node/ipc';\nimport { isRemoteConsoleLog, log } from 'vs/base/node/console';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper({\n\t\t\tsend: r => {\n\t\t\t\ttry {\n\t\t\t\t\tif (process.send) {\n\t\t\t\t\t\tprocess.send(r.toString('base64'));\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /* not much to do */ }\n\t\t\t},\n\t\t\tonMessage: Event.fromNodeEventEmitter(process, 'message', msg => Buffer.from(msg, 'base64'))\n\t\t}, ctx);\n\n\t\tprocess.once('disconnect', () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * See https://github.com/Microsoft/vscode/issues/27665\n\t * Allows to pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.\n\t * e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host\n\t * results in the forked process inheriting `--inspect-brk=xxx`.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\n\tprivate disposeDelayer: Delayer<void>;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate _onDidProcessExit = new Emitter<{ code: number, signal: string }>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(private modulePath: string, private options: IIPCOptions) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error('disposed'));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise(token => channel.call<T>(name, arg, token));\n\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(channelName: string, name: string, arg?: any): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args = this.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = assign(deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = assign(forkOpts.env, this.options.env);\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n\t\t\t}\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<Buffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n\n\t\t\tonRawMessage(msg => {\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(Buffer.from(msg, 'base64'));\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue ? createQueuedSender(this.child) : this.child;\n\t\t\tconst send = (r: Buffer) => this.child && (process.env.isBrowser ? true : this.child.connected) && sender.send(r.toString('base64'));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once('exit', onExit);\n\n\t\t\tthis.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n\n\t\t\tthis.child.on('exit', (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener('exit', onExit);\n\n\t\t\t\tthis.activeRequests.forEach(r => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== 'SIGTERM') {\n\t\t\t\t\tconsole.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n\t\t\t\t}\n\n\t\t\t\tif (this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.cancel();\n\t\t\t\t}\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tthis.disposeDelayer.cancel();\n\t\tthis.disposeDelayer = null!; // StrictNullOverride: nulling out ok in dispose\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ServiceCollection } from './serviceCollection';\nimport * as descriptors from './descriptors';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>, index: number, optional: boolean }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport interface IConstructorSignature0<T> {\n\tnew(...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature1<A1, T> {\n\tnew(first: A1, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature2<A1, A2, T> {\n\tnew(first: A1, second: A2, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature3<A1, A2, A3, T> {\n\tnew(first: A1, second: A2, third: A3, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature4<A1, A2, A3, A4, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature5<A1, A2, A3, A4, A5, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature6<A1, A2, A3, A4, A5, A6, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>, isOptional?: typeof optional): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\nexport interface IInstantiationService {\n\n\t_serviceBrand: any;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by\n\t * the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<A1, T>(descriptor: descriptors.SyncDescriptor1<A1, T>, a1: A1): T;\n\tcreateInstance<A1, A2, T>(descriptor: descriptors.SyncDescriptor2<A1, A2, T>, a1: A1, a2: A2): T;\n\tcreateInstance<A1, A2, A3, T>(descriptor: descriptors.SyncDescriptor3<A1, A2, A3, T>, a1: A1, a2: A2, a3: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(descriptor: descriptors.SyncDescriptor4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3, a4: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(descriptor: descriptors.SyncDescriptor5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(descriptor: descriptors.SyncDescriptor6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(descriptor: descriptors.SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(descriptor: descriptors.SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;\n\n\tcreateInstance<T>(ctor: IConstructorSignature0<T>): T;\n\tcreateInstance<A1, T>(ctor: IConstructorSignature1<A1, T>, first: A1): T;\n\tcreateInstance<A1, A2, T>(ctor: IConstructorSignature2<A1, A2, T>, first: A1, second: A2): T;\n\tcreateInstance<A1, A2, A3, T>(ctor: IConstructorSignature3<A1, A2, A3, T>, first: A1, second: A2, third: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(ctor: IConstructorSignature4<A1, A2, A3, A4, T>, first: A1, second: A2, third: A3, fourth: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(ctor: IConstructorSignature5<A1, A2, A3, A4, A5, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(ctor: IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(ctor: IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8): T;\n\n\t/**\n\t *\n\t */\n\tinvokeFunction<R, TS extends any[]=[]>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherts all current services\n\t * and adds/overwrites the given services\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type T\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void {\n\tif (target[_util.DI_TARGET] === target) {\n\t\ttarget[_util.DI_DEPENDENCIES].push({ id, index, optional });\n\t} else {\n\t\ttarget[_util.DI_DEPENDENCIES] = [{ id, index, optional }];\n\t\ttarget[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * A *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): { (...args: any[]): void; type: T; } {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index, false);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\n/**\n * Mark a service dependency as optional.\n */\nexport function optional<T>(serviceIdentifier: ServiceIdentifier<T>) {\n\n\treturn function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@optional-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(serviceIdentifier, target, index, true);\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createDecorator as createServiceDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IDisposable, Disposable } from 'vs/base/common/lifecycle';\nimport { isWindows } from 'vs/base/common/platform';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\n\nexport const ILogService = createServiceDecorator<ILogService>('logService');\n\nfunction now(): string {\n\treturn new Date().toISOString();\n}\n\nexport enum LogLevel {\n\tTrace,\n\tDebug,\n\tInfo,\n\tWarning,\n\tError,\n\tCritical,\n\tOff\n}\n\nexport const DEFAULT_LOG_LEVEL: LogLevel = LogLevel.Info;\n\nexport interface ILogService extends IDisposable {\n\t_serviceBrand: any;\n\tonDidChangeLogLevel: Event<LogLevel>;\n\n\tgetLevel(): LogLevel;\n\tsetLevel(level: LogLevel): void;\n\ttrace(message: string, ...args: any[]): void;\n\tdebug(message: string, ...args: any[]): void;\n\tinfo(message: string, ...args: any[]): void;\n\twarn(message: string, ...args: any[]): void;\n\terror(message: string | Error, ...args: any[]): void;\n\tcritical(message: string | Error, ...args: any[]): void;\n}\n\nexport abstract class AbstractLogService extends Disposable {\n\n\tprivate level: LogLevel = DEFAULT_LOG_LEVEL;\n\tprivate readonly _onDidChangeLogLevel: Emitter<LogLevel> = this._register(new Emitter<LogLevel>());\n\treadonly onDidChangeLogLevel: Event<LogLevel> = this._onDidChangeLogLevel.event;\n\n\tsetLevel(level: LogLevel): void {\n\t\tif (this.level !== level) {\n\t\t\tthis.level = level;\n\t\t\tthis._onDidChangeLogLevel.fire(this.level);\n\t\t}\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.level;\n\t}\n}\n\nexport class ConsoleLogMainService extends AbstractLogService implements ILogService {\n\n\t_serviceBrand: any;\n\tprivate useColors: boolean;\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t\tthis.useColors = !isWindows;\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Trace) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Debug) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Info) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.log(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Warning) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.warn(`\\x1b[93m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Error) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error(`\\x1b[91m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tcritical(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Critical) {\n\t\t\tif (this.useColors) {\n\t\t\t\tconsole.error(`\\x1b[90m[main ${now()}]\\x1b[0m`, message, ...args);\n\t\t\t} else {\n\t\t\t\tconsole.error(`[main ${now()}]`, message, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\t// noop\n\t}\n}\n\nexport class ConsoleLogService extends AbstractLogService implements ILogService {\n\n\t_serviceBrand: any;\n\n\tconstructor(logLevel: LogLevel = DEFAULT_LOG_LEVEL) {\n\t\tsuper();\n\t\tthis.setLevel(logLevel);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Trace) {\n\t\t\tconsole.log('%cTRACE', 'color: #888', message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Debug) {\n\t\t\tconsole.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Info) {\n\t\t\tconsole.log('%c INFO', 'color: #33f', message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string | Error, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Warning) {\n\t\t\tconsole.log('%c WARN', 'color: #993', message, ...args);\n\t\t}\n\t}\n\n\terror(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Error) {\n\t\t\tconsole.log('%c  ERR', 'color: #f33', message, ...args);\n\t\t}\n\t}\n\n\tcritical(message: string, ...args: any[]): void {\n\t\tif (this.getLevel() <= LogLevel.Critical) {\n\t\t\tconsole.log('%cCRITI', 'background: #f33; color: white', message, ...args);\n\t\t}\n\t}\n\n\tdispose(): void { }\n}\n\nexport class MultiplexLogService extends AbstractLogService implements ILogService {\n\t_serviceBrand: any;\n\n\tconstructor(private logServices: ILogService[]) {\n\t\tsuper();\n\t\tif (logServices.length) {\n\t\t\tthis.setLevel(logServices[0].getLevel());\n\t\t}\n\t}\n\n\tsetLevel(level: LogLevel): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.setLevel(level);\n\t\t}\n\t\tsuper.setLevel(level);\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.trace(message, ...args);\n\t\t}\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.debug(message, ...args);\n\t\t}\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.info(message, ...args);\n\t\t}\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.warn(message, ...args);\n\t\t}\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.error(message, ...args);\n\t\t}\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.critical(message, ...args);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tfor (const logService of this.logServices) {\n\t\t\tlogService.dispose();\n\t\t}\n\t}\n}\n\nexport class DelegatedLogService extends Disposable implements ILogService {\n\t_serviceBrand: any;\n\n\tconstructor(private logService: ILogService) {\n\t\tsuper();\n\t\tthis._register(logService);\n\t}\n\n\tget onDidChangeLogLevel(): Event<LogLevel> {\n\t\treturn this.logService.onDidChangeLogLevel;\n\t}\n\n\tsetLevel(level: LogLevel): void {\n\t\tthis.logService.setLevel(level);\n\t}\n\n\tgetLevel(): LogLevel {\n\t\treturn this.logService.getLevel();\n\t}\n\n\ttrace(message: string, ...args: any[]): void {\n\t\tthis.logService.trace(message, ...args);\n\t}\n\n\tdebug(message: string, ...args: any[]): void {\n\t\tthis.logService.debug(message, ...args);\n\t}\n\n\tinfo(message: string, ...args: any[]): void {\n\t\tthis.logService.info(message, ...args);\n\t}\n\n\twarn(message: string, ...args: any[]): void {\n\t\tthis.logService.warn(message, ...args);\n\t}\n\n\terror(message: string | Error, ...args: any[]): void {\n\t\tthis.logService.error(message, ...args);\n\t}\n\n\tcritical(message: string | Error, ...args: any[]): void {\n\t\tthis.logService.critical(message, ...args);\n\t}\n}\n\nexport class NullLogService implements ILogService {\n\t_serviceBrand: any;\n\treadonly onDidChangeLogLevel: Event<LogLevel> = new Emitter<LogLevel>().event;\n\tsetLevel(level: LogLevel): void { }\n\tgetLevel(): LogLevel { return LogLevel.Info; }\n\ttrace(message: string, ...args: any[]): void { }\n\tdebug(message: string, ...args: any[]): void { }\n\tinfo(message: string, ...args: any[]): void { }\n\twarn(message: string, ...args: any[]): void { }\n\terror(message: string | Error, ...args: any[]): void { }\n\tcritical(message: string | Error, ...args: any[]): void { }\n\tdispose(): void { }\n}\n\nexport function getLogLevel(environmentService: IEnvironmentService): LogLevel {\n\tif (environmentService.verbose) {\n\t\treturn LogLevel.Trace;\n\t}\n\tif (typeof environmentService.args.log === 'string') {\n\t\tconst logLevel = environmentService.args.log.toLowerCase();\n\t\tswitch (logLevel) {\n\t\t\tcase 'trace':\n\t\t\t\treturn LogLevel.Trace;\n\t\t\tcase 'debug':\n\t\t\t\treturn LogLevel.Debug;\n\t\t\tcase 'info':\n\t\t\t\treturn LogLevel.Info;\n\t\t\tcase 'warn':\n\t\t\t\treturn LogLevel.Warning;\n\t\t\tcase 'error':\n\t\t\t\treturn LogLevel.Error;\n\t\t\tcase 'critical':\n\t\t\t\treturn LogLevel.Critical;\n\t\t\tcase 'off':\n\t\t\t\treturn LogLevel.Off;\n\t\t}\n\t}\n\treturn DEFAULT_LOG_LEVEL;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as appInsights from 'applicationinsights';\nimport { isObject } from 'vs/base/common/types';\nimport { safeStringify, mixin } from 'vs/base/common/objects';\nimport { ITelemetryAppender } from 'vs/platform/telemetry/common/telemetryUtils';\nimport { ILogService } from 'vs/platform/log/common/log';\n\nfunction getClient(aiKey: string): appInsights.TelemetryClient {\n\n\tlet client: appInsights.TelemetryClient;\n\tif (appInsights.defaultClient) {\n\t\tclient = new appInsights.TelemetryClient(aiKey);\n\t\tclient.channel.setUseDiskRetryCaching(true);\n\t} else {\n\t\tappInsights.setup(aiKey)\n\t\t\t.setAutoCollectRequests(false)\n\t\t\t.setAutoCollectPerformance(false)\n\t\t\t.setAutoCollectExceptions(false)\n\t\t\t.setAutoCollectDependencies(false)\n\t\t\t.setAutoDependencyCorrelation(false)\n\t\t\t.setAutoCollectConsole(false)\n\t\t\t.setInternalLogging(false, false)\n\t\t\t.setUseDiskRetryCaching(true)\n\t\t\t.start();\n\t\tclient = appInsights.defaultClient;\n\t}\n\n\tif (aiKey.indexOf('AIF-') === 0) {\n\t\tclient.config.endpointUrl = 'https://fes.bytedance.net/collect';\n\t}\n\treturn client;\n}\n\ninterface Properties {\n\t[key: string]: string;\n}\n\ninterface Measurements {\n\t[key: string]: number;\n}\n\nexport class AppInsightsAppender implements ITelemetryAppender {\n\n\tprivate _aiClient?: appInsights.TelemetryClient;\n\n\tconstructor(\n\t\tprivate _eventPrefix: string,\n\t\tprivate _defaultData: { [key: string]: any } | null,\n\t\taiKeyOrClientFactory: string | (() => appInsights.ITelemetryClient), // allow factory function for testing\n\t\t@ILogService private _logService?: ILogService\n\t) {\n\t\tif (!this._defaultData) {\n\t\t\tthis._defaultData = Object.create(null);\n\t\t}\n\n\t\tif (typeof aiKeyOrClientFactory === 'string') {\n\t\t\tthis._aiClient = getClient(aiKeyOrClientFactory);\n\t\t} else if (typeof aiKeyOrClientFactory === 'function') {\n\t\t\tthis._aiClient = aiKeyOrClientFactory();\n\t\t}\n\t}\n\n\tprivate static _getData(data?: any): { properties: Properties, measurements: Measurements } {\n\n\t\tconst properties: Properties = Object.create(null);\n\t\tconst measurements: Measurements = Object.create(null);\n\n\t\tconst flat = Object.create(null);\n\t\tAppInsightsAppender._flaten(data, flat);\n\n\t\tfor (let prop in flat) {\n\t\t\t// enforce property names less than 150 char, take the last 150 char\n\t\t\tprop = prop.length > 150 ? prop.substr(prop.length - 149) : prop;\n\t\t\tconst value = flat[prop];\n\n\t\t\tif (typeof value === 'number') {\n\t\t\t\tmeasurements[prop] = value;\n\n\t\t\t} else if (typeof value === 'boolean') {\n\t\t\t\tmeasurements[prop] = value ? 1 : 0;\n\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\t//enforce property value to be less than 1024 char, take the first 1024 char\n\t\t\t\tproperties[prop] = value.substring(0, 1023);\n\n\t\t\t} else if (typeof value !== 'undefined' && value !== null) {\n\t\t\t\tproperties[prop] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproperties,\n\t\t\tmeasurements\n\t\t};\n\t}\n\n\tprivate static _flaten(obj: any, result: { [key: string]: any }, order: number = 0, prefix?: string): void {\n\t\tif (!obj) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let item of Object.getOwnPropertyNames(obj)) {\n\t\t\tconst value = obj[item];\n\t\t\tconst index = prefix ? prefix + item : item;\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tresult[index] = safeStringify(value);\n\n\t\t\t} else if (value instanceof Date) {\n\t\t\t\t// TODO unsure why this is here and not in _getData\n\t\t\t\tresult[index] = value.toISOString();\n\n\t\t\t} else if (isObject(value)) {\n\t\t\t\tif (order < 2) {\n\t\t\t\t\tAppInsightsAppender._flaten(value, result, order + 1, index + '.');\n\t\t\t\t} else {\n\t\t\t\t\tresult[index] = safeStringify(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[index] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tlog(eventName: string, data?: any): void {\n\t\tif (!this._aiClient) {\n\t\t\treturn;\n\t\t}\n\t\tdata = mixin(data, this._defaultData);\n\t\tdata = AppInsightsAppender._getData(data);\n\n\t\tif (this._logService) {\n\t\t\tthis._logService.trace(`telemetry/${eventName}`, data);\n\t\t}\n\t\tthis._aiClient.trackEvent({\n\t\t\tname: this._eventPrefix + '/' + eventName,\n\t\t\tproperties: data.properties,\n\t\t\tmeasurements: data.measurements\n\t\t});\n\t}\n\n\tdispose(): Promise<any> | undefined {\n\t\tif (this._aiClient) {\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis._aiClient!.flush({\n\t\t\t\t\tcallback: () => {\n\t\t\t\t\t\t// all data flushed\n\t\t\t\t\t\tthis._aiClient = undefined;\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IChannel, IServerChannel } from 'vs/base/parts/ipc/node/ipc';\nimport { ITelemetryAppender } from 'vs/platform/telemetry/common/telemetryUtils';\nimport { Event } from 'vs/base/common/event';\n\nexport interface ITelemetryLog {\n\teventName: string;\n\tdata?: any;\n}\n\nexport class TelemetryAppenderChannel implements IServerChannel {\n\n\tconstructor(private appender: ITelemetryAppender) { }\n\n\tlisten<T>(_, event: string): Event<T> {\n\t\tthrow new Error(`Event not found: ${event}`);\n\t}\n\n\tcall(_, command: string, { eventName, data }: ITelemetryLog): Promise<any> {\n\t\tthis.appender.log(eventName, data);\n\t\treturn Promise.resolve(null);\n\t}\n}\n\nexport class TelemetryAppenderClient implements ITelemetryAppender {\n\n\tconstructor(private channel: IChannel) { }\n\n\tlog(eventName: string, data?: any): any {\n\t\tthis.channel.call('log', { eventName, data })\n\t\t\t.then(undefined, err => `Failed to log telemetry: ${console.warn(err)}`);\n\n\t\treturn Promise.resolve(null);\n\t}\n\n\tdispose(): any {\n\t\t// TODO\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Server } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { AppInsightsAppender } from 'vs/platform/telemetry/node/appInsightsAppender';\nimport { TelemetryAppenderChannel } from 'vs/platform/telemetry/node/telemetryIpc';\n\nconst appender = new AppInsightsAppender(process.argv[2], JSON.parse(process.argv[3]), process.argv[4]);\nprocess.once('exit', () => appender.dispose());\n\nconst channel = new TelemetryAppenderChannel(appender);\nconst server = new Server('telemetry');\nserver.registerChannel('telemetryAppender', channel);\n"]}