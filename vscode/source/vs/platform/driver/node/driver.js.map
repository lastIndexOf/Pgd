{"version":3,"sources":["vs/platform/driver/node/fake","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/errors.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/functional.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/iterator.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/lifecycle.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/linkedList.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/event.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/cancellation.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/async.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/platform.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/process.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/path.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/common/uuid.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/base/parts/ipc/node/ipc.net.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/instantiation/common/instantiation.ts","vs/platform/driver/node/file:/Users/zhengfankai/Desktop/workspace/vs-editor/src/vs/platform/driver/node/driver.ts"],"names":["__m","__M","deps","result","i","len","length","isPromiseCanceledError","error","Error","name","canceledName","message","ErrorHandler","[object Object]","this","listeners","unexpectedErrorHandler","e","setTimeout","stack","listener","push","_removeListener","forEach","splice","indexOf","newUnexpectedErrorHandler","emit","exports","errorHandler","setUnexpectedErrorHandler","onUnexpectedError","onUnexpectedExternalError","transformErrorForSerialization","$isError","stacktrace","canceled","illegalArgument","illegalState","readonly","disposed","what","getErrorMessage","err","split","String","once","fn","_this","didCall","apply","arguments","FIN","done","value","undefined","Iterator","iterator","next","_empty","empty","fromArray","array","index","from","elements","Array","isArray","map","element","filter","collect","getSequenceIterator","arg","ArrayIterator","items","start","end","current","Math","min","ArrayNavigator","super","max","MappedIterator","MappedNavigator","navigator","previous","parent","first","last","dispose","rest","d","isDisposable","thing","combinedDisposable","disposables","toDisposable","Disposable","_toDispose","_lifecycle_disposable_isDisposed","toDispose","t","console","warn","None","Object","freeze","ReferenceCollection","references","create","key","reference","counter","object","createReferencedObject","functional_1","destroyReferencedObject","ImmortalReference","Node","LinkedList","_size","size","_first","_last","_insert","atTheEnd","newNode","oldLast","prev","oldFirst","_remove","bind","res","node","candidate","anchor","iterator_1","Event","event","thisArgs","didFire","call","snapshot","each","reduce","merge","initial","output","emitter","Emitter","fire","latch","cache","firstCall","shouldEmit","_disposable","signal","any","events","lifecycle_1","debounce","delay","leading","leakWarningThreshold","subscription","handle","numDebouncedCalls","cur","clearTimeout","_output","stopwatch","Date","getTime","_","buffer","nextTick","_buffer","slice","flush","echo","ChainableEvent","chain","fromNodeEventEmitter","eventName","id","args","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromPromise","promise","then","toPromise","Promise","c","_globalLeakWarningThreshold","setGlobalLeakWarningThreshold","n","oldValue","LeakageMonitor","customThreshold","random","toString","_warnCountdown","_stacks","clear","listenerCount","threshold","Map","join","count","get","set","topStack","topCount","options","_disposed","_options","_leakageMon","_event","_listeners","linkedList_1","firstListener","isEmpty","remove","onFirstListenerDidAdd","onListenerDidAdd","removeMonitor","check","_noop","_deliveryQueue","iter","shift","errors_1","AsyncEmitter","eventFn","_asyncDeliveryQueue","thenables","all","EventMultiplexer","hasListeners","hook","unhook","idx","r","EventBufferer","buffers","pop","Relay","listening","inputEvent","inputEventListener","input","shortcutEvent","callback","context","CancellationToken","isCancellationToken","Cancelled","MutableToken","isCancellationRequested","onCancellationRequested","event_1","_isCancelled","_emitter","CancellationTokenSource","token","_token","cancel","isThenable","obj","createCancelablePromise","source","cancellation_1","thenable","resolve","reject","errors","onfinally","finally","timeout","millis","sequence","promiseFactories","thenHandler","results","asPromise","item","Throttler","activePromise","queuedPromise","queuedPromiseFactory","promiseFactory","onComplete","queue","Sequencer","promiseTask","Delayer","defaultDelay","completionPromise","doResolve","task","cancelTimeout","doReject","ThrottledDelayer","delayer","throttler","trigger","isTriggered","Barrier","_isOpen","_promise","_completePromise","disposableTimeout","handler","timer","ignoreErrors","shouldStop","defaultValue","loop","factory","Limiter","maxDegreeOfParalellism","outstandingPromises","runningPromises","_onFinished","onFinished","consume","iLimitedTask","consumed","Queue","ResourceQueue","queues","resource","TimeoutTimer","runner","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","isScheduled","doRun","RunOnceWorker","units","unit","schedule","nfcall","ninvoke","thisArg","requestIdleCallback","cancelIdleCallback","dummyIdle","didTimeout","timeRemaining","runWhenIdle","IdleValue","executor","_executor","_value","_error","_didRun","_handle","LANGUAGE_DEFAULT","_isWindows","_isMacintosh","_isNative","_locale","_language","_translationsConfigFile","isElectronRenderer","process","versions","electron","type","platform","rawNlsConfig","env","nlsConfig","JSON","parse","resolved","availableLanguages","locale","userAgent","language","Platform","PlatformToString","isRealWindows","isWindows","isMacintosh","isLinux","isNative","isWeb","isRootUser","getuid","translationsConfigFile","_globals","self","global","globals","_setImmediate","setImmediate","OperatingSystem","OS","safeProcess","cwd","platform_1","validateString","ErrorInvalidArgType","isPathSeparator","code","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","isPosixPathSeparator","isWindowsDeviceRoot","CHAR_UPPERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_A","CHAR_LOWERCASE_Z","normalizeString","path","allowAboveRoot","separator","lastSegmentLength","lastSlash","dots","charCodeAt","CHAR_DOT","lastSlashIndex","lastIndexOf","_format","sep","pathObject","dir","root","base","ext","expected","actual","determiner","replace","msg","win32","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","toLowerCase","rootEnd","device","isAbsolute","j","firstPart","tail","paths","joined","needsReplace","slashCount","firstLen","normalize","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","resolvedPath","matchedSlash","offset","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","delimiter","posix","trailingSeparator","toNamespacedPath","hasRoot","relative","dirname","basename","extname","format","v4","V4UUID","isUUID","_UUIDPattern","test","ValueUUID","_randomHex","_oneOf","_timeHighBits","floor","_chars","generateUuid","asHex","createSizeBuffer","Buffer","allocUnsafe","writeUInt32BE","readSizeBuffer","reader","read","readUInt32BE","serialize","writer","data","write","BufferPresets","Undefined","isBuffer","el","stringify","deserialize","readUInt8","DataType","getDelayedChannel","command","cancellationToken","relay","listen","RequestType","ResponseType","State","BufferReader","pos","bytes","BufferWriter","concat","alloc","ChannelServer","protocol","ctx","channels","activeRequests","protocolListener","onMessage","onRawMessage","sendResponse","channelName","channel","response","send","header","body","sendBuffer","onPromise","onEventListen","disposeActiveRequest","request","cancellationTokenSource","delete","disposable","ChannelClient","state","Uninitialized","Set","handlers","lastRequestId","_onDidInitialize","onDidInitialize","onBuffer","that","requestPromise","requestEvent","uninitializedPromise","async_1","whenInitialized","sendRequest","cancellationTokenListener","add","onResponse","Idle","p","IPCServer","onDidClientConnect","_connections","_onDidChangeConnections","onDidChangeConnections","onDidClientDisconnect","onFirstMessage","channelServer","channelClient","registerChannel","connection","connections","router","routeCall","getChannel","routeEvent","IPCClient","getNextTickChannel","didTick","StaticRouter","hub","route","createBufferedEvent","isDeliveringMessages","bufferedMessages","deliverMessages","generateRandomPipeName","randomSuffix","uuid_1","path_1","os_1","tmpdir","ChunkStream","byteLength","_totalLength","_chunks","buff","byteCount","resultOffset","chunk","copy","Protocol","_socket","_onMessage","_onClose","onClose","_writeBuffer","_data","head","wasEmpty","_isDisposed","_incomingData","readHead","bodyLen","_socketDataListener","acceptChunk","_headerLen","_socketEndListener","_socketCloseListener","_writeSoon","destroyed","take","Server","ipc_1","server","onConnection","socket","toClientConnectionEvent","close","Client","serve","net_1","createServer","connect","clientId","createConnection","fromSocket","BufferedProtocol","_actual","storeServiceDependency","target","optional","_util","DI_TARGET","DI_DEPENDENCIES","createDecorator","serviceId","serviceIds","has","getServiceDependencies","ctor","IInstantiationService","serviceIdentifier","ID","IDriver","instantiation_1","DriverChannel","driver","getWindowIds","capturePage","reloadWindow","exitApplication","dispatchKeybinding","click","doubleClick","setValue","getTitle","isActiveElement","getElements","typeInEditor","getTerminalBuffer","writeInTerminal","DriverChannelClient","windowId","keybinding","selector","xoffset","yoffset","text","recursive","WindowDriverRegistryChannel","registry","registerWindowDriver","reloadWindowDriver","WindowDriverRegistryChannelClient","WindowDriverChannel","WindowDriverChannelClient","client","ipc_net_1"],"mappings":"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","file":"driver.js","sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\tpublic addListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tpublic setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tpublic getUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tpublic onUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tpublic onUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tlet { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): any;\n\tgetTypeName(): string;\n\tgetFunction(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string;\n\tgetLineNumber(): number;\n\tgetColumnNumber(): number;\n\tgetEvalOrigin(): string;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error: any): boolean {\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function disposed(what: string): Error {\n\tconst result = new Error(`${what} has been disposed`);\n\tresult.name = 'DISPOSED';\n\treturn result;\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function once<T extends Function>(this: any, fn: T): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: any;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tresult = fn.apply(_this, arguments);\n\n\t\treturn result;\n\t} as any as T;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IteratorDefinedResult<T> {\n\treadonly done: false;\n\treadonly value: T;\n}\nexport interface IteratorUndefinedResult {\n\treadonly done: true;\n\treadonly value: undefined;\n}\nexport const FIN: IteratorUndefinedResult = { done: true, value: undefined };\nexport type IteratorResult<T> = IteratorDefinedResult<T> | IteratorUndefinedResult;\n\nexport interface Iterator<T> {\n\tnext(): IteratorResult<T>;\n}\n\nexport module Iterator {\n\tconst _empty: Iterator<any> = {\n\t\tnext() {\n\t\t\treturn FIN;\n\t\t}\n\t};\n\n\texport function empty<T>(): Iterator<T> {\n\t\treturn _empty;\n\t}\n\n\texport function fromArray<T>(array: T[], index = 0, length = array.length): Iterator<T> {\n\t\treturn {\n\t\t\tnext(): IteratorResult<T> {\n\t\t\t\tif (index >= length) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\treturn { done: false, value: array[index++] };\n\t\t\t}\n\t\t};\n\t}\n\n\texport function from<T>(elements: Iterator<T> | T[] | undefined): Iterator<T> {\n\t\tif (!elements) {\n\t\t\treturn Iterator.empty();\n\t\t} else if (Array.isArray(elements)) {\n\t\t\treturn Iterator.fromArray(elements);\n\t\t} else {\n\t\t\treturn elements;\n\t\t}\n\t}\n\n\texport function map<T, R>(iterator: Iterator<T>, fn: (t: T) => R): Iterator<R> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tconst element = iterator.next();\n\t\t\t\tif (element.done) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t} else {\n\t\t\t\t\treturn { done: false, value: fn(element.value) };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function filter<T>(iterator: Iterator<T>, fn: (t: T) => boolean): Iterator<T> {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst element = iterator.next();\n\t\t\t\t\tif (element.done) {\n\t\t\t\t\t\treturn FIN;\n\t\t\t\t\t}\n\t\t\t\t\tif (fn(element.value)) {\n\t\t\t\t\t\treturn { done: false, value: element.value };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\texport function forEach<T>(iterator: Iterator<T>, fn: (t: T) => void): void {\n\t\tfor (let next = iterator.next(); !next.done; next = iterator.next()) {\n\t\t\tfn(next.value);\n\t\t}\n\t}\n\n\texport function collect<T>(iterator: Iterator<T>): T[] {\n\t\tconst result: T[] = [];\n\t\tforEach(iterator, value => result.push(value));\n\t\treturn result;\n\t}\n}\n\nexport type ISequence<T> = Iterator<T> | T[];\n\nexport function getSequenceIterator<T>(arg: Iterator<T> | T[]): Iterator<T> {\n\tif (Array.isArray(arg)) {\n\t\treturn Iterator.fromArray(arg);\n\t} else {\n\t\treturn arg;\n\t}\n}\n\nexport interface INextIterator<T> {\n\tnext(): T | null;\n}\n\nexport class ArrayIterator<T> implements INextIterator<T> {\n\n\tprivate items: T[];\n\tprotected start: number;\n\tprotected end: number;\n\tprotected index: number;\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tthis.items = items;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.index = index;\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic next(): T | null {\n\t\tthis.index = Math.min(this.index + 1, this.end);\n\t\treturn this.current();\n\t}\n\n\tprotected current(): T | null {\n\t\tif (this.index === this.start - 1 || this.index === this.end) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.items[this.index];\n\t}\n}\n\nexport class ArrayNavigator<T> extends ArrayIterator<T> implements INavigator<T> {\n\n\tconstructor(items: T[], start: number = 0, end: number = items.length, index = start - 1) {\n\t\tsuper(items, start, end, index);\n\t}\n\n\tpublic current(): T | null {\n\t\treturn super.current();\n\t}\n\n\tpublic previous(): T | null {\n\t\tthis.index = Math.max(this.index - 1, this.start - 1);\n\t\treturn this.current();\n\t}\n\n\tpublic first(): T | null {\n\t\tthis.index = this.start;\n\t\treturn this.current();\n\t}\n\n\tpublic last(): T | null {\n\t\tthis.index = this.end - 1;\n\t\treturn this.current();\n\t}\n\n\tpublic parent(): T | null {\n\t\treturn null;\n\t}\n}\n\nexport class MappedIterator<T, R> implements INextIterator<R> {\n\n\tconstructor(protected iterator: INextIterator<T>, protected fn: (item: T | null) => R) {\n\t\t// noop\n\t}\n\n\tnext() { return this.fn(this.iterator.next()); }\n}\n\nexport interface INavigator<T> extends INextIterator<T> {\n\tcurrent(): T | null;\n\tprevious(): T | null;\n\tparent(): T | null;\n\tfirst(): T | null;\n\tlast(): T | null;\n\tnext(): T | null;\n}\n\nexport class MappedNavigator<T, R> extends MappedIterator<T, R> implements INavigator<R> {\n\n\tconstructor(protected navigator: INavigator<T>, fn: (item: T) => R) {\n\t\tsuper(navigator, fn);\n\t}\n\n\tcurrent() { return this.fn(this.navigator.current()); }\n\tprevious() { return this.fn(this.navigator.previous()); }\n\tparent() { return this.fn(this.navigator.parent()); }\n\tfirst() { return this.fn(this.navigator.first()); }\n\tlast() { return this.fn(this.navigator.last()); }\n\tnext() { return this.fn(this.navigator.next()); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable><any>thing).dispose === 'function'\n\t\t&& (<IDisposable><any>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(...disposables: Array<T | undefined>): T[];\nexport function dispose<T extends IDisposable>(disposables: T[]): T[];\nexport function dispose<T extends IDisposable>(first: T | T[], ...rest: T[]): T | T[] | undefined {\n\tif (Array.isArray(first)) {\n\t\tfirst.forEach(d => d && d.dispose());\n\t\treturn [];\n\t} else if (rest.length === 0) {\n\t\tif (first) {\n\t\t\tfirst.dispose();\n\t\t\treturn first;\n\t\t}\n\t\treturn undefined;\n\t} else {\n\t\tdispose(first);\n\t\tdispose(rest);\n\t\treturn [];\n\t}\n}\n\nexport function combinedDisposable(disposables: IDisposable[]): IDisposable {\n\treturn { dispose: () => dispose(disposables) };\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn { dispose() { fn(); } };\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected _toDispose: IDisposable[] = [];\n\tprotected get toDispose(): IDisposable[] { return this._toDispose; }\n\n\tprivate _lifecycle_disposable_isDisposed = false;\n\n\tpublic dispose(): void {\n\t\tthis._lifecycle_disposable_isDisposed = true;\n\t\tthis._toDispose = dispose(this._toDispose);\n\t}\n\n\tprotected _register<T extends IDisposable>(t: T): T {\n\t\tif (this._lifecycle_disposable_isDisposed) {\n\t\t\tconsole.warn('Registering disposable on object that has already been disposed.');\n\t\t\tt.dispose();\n\t\t} else {\n\t\t\tthis._toDispose.push(t);\n\t\t}\n\n\t\treturn t;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate references: { [key: string]: { readonly object: T; counter: number; } } = Object.create(null);\n\n\tconstructor() { }\n\n\tacquire(key: string): IReference<T> {\n\t\tlet reference = this.references[key];\n\n\t\tif (!reference) {\n\t\t\treference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tdelete this.references[key];\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterator, IteratorResult, FIN } from 'vs/base/common/iterator';\n\nclass Node<E> {\n\telement: E;\n\tnext: Node<E> | undefined;\n\tprev: Node<E> | undefined;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> | undefined;\n\tprivate _last: Node<E> | undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._first;\n\t}\n\n\tclear(): void {\n\t\tthis._first = undefined;\n\t\tthis._last = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (!this._first) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last!;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\t\treturn this._remove.bind(this, newNode);\n\t}\n\n\n\tshift(): E | undefined {\n\t\tif (!this._first) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (!this._last) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tlet candidate: Node<E> | undefined = this._first;\n\t\twhile (candidate instanceof Node) {\n\t\t\tif (candidate !== node) {\n\t\t\t\tcandidate = candidate.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (candidate.prev && candidate.next) {\n\t\t\t\t// middle\n\t\t\t\tconst anchor = candidate.prev;\n\t\t\t\tanchor.next = candidate.next;\n\t\t\t\tcandidate.next.prev = anchor;\n\n\t\t\t} else if (!candidate.prev && !candidate.next) {\n\t\t\t\t// only node\n\t\t\t\tthis._first = undefined;\n\t\t\t\tthis._last = undefined;\n\n\t\t\t} else if (!candidate.next) {\n\t\t\t\t// last\n\t\t\t\tthis._last = this._last!.prev!;\n\t\t\t\tthis._last.next = undefined;\n\n\t\t\t} else if (!candidate.prev) {\n\t\t\t\t// first\n\t\t\t\tthis._first = this._first!.next!;\n\t\t\t\tthis._first.prev = undefined;\n\t\t\t}\n\n\t\t\t// done\n\t\t\tthis._size -= 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\titerator(): Iterator<E> {\n\t\tlet element: { done: false; value: E; };\n\t\tlet node = this._first;\n\t\treturn {\n\t\t\tnext(): IteratorResult<E> {\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn FIN;\n\t\t\t\t}\n\n\t\t\t\tif (!element) {\n\t\t\t\t\telement = { done: false, value: node.element };\n\t\t\t\t} else {\n\t\t\t\t\telement.value = node.element;\n\t\t\t\t}\n\t\t\t\tnode = node.next;\n\t\t\t\treturn element;\n\t\t\t}\n\t\t};\n\t}\n\n\ttoArray(): E[] {\n\t\tconst result: E[] = [];\n\t\tfor (let node = this._first; node instanceof Node; node = node.next) {\n\t\t\tresult.push(node.element);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { combinedDisposable, Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n}\n\nexport namespace Event {\n\tconst _disposable = { dispose() { } };\n\texport const None: Event<any> = function () { return _disposable; };\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event and a `map` function, returns another event which maps each element\n\t * throught the mapping function.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n\t}\n\n\t/**\n\t * Given an event and an `each` function, returns another identical event and calls\n\t * the `each` function per each element.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n\t}\n\n\t/**\n\t * Given an event and a `filter` function, returns another event which emits those\n\t * elements for which the `filter` function returns `true`.\n\t */\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * Given an event and a `merge` function, returns another event which maps each element\n\t * and the cummulative result throught the `merge` function. Similar to `map`, but with memory.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t});\n\t}\n\n\t/**\n\t * Given a chain of event processing functions (filter, map, etc), each\n\t * function will be invoked per event & per listener. Snapshotting an event\n\t * chain allows each function to be invoked just once per event.\n\t */\n\texport function snapshot<T>(event: Event<T>): Event<T> {\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces the provided event, given a `merge` function.\n\t *\n\t * @param event The input event.\n\t * @param merge The reducing function.\n\t * @param delay The debouncing delay in millis.\n\t * @param leading Whether the event should fire in the leading phase of the timeout.\n\t * @param leakWarningThreshold The leak warning threshold override.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst emitter = new Emitter<O>({\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only once and as soon as\n\t * the input event emits. The event data is the number of millis it took for the\n\t * event to fire.\n\t */\n\texport function stopwatch<T>(event: Event<T>): Event<number> {\n\t\tconst start = new Date().getTime();\n\t\treturn map(once(event), _ => new Date().getTime() - start);\n\t}\n\n\t/**\n\t * Given an event, it returns another event which fires only when the event\n\t * element changes.\n\t */\n\texport function latch<T>(event: Event<T>): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || value !== cache;\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t});\n\t}\n\n\t/**\n\t * Buffers the provided event until a first listener comes\n\t * along, at which point fire all the events at once and\n\t * pipe the event from then on.\n\t *\n\t * ```typescript\n\t * const emitter = new Emitter<number>();\n\t * const event = emitter.event;\n\t * const bufferedEvent = buffer(event);\n\t *\n\t * emitter.fire(1);\n\t * emitter.fire(2);\n\t * emitter.fire(3);\n\t * // nothing...\n\t *\n\t * const listener = bufferedEvent(num => console.log(num));\n\t * // 1, 2, 3\n\t *\n\t * emitter.fire(4);\n\t * // 4\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, nextTick = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.forEach(e => emitter.fire(e));\n\t\t\t}\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (nextTick) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Similar to `buffer` but it buffers indefinitely and repeats\n\t * the buffered events to every new listener.\n\t */\n\texport function echo<T>(event: Event<T>, nextTick = false, buffer: T[] = []): Event<T> {\n\t\tbuffer = buffer.slice();\n\n\t\tevent(e => {\n\t\t\tbuffer.push(e);\n\t\t\temitter.fire(e);\n\t\t});\n\n\t\tconst flush = (listener: (e: T) => any, thisArgs?: any) => buffer.forEach(e => listener.call(thisArgs, e));\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonListenerDidAdd(emitter: Emitter<T>, listener: (e: T) => any, thisArgs?: any) {\n\t\t\t\tif (nextTick) {\n\t\t\t\t\tsetTimeout(() => flush(listener, thisArgs));\n\t\t\t\t} else {\n\t\t\t\t\tflush(listener, thisArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> {\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): this;\n\t\tremoveListener(event: string | symbol, listener: Function): this;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function fromPromise<T = any>(promise: Promise<T>): Event<undefined> {\n\t\tconst emitter = new Emitter<undefined>();\n\t\tlet shouldEmit = false;\n\n\t\tpromise\n\t\t\t.then(undefined, () => null)\n\t\t\t.then(() => {\n\t\t\t\tif (!shouldEmit) {\n\t\t\t\t\tsetTimeout(() => emitter.fire(undefined), 0);\n\t\t\t\t} else {\n\t\t\t\t\temitter.fire(undefined);\n\t\t\t\t}\n\t\t\t});\n\n\t\tshouldEmit = true;\n\t\treturn emitter.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(c => once(event)(c));\n\t}\n}\n\ntype Listener<T> = [(e: T) => void, any] | ((e: T) => void);\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n\t\tconst count = (this._stacks.get(stack) || 0);\n\t\tthis._stacks.set(stack, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string;\n\t\t\tlet topCount: number = 0;\n\t\t\tthis._stacks.forEach((count, stack) => {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack) || 0);\n\t\t\tthis._stacks!.set(stack, count - 1);\n\t\t};\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static readonly _noop = function () { };\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue: [Listener<T>, T][];\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0\n\t\t\t? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\n\t\t\t: undefined;\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tconst remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n\t\t\t\tif (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options && this._options.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, listener, thisArgs);\n\t\t\t\t}\n\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tlet removeMonitor: (() => void) | undefined;\n\t\t\t\tif (this._leakageMon) {\n\t\t\t\t\tremoveMonitor = this._leakageMon.check(this._listeners.size);\n\t\t\t\t}\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (removeMonitor) {\n\t\t\t\t\t\t\tremoveMonitor();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tremove();\n\t\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = [];\n\t\t\t}\n\n\t\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\t\tthis._deliveryQueue.push([e.value, event]);\n\t\t\t}\n\n\t\t\twhile (this._deliveryQueue.length > 0) {\n\t\t\t\tconst [listener, event] = this._deliveryQueue.shift()!;\n\t\t\t\ttry {\n\t\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif (this._listeners) {\n\t\t\tthis._listeners = undefined;\n\t\t}\n\t\tif (this._deliveryQueue) {\n\t\t\tthis._deliveryQueue.length = 0;\n\t\t}\n\t\tif (this._leakageMon) {\n\t\t\tthis._leakageMon.dispose();\n\t\t}\n\t\tthis._disposed = true;\n\t}\n}\n\nexport interface IWaitUntil {\n\twaitUntil(thenable: Promise<any>): void;\n}\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue: [Listener<T>, T, Promise<any>[]][];\n\n\tasync fireAsync(eventFn: (thenables: Promise<any>[], listener: Function) => T): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\t// put all [listener,event]-pairs into delivery queue\n\t\t// then emit all event. an inner/nested event might be\n\t\t// the driver of this\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = [];\n\t\t}\n\n\t\tfor (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n\t\t\tconst thenables: Promise<void>[] = [];\n\t\t\tthis._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);\n\t\t}\n\n\t\twhile (this._asyncDeliveryQueue.length > 0) {\n\t\t\tconst [listener, event, thenables] = this._asyncDeliveryQueue.shift()!;\n\t\t\ttry {\n\t\t\t\tif (typeof listener === 'function') {\n\t\t\t\t\tlistener.call(undefined, event);\n\t\t\t\t} else {\n\t\t\t\t\tlistener[0].call(listener[1], event);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\t\t\tawait Promise.all(thenables);\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null; }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null; }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\treadonly isCancellationRequested: boolean;\n\t/**\n\t * An event emitted when cancellation is requested\n\t * @event\n\t */\n\treadonly onCancellationRequested: Event<any>;\n}\n\nconst shortcutEvent = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n} as Event<any>);\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: any): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled: CancellationToken = Object.freeze({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token: CancellationToken;\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\n\nexport function isThenable<T>(obj: any): obj is Promise<T> {\n\treturn obj && typeof (<Promise<any>>obj).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tsource.token.onCancellationRequested(() => {\n\t\t\treject(errors.canceled());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn new class implements CancelablePromise<T> {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(c => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(c);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((c, e) => {\n\t\t\t\tthis.queuedPromise!.then(c, e);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((c, e) => {\n\t\t\tthis.activePromise!.then((result: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tc(result);\n\t\t\t}, (err: any) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\te(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<any> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask());\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate timeout: any;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: (err: any) => void;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number) {\n\t\tthis.timeout = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay: number = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((c, e) => {\n\t\t\t\tthis.doResolve = c;\n\t\t\t\tthis.doReject = e;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tconst task = this.task!;\n\t\t\t\tthis.task = null;\n\n\t\t\t\treturn task();\n\t\t\t});\n\t\t}\n\n\t\tthis.timeout = setTimeout(() => {\n\t\t\tthis.timeout = null;\n\t\t\tthis.doResolve!(null);\n\t\t}, delay);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.timeout !== null;\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject(errors.canceled());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tif (this.timeout !== null) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancelTimeout();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as any as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(resolve, millis);\n\t\ttoken.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\treject(errors.canceled());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\nexport function ignoreErrors<T>(promise: Promise<T>): Promise<T | undefined> {\n\treturn promise.then(undefined, _ => undefined);\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value?: T | Promise<T>) => void;\n\te: (error?: any) => void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> {\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate maxDegreeOfParalellism: number;\n\tprivate outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onFinished: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onFinished = new Emitter<void>();\n\t}\n\n\tpublic get onFinished(): Event<void> {\n\t\treturn this._onFinished.event;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._size;\n\t\t// return this.runningPromises + this.outstandingPromises.length;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onFinished.fire();\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._onFinished.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue {\n\tprivate queues: { [path: string]: Queue<void> };\n\n\tconstructor() {\n\t\tthis.queues = Object.create(null);\n\t}\n\n\tpublic queueFor(resource: URI): Queue<void> {\n\t\tconst key = resource.toString();\n\t\tif (!this.queues[key]) {\n\t\t\tconst queue = new Queue<void>();\n\t\t\tqueue.onFinished(() => {\n\t\t\t\tqueue.dispose();\n\t\t\t\tdelete this.queues[key];\n\t\t\t});\n\n\t\t\tthis.queues[key] = queue;\n\t\t}\n\n\t\treturn this.queues[key];\n\t}\n}\n\nexport class TimeoutTimer extends Disposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tsuper();\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer extends Disposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tsuper.dispose();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: any[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, timeout: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tif (this.runner) {\n\t\t\tthis.runner();\n\t\t}\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tif (this.runner) {\n\t\t\tthis.runner(units);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport function nfcall(fn: Function, ...args: any[]): Promise<any>;\nexport function nfcall<T>(fn: Function, ...args: any[]): Promise<T>;\nexport function nfcall(fn: Function, ...args: any[]): any {\n\treturn new Promise((c, e) => fn(...args, (err: any, result: any) => err ? e(err) : c(result)));\n}\n\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): Promise<any>;\nexport function ninvoke<T>(thisArg: any, fn: Function, ...args: any[]): Promise<T>;\nexport function ninvoke(thisArg: any, fn: Function, ...args: any[]): any {\n\treturn new Promise((resolve, reject) => fn.call(thisArg, ...args, (err: any, result: any) => err ? reject(err) : resolve(result)));\n}\n\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): DOMHighResTimeStamp;\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\tconst dummyIdle: IdleDeadline = Object.freeze({\n\t\t\tdidTimeout: true,\n\t\t\ttimeRemaining() { return 15; }\n\t\t});\n\t\trunWhenIdle = (runner) => {\n\t\t\tconst handle = setTimeout(() => runner(dummyIdle));\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean;\n\tprivate _value: T;\n\tprivate _error: any;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value;\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\n// let _isLinux = false;\nlet _isNative = false;\n// let _isWeb = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\n\ninterface NLSConfig {\n\tlocale: string;\n\tavailableLanguages: { [key: string]: string; };\n\t_translationsConfigFile: string;\n}\n\nexport interface IProcessEnvironment {\n\t[key: string]: string;\n}\n\ninterface INodeProcess {\n\tplatform: string;\n\tenv: IProcessEnvironment;\n\tgetuid(): number;\n\tnextTick: Function;\n\tversions?: {\n\t\telectron?: string;\n\t};\n\ttype?: string;\n}\ndeclare const process: INodeProcess;\ndeclare const global: any;\n\ninterface INavigator {\n\tuserAgent: string;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\ndeclare const self: any;\n\nconst isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');\n\n// OS detection\nif (typeof navigator === 'object' && !isElectronRenderer) {\n\tconst userAgent = navigator.userAgent;\n\t_isWindows = userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = userAgent.indexOf('Macintosh') >= 0;\n\t// _isLinux = userAgent.indexOf('Linux') >= 0;\n\t// _isWeb = true;\n\t_locale = navigator.language;\n\t_language = _locale;\n} else if (typeof process === 'object') {\n\t_isWindows = (process.platform === 'win32');\n\t_isMacintosh = (process.platform === 'darwin');\n\t// _isLinux = (process.platform === 'linux');\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\tconst resolved = nlsConfig.availableLanguages['*'];\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t// VSCode's default language is 'en'\n\t\t\t_language = resolved ? resolved : LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport function PlatformToString(platform: Platform) {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\n// let _platform: Platform = Platform.Web;\n// if (_isNative) {\n// \tif (_isMacintosh) {\n// \t\t_platform = Platform.Mac;\n// \t} else if (_isWindows) {\n// \t\t_platform = Platform.Windows;\n// \t} else if (_isLinux) {\n// \t\t_platform = Platform.Linux;\n// \t}\n// }\n\nexport const isRealWindows = _isWindows;\nexport const isWindows = false; // _isWindows;\nexport const isMacintosh = true; // _isMacintosh;\nexport const isLinux = false; // _isLinux;\nexport const isNative = false; // _isNative;\nexport const isWeb = false; // _isWeb;\nexport const platform = 1; // _platform;\n\nexport function isRootUser(): boolean {\n\treturn _isNative && !_isWindows && (process.getuid() === 0);\n}\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * The translatios that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nconst _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {} as any);\nexport const globals: any = _globals;\n\nlet _setImmediate: ((callback: (...args: any[]) => void) => number) | null = null;\nexport function setImmediate(callback: (...args: any[]) => void): number {\n\tif (_setImmediate === null) {\n\t\tif (globals.setImmediate) {\n\t\t\t_setImmediate = globals.setImmediate.bind(globals);\n\t\t} else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n\t\t\t_setImmediate = process.nextTick.bind(process);\n\t\t} else {\n\t\t\t_setImmediate = globals.setTimeout.bind(globals);\n\t\t}\n\t}\n\treturn _setImmediate!(callback);\n}\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isWindows, isMacintosh, setImmediate } from 'vs/base/common/platform';\n\ninterface IProcess {\n\tplatform: string;\n\tenv: object;\n\n\tcwd(): string;\n\tnextTick(callback: (...args: any[]) => void): number;\n}\n\ndeclare const process: IProcess;\nconst safeProcess: IProcess = (typeof process === 'undefined') ? {\n\tcwd(): string { return '/'; },\n\tenv: Object.create(null),\n\tget platform(): string { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\tnextTick(callback: (...args: any[]) => void): number { return setImmediate(callback); }\n} : process;\n\nexport const cwd = safeProcess.cwd;\nexport const env = safeProcess.env;\nexport const platform = safeProcess.platform;\nexport const nextTick = safeProcess.nextTick;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: string) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tlet msg;\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tmsg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\t}\n}\n\nfunction validateString(value: string, name) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n\treturn code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\n\t\tcode >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (lastSlash !== i - 1 && dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length === 2 || res.length === 1) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tif (res.length > 0) {\n\t\t\t\t\t\tres += `${separator}..`;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres = '..';\n\t\t\t\t\t}\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += separator + path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep, pathObject) {\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t((pathObject.name || '') + (pathObject.ext || ''));\n\tif (!dir) {\n\t\treturn base;\n\t}\n\tif (dir === pathObject.root) {\n\t\treturn dir + base;\n\t}\n\treturn dir + sep + base;\n}\n\ninterface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\ninterface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t} else if (!resolvedDevice) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env['=' + resolvedDevice] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\tpath.slice(0, 3).toLowerCase() !==\n\t\t\t\t\tresolvedDevice.toLowerCase() + '\\\\') {\n\t\t\t\t\tpath = resolvedDevice + '\\\\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len > 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// Possible UNC root\n\n\t\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\t\tisAbsolute = true;\n\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\t\tlet j = 2;\n\t\t\t\t\t\tlet last = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trootEnd = 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t\t// Possible device root\n\n\t\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\t\trootEnd = 2;\n\t\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator\n\t\t\t\trootEnd = 1;\n\t\t\t\tisAbsolute = true;\n\t\t\t}\n\n\t\t\tif (device.length > 0 &&\n\t\t\t\tresolvedDevice.length > 0 &&\n\t\t\t\tdevice.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length === 0 && device.length > 0) {\n\t\t\t\tresolvedDevice = device;\n\t\t\t}\n\t\t\tif (!resolvedAbsolute) {\n\t\t\t\tresolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t}\n\n\t\t\tif (resolvedDevice.length > 0 && resolvedAbsolute) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n\t\t\t'.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t\t// path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t\t// is nothing left to process\n\n\t\t\t\t\t\t\t\treturn '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\tdevice = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t\t\t// indicator\n\t\t\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid unnecessary\n\t\t\t// work\n\t\t\treturn '\\\\';\n\t\t}\n\n\t\tlet tail;\n\t\tif (rootEnd < len) {\n\t\t\ttail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\',\n\t\t\t\tisPathSeparator);\n\t\t} else {\n\t\t\ttail = '';\n\t\t}\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\tif (isAbsolute) {\n\t\t\t\tif (tail.length > 0) {\n\t\t\t\t\treturn '\\\\' + tail;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t} else if (tail.length > 0) {\n\t\t\t\treturn tail;\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (isAbsolute) {\n\t\t\tif (tail.length > 0) {\n\t\t\t\treturn device + '\\\\' + tail;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn device + '\\\\';\n\t\t\t}\n\t\t} else if (tail.length > 0) {\n\t\t\treturn device + tail;\n\t\t} else {\n\t\t\treturn device;\n\t\t}\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\tif (isPathSeparator(code)) {\n\t\t\treturn true;\n\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t// Possible device root\n\n\t\t\tif (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '\\\\' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for an UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at an UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as an UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1) {\n\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t\t++slashCount;\n\t\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\tfor (; slashCount < joined.length; ++slashCount) {\n\t\t\t\tif (!isPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = '\\\\' + joined.slice(slashCount);\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\tfor (; fromEnd - 1 > fromStart; --fromEnd) {\n\t\t\tif (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\tfor (; toEnd - 1 > toStart; --toEnd) {\n\t\t\tif (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length && lastCommonSep === -1) {\n\t\t\treturn toOrig;\n\t\t}\n\n\t\tlet out = '';\n\t\tif (lastCommonSep === -1) {\n\t\t\tlastCommonSep = 0;\n\t\t}\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '\\\\..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + toOrig.slice(toStart + lastCommonSep, toEnd);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn toOrig.slice(toStart, toEnd);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length >= 3) {\n\t\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\t\treturn '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\t\t\treturn '\\\\\\\\?\\\\' + resolvedPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = offset = 1;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = offset = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\trootEnd = offset = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn path;\n\t\t}\n\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = rootEnd;\n\t\t\t}\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2) {\n\t\t\tconst drive = path.charCodeAt(0);\n\t\t\tif (isWindowsDeviceRoot(drive)) {\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\tstart = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('\\\\', pathObject);\n\t},\n\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len > 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\trootEnd = 1;\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\tif (!isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\tfor (; j < len; ++j) {\n\t\t\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t\t// We matched a UNC root only\n\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code)) {\n\t\t\t\t// Possible device root\n\n\t\t\t\tif (path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t\trootEnd = 2;\n\t\t\t\t\tif (len > 2) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t\t\tif (len === 3) {\n\t\t\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trootEnd = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t\t// unnecessary work\n\t\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPathSeparator(code)) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\tret.root = ret.dir = path;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t}\n\t\t} else {\n\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\tret.base = path.slice(startPart, end);\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = process.cwd();\n\t\t\t}\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = path + '/' + resolvedPath;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\tif (resolvedPath.length > 0) {\n\t\t\t\treturn '/' + resolvedPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t} else if (resolvedPath.length > 0) {\n\t\t\treturn resolvedPath;\n\t\t} else {\n\t\t\treturn '.';\n\t\t}\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0 && !isAbsolute) {\n\t\t\tpath = '.';\n\t\t}\n\t\tif (path.length > 0 && trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\tif (isAbsolute) {\n\t\t\treturn '/' + path;\n\t\t}\n\t\treturn path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = arguments[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += '/' + arg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 1;\n\t\tfor (; fromStart < from.length; ++fromStart) {\n\t\t\tif (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = (fromEnd - fromStart);\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 1;\n\t\tfor (; toStart < to.length; ++toStart) {\n\t\t\tif (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst toEnd = to.length;\n\t\tconst toLen = (toEnd - toStart);\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i <= length; ++i) {\n\t\t\tif (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t\t}\n\t\t\t\t} else if (fromLen > length) {\n\t\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t\t// For example: from='/foo'; to='/'\n\t\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tconst toCode = to.charCodeAt(toStart + i);\n\t\t\tif (fromCode !== toCode) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (out.length === 0) {\n\t\t\t\t\tout += '..';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += '/..';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn out + to.slice(toStart + lastCommonSep);\n\t\t}\n\t\telse {\n\t\t\ttoStart += lastCommonSep;\n\t\t\tif (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n\t\t\t\t++toStart;\n\t\t\t}\n\t\t\treturn to.slice(toStart);\n\t\t}\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext.length === path.length && ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t}\n\t\t\telse if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t} else {\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (end === -1) {\n\t\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t\t// path component\n\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\tend = i + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end === -1) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat(pathObject): string {\n\t\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t\t}\n\n\t\treturn _format('/', pathObject);\n\t},\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\tif (end !== -1) {\n\t\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\t\tret.base = ret.name = path.slice(1, end);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (startPart === 0 && isAbsolute) {\n\t\t\t\tret.name = path.slice(1, startDot);\n\t\t\t\tret.base = path.slice(1, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t}\n\t\t\tret.ext = path.slice(startDot, end);\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t}\n\t\telse if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents a UUID as defined by rfc4122.\n */\nexport interface UUID {\n\n\t/**\n\t * @returns the canonical representation in sets of hexadecimal numbers separated by dashes.\n\t */\n\tasHex(): string;\n}\n\nclass ValueUUID implements UUID {\n\n\tconstructor(public _value: string) {\n\t\t// empty\n\t}\n\n\tpublic asHex(): string {\n\t\treturn this._value;\n\t}\n}\n\nclass V4UUID extends ValueUUID {\n\n\tprivate static readonly _chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\tprivate static readonly _timeHighBits = ['8', '9', 'a', 'b'];\n\n\tprivate static _oneOf(array: string[]): string {\n\t\treturn array[Math.floor(array.length * Math.random())];\n\t}\n\n\tprivate static _randomHex(): string {\n\t\treturn V4UUID._oneOf(V4UUID._chars);\n\t}\n\n\tconstructor() {\n\t\tsuper([\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\t'4',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._oneOf(V4UUID._timeHighBits),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\t'-',\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t\tV4UUID._randomHex(),\n\t\t].join(''));\n\t}\n}\n\nexport function v4(): UUID {\n\treturn new V4UUID();\n}\n\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\nexport function isUUID(value: string): boolean {\n\treturn _UUIDPattern.test(value);\n}\n\n/**\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\n * @param value A uuid string.\n */\nexport function parse(value: string): UUID {\n\tif (!isUUID(value)) {\n\t\tthrow new Error('invalid uuid');\n\t}\n\n\treturn new ValueUUID(value);\n}\n\nexport function generateUuid(): string {\n\treturn v4().asHex();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable, toDisposable, combinedDisposable } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, Relay } from 'vs/base/common/event';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any; };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel, id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any; };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose, id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string, name: string, stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: Buffer): void;\n\tonMessage: Event<Buffer>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the couter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidChangeConnections: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): Buffer;\n}\n\ninterface IWriter {\n\twrite(buffer: Buffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: Buffer) { }\n\n\tread(bytes: number): Buffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.length;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: Buffer[] = [];\n\n\tget buffer(): Buffer {\n\t\treturn Buffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: Buffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tArray = 3,\n\tObject = 4\n}\n\nfunction createSizeBuffer(size: number): Buffer {\n\tconst result = Buffer.allocUnsafe(4);\n\tresult.writeUInt32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUInt32BE(0);\n}\n\nconst BufferPresets = {\n\tUndefined: Buffer.alloc(1, DataType.Undefined),\n\tString: Buffer.alloc(1, DataType.String),\n\tBuffer: Buffer.alloc(1, DataType.Buffer),\n\tArray: Buffer.alloc(1, DataType.Array),\n\tObject: Buffer.alloc(1, DataType.Object)\n};\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = Buffer.from(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t} else if (Buffer.isBuffer(data)) {\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(data.length));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = Buffer.from(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.length));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.send([response.type]);\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.send([response.type, response.id], response.data);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(d => d.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\n\tprivate _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = createCancelablePromise(_ => this.whenInitialized());\n\t\t\tuninitializedPromise.then(() => {\n\t\t\t\tuninitializedPromise = null;\n\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t});\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable([toDisposable(cancel), cancellationTokenListener]);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => this.activeRequests.delete(disposable));\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawEventFireResponse) => emitter.fire(res.data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.send([request.type, request.id]);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: Buffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onBuffer(message: Buffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\tif (handler) {\n\t\t\thandler(response);\n\t\t}\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn Event.toPromise(this.onDidInitialize);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(p => p.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate _onDidChangeConnections = new Emitter<Connection<TContext>>();\n\treadonly onDidChangeConnections: Event<Connection<TContext>> = this._onDidChangeConnections.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidChangeConnections.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tconst channelPromise = router.routeCall(that, command, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tconst channelPromise = router.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidChangeConnections.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidChangeConnections);\n\t\treturn await this.route(hub);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Socket, Server as NetServer, createConnection, createServer } from 'net';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IMessagePassingProtocol, ClientConnectionEvent, IPCServer, IPCClient } from 'vs/base/parts/ipc/node/ipc';\nimport { join } from 'vs/base/common/path';\nimport { tmpdir } from 'os';\nimport { generateUuid } from 'vs/base/common/uuid';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport function generateRandomPipeName(): string {\n\tconst randomSuffix = generateUuid();\n\tif (process.platform === 'win32') {\n\t\treturn `\\\\\\\\.\\\\pipe\\\\vscode-ipc-${randomSuffix}-sock`;\n\t} else {\n\t\t// Mac/Unix: use socket file\n\t\treturn join(tmpdir(), `vscode-ipc-${randomSuffix}.sock`);\n\t}\n}\n\nclass ChunkStream {\n\n\tprivate _chunks: Buffer[];\n\tprivate _totalLength: number;\n\n\tpublic get byteLength() {\n\t\treturn this._totalLength;\n\t}\n\n\tconstructor() {\n\t\tthis._chunks = [];\n\t\tthis._totalLength = 0;\n\t}\n\n\tpublic acceptChunk(buff: Buffer) {\n\t\tthis._chunks.push(buff);\n\t\tthis._totalLength += buff.byteLength;\n\t}\n\n\tpublic readUInt32BE(): number {\n\t\tlet tmp = this.read(4);\n\t\treturn tmp.readUInt32BE(0);\n\t}\n\n\tpublic read(byteCount: number): Buffer {\n\t\tif (byteCount === 0) {\n\t\t\treturn Buffer.allocUnsafe(0);\n\t\t}\n\n\t\tif (byteCount > this._totalLength) {\n\t\t\tthrow new Error(`Cannot read so many bytes!`);\n\t\t}\n\n\t\tif (this._chunks[0].byteLength === byteCount) {\n\t\t\t// super fast path, precisely first chunk must be returned\n\t\t\tconst result = this._chunks.shift()!;\n\t\t\tthis._totalLength -= byteCount;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (this._chunks[0].byteLength > byteCount) {\n\t\t\t// fast path, the reading is entirely within the first chunk\n\t\t\tconst result = this._chunks[0].slice(0, byteCount);\n\t\t\tthis._chunks[0] = this._chunks[0].slice(byteCount);\n\t\t\tthis._totalLength -= byteCount;\n\t\t\treturn result;\n\t\t}\n\n\t\tlet result = Buffer.allocUnsafe(byteCount);\n\t\tlet resultOffset = 0;\n\t\twhile (byteCount > 0) {\n\t\t\tconst chunk = this._chunks[0];\n\t\t\tif (chunk.byteLength > byteCount) {\n\t\t\t\t// this chunk will survive\n\t\t\t\tthis._chunks[0] = chunk.slice(byteCount);\n\n\t\t\t\tchunk.copy(result, resultOffset, 0, byteCount);\n\t\t\t\tresultOffset += byteCount;\n\t\t\t\tthis._totalLength -= byteCount;\n\t\t\t\tbyteCount -= byteCount;\n\t\t\t} else {\n\t\t\t\t// this chunk will be entirely read\n\t\t\t\tthis._chunks.shift();\n\n\t\t\t\tchunk.copy(result, resultOffset, 0, chunk.byteLength);\n\t\t\t\tresultOffset += chunk.byteLength;\n\t\t\t\tthis._totalLength -= chunk.byteLength;\n\t\t\t\tbyteCount -= chunk.byteLength;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * A message has the following format:\n *\n * \t\t[bodyLen|message]\n * \t\t[header^|data^^^]\n * \t\t[u32be^^|buffer^]\n */\n\nexport class Protocol implements IDisposable, IMessagePassingProtocol {\n\n\tprivate static readonly _headerLen = 4;\n\n\tprivate _isDisposed: boolean;\n\tprivate _incomingData: ChunkStream;\n\n\tprivate _socketDataListener: (data: Buffer) => void;\n\tprivate _socketEndListener: () => void;\n\tprivate _socketCloseListener: () => void;\n\n\tprivate _onMessage = new Emitter<Buffer>();\n\treadonly onMessage: Event<Buffer> = this._onMessage.event;\n\n\tprivate _onClose = new Emitter<void>();\n\treadonly onClose: Event<void> = this._onClose.event;\n\n\tconstructor(private _socket: Socket) {\n\t\tthis._isDisposed = false;\n\t\tthis._incomingData = new ChunkStream();\n\n\t\tconst state = {\n\t\t\treadHead: true,\n\t\t\tbodyLen: -1,\n\t\t};\n\n\t\tconst acceptChunk = (data: Buffer) => {\n\n\t\t\tthis._incomingData.acceptChunk(data);\n\n\t\t\twhile (this._incomingData.byteLength > 0) {\n\n\t\t\t\tif (state.readHead) {\n\t\t\t\t\t// expecting header -> read header\n\t\t\t\t\tif (this._incomingData.byteLength >= Protocol._headerLen) {\n\t\t\t\t\t\tstate.bodyLen = this._incomingData.readUInt32BE();\n\t\t\t\t\t\tstate.readHead = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!state.readHead) {\n\t\t\t\t\t// expecting body -> read bodyLen-bytes for\n\t\t\t\t\t// the actual message or wait for more data\n\t\t\t\t\tif (this._incomingData.byteLength >= state.bodyLen) {\n\t\t\t\t\t\tconst buffer = this._incomingData.read(state.bodyLen);\n\n\t\t\t\t\t\tstate.bodyLen = -1;\n\t\t\t\t\t\tstate.readHead = true;\n\n\t\t\t\t\t\tthis._onMessage.fire(buffer);\n\n\t\t\t\t\t\tif (this._isDisposed) {\n\t\t\t\t\t\t\t// check if an event listener lead to our disposal\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis._socketDataListener = (data: Buffer) => {\n\t\t\tacceptChunk(data);\n\t\t};\n\t\t_socket.on('data', this._socketDataListener);\n\n\t\tthis._socketEndListener = () => {\n\t\t};\n\t\t_socket.on('end', this._socketEndListener);\n\n\t\tthis._socketCloseListener = () => {\n\t\t\tthis._onClose.fire();\n\t\t};\n\t\t_socket.once('close', this._socketCloseListener);\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis._socket.removeListener('data', this._socketDataListener);\n\t\tthis._socket.removeListener('end', this._socketEndListener);\n\t\tthis._socket.removeListener('close', this._socketCloseListener);\n\t}\n\n\tend(): void {\n\t\tthis._socket.end();\n\t}\n\n\treadEntireBuffer(): Buffer {\n\t\treturn this._incomingData.read(this._incomingData.byteLength);\n\t}\n\n\tsend(buffer: Buffer): void {\n\t\tconst header = Buffer.allocUnsafe(Protocol._headerLen);\n\t\theader.writeUInt32BE(buffer.length, 0, true);\n\t\tthis._writeSoon(header, buffer);\n\t}\n\n\tprivate _writeBuffer = new class {\n\n\t\tprivate _data: Buffer[] = [];\n\t\tprivate _totalLength = 0;\n\n\t\tadd(head: Buffer, body: Buffer): boolean {\n\t\t\tconst wasEmpty = this._totalLength === 0;\n\t\t\tthis._data.push(head, body);\n\t\t\tthis._totalLength += head.length + body.length;\n\t\t\treturn wasEmpty;\n\t\t}\n\n\t\ttake(): Buffer {\n\t\t\tconst ret = Buffer.concat(this._data, this._totalLength);\n\t\t\tthis._data.length = 0;\n\t\t\tthis._totalLength = 0;\n\t\t\treturn ret;\n\t\t}\n\t};\n\n\tprivate _writeSoon(header: Buffer, data: Buffer): void {\n\t\tif (this._writeBuffer.add(header, data)) {\n\t\t\tsetImmediate(() => {\n\t\t\t\t// return early if socket has been destroyed in the meantime\n\t\t\t\tif (this._socket.destroyed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// we ignore the returned value from `write` because we would have to cached the data\n\t\t\t\t// anyways and nodejs is already doing that for us:\n\t\t\t\t// > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\n\t\t\t\t// > However, the false return value is only advisory and the writable stream will unconditionally\n\t\t\t\t// > accept and buffer chunk even if it has not not been allowed to drain.\n\t\t\t\tthis._socket.write(this._writeBuffer.take());\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport class Server extends IPCServer {\n\n\tprivate static toClientConnectionEvent(server: NetServer): Event<ClientConnectionEvent> {\n\t\tconst onConnection = Event.fromNodeEventEmitter<Socket>(server, 'connection');\n\n\t\treturn Event.map(onConnection, socket => ({\n\t\t\tprotocol: new Protocol(socket),\n\t\t\tonDidClientDisconnect: Event.once(Event.fromNodeEventEmitter<void>(socket, 'close'))\n\t\t}));\n\t}\n\n\tprivate server: NetServer | null;\n\n\tconstructor(server: NetServer) {\n\t\tsuper(Server.toClientConnectionEvent(server));\n\t\tthis.server = server;\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\t\tif (this.server) {\n\t\t\tthis.server.close();\n\t\t\tthis.server = null;\n\t\t}\n\t}\n}\n\nexport class Client<TContext = string> extends IPCClient<TContext> {\n\n\tstatic fromSocket<TContext = string>(socket: Socket, id: TContext): Client<TContext> {\n\t\treturn new Client(new Protocol(socket), id);\n\t}\n\n\tget onClose(): Event<void> { return this.protocol.onClose; }\n\n\tconstructor(private protocol: Protocol | BufferedProtocol, id: TContext) {\n\t\tsuper(protocol, id);\n\t}\n\n\tdispose(): void {\n\t\tsuper.dispose();\n\t\tthis.protocol.end();\n\t}\n}\n\nexport function serve(port: number): Promise<Server>;\nexport function serve(namedPipe: string): Promise<Server>;\nexport function serve(hook: any): Promise<Server> {\n\treturn new Promise<Server>((c, e) => {\n\t\tconst server = createServer();\n\n\t\tserver.on('error', e);\n\t\tserver.listen(hook, () => {\n\t\t\tserver.removeListener('error', e);\n\t\t\tc(new Server(server));\n\t\t});\n\t});\n}\n\nexport function connect(options: { host: string, port: number }, clientId: string): Promise<Client>;\nexport function connect(port: number, clientId: string): Promise<Client>;\nexport function connect(namedPipe: string, clientId: string): Promise<Client>;\nexport function connect(hook: any, clientId: string): Promise<Client> {\n\treturn new Promise<Client>((c, e) => {\n\t\tconst socket = createConnection(hook, () => {\n\t\t\tsocket.removeListener('error', e);\n\t\t\tc(Client.fromSocket(socket, clientId));\n\t\t});\n\n\t\tsocket.once('error', e);\n\t});\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nfunction createBufferedEvent<T>(source: Event<T>): Event<T> {\n\tlet emitter: Emitter<T>;\n\tlet hasListeners = false;\n\tlet isDeliveringMessages = false;\n\tlet bufferedMessages: T[] = [];\n\n\tconst deliverMessages = () => {\n\t\tif (isDeliveringMessages) {\n\t\t\treturn;\n\t\t}\n\t\tisDeliveringMessages = true;\n\t\twhile (hasListeners && bufferedMessages.length > 0) {\n\t\t\temitter.fire(bufferedMessages.shift()!);\n\t\t}\n\t\tisDeliveringMessages = false;\n\t};\n\n\tsource((e: T) => {\n\t\tbufferedMessages.push(e);\n\t\tdeliverMessages();\n\t});\n\n\temitter = new Emitter<T>({\n\t\tonFirstListenerAdd: () => {\n\t\t\thasListeners = true;\n\t\t\t// it is important to deliver these messages after this call, but before\n\t\t\t// other messages have a chance to be received (to guarantee in order delivery)\n\t\t\t// that's why we're using here nextTick and not other types of timeouts\n\t\t\tprocess.nextTick(deliverMessages);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\thasListeners = false;\n\t\t}\n\t});\n\n\treturn emitter.event;\n}\n\n/**\n * Will ensure no messages are lost if there are no event listeners.\n */\nexport class BufferedProtocol implements IMessagePassingProtocol {\n\n\tprivate readonly _actual: Protocol;\n\tpublic readonly onMessage: Event<Buffer>;\n\tpublic readonly onClose: Event<void>;\n\n\tconstructor(actual: Protocol) {\n\t\tthis._actual = actual;\n\t\tthis.onMessage = createBufferedEvent(this._actual.onMessage);\n\t\tthis.onClose = createBufferedEvent(this._actual.onClose);\n\t}\n\n\tpublic send(buffer: Buffer): void {\n\t\tthis._actual.send(buffer);\n\t}\n\n\tpublic end(): void {\n\t\tthis._actual.end();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ServiceCollection } from './serviceCollection';\nimport * as descriptors from './descriptors';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>, index: number, optional: boolean }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport interface IConstructorSignature0<T> {\n\tnew(...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature1<A1, T> {\n\tnew(first: A1, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature2<A1, A2, T> {\n\tnew(first: A1, second: A2, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature3<A1, A2, A3, T> {\n\tnew(first: A1, second: A2, third: A3, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature4<A1, A2, A3, A4, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature5<A1, A2, A3, A4, A5, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature6<A1, A2, A3, A4, A5, A6, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\tnew(first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8, ...services: { _serviceBrand: any; }[]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>, isOptional?: typeof optional): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\nexport interface IInstantiationService {\n\n\t_serviceBrand: any;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by\n\t * the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<A1, T>(descriptor: descriptors.SyncDescriptor1<A1, T>, a1: A1): T;\n\tcreateInstance<A1, A2, T>(descriptor: descriptors.SyncDescriptor2<A1, A2, T>, a1: A1, a2: A2): T;\n\tcreateInstance<A1, A2, A3, T>(descriptor: descriptors.SyncDescriptor3<A1, A2, A3, T>, a1: A1, a2: A2, a3: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(descriptor: descriptors.SyncDescriptor4<A1, A2, A3, A4, T>, a1: A1, a2: A2, a3: A3, a4: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(descriptor: descriptors.SyncDescriptor5<A1, A2, A3, A4, A5, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(descriptor: descriptors.SyncDescriptor6<A1, A2, A3, A4, A5, A6, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(descriptor: descriptors.SyncDescriptor7<A1, A2, A3, A4, A5, A6, A7, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(descriptor: descriptors.SyncDescriptor8<A1, A2, A3, A4, A5, A6, A7, A8, T>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;\n\n\tcreateInstance<T>(ctor: IConstructorSignature0<T>): T;\n\tcreateInstance<A1, T>(ctor: IConstructorSignature1<A1, T>, first: A1): T;\n\tcreateInstance<A1, A2, T>(ctor: IConstructorSignature2<A1, A2, T>, first: A1, second: A2): T;\n\tcreateInstance<A1, A2, A3, T>(ctor: IConstructorSignature3<A1, A2, A3, T>, first: A1, second: A2, third: A3): T;\n\tcreateInstance<A1, A2, A3, A4, T>(ctor: IConstructorSignature4<A1, A2, A3, A4, T>, first: A1, second: A2, third: A3, fourth: A4): T;\n\tcreateInstance<A1, A2, A3, A4, A5, T>(ctor: IConstructorSignature5<A1, A2, A3, A4, A5, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, T>(ctor: IConstructorSignature6<A1, A2, A3, A4, A5, A6, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, T>(ctor: IConstructorSignature7<A1, A2, A3, A4, A5, A6, A7, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7): T;\n\tcreateInstance<A1, A2, A3, A4, A5, A6, A7, A8, T>(ctor: IConstructorSignature8<A1, A2, A3, A4, A5, A6, A7, A8, T>, first: A1, second: A2, third: A3, fourth: A4, fifth: A5, sixth: A6, seventh: A7, eigth: A8): T;\n\n\t/**\n\t *\n\t */\n\tinvokeFunction<R, TS extends any[]=[]>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherts all current services\n\t * and adds/overwrites the given services\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type T\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number, optional: boolean): void {\n\tif (target[_util.DI_TARGET] === target) {\n\t\ttarget[_util.DI_DEPENDENCIES].push({ id, index, optional });\n\t} else {\n\t\ttarget[_util.DI_DEPENDENCIES] = [{ id, index, optional }];\n\t\ttarget[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * A *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): { (...args: any[]): void; type: T; } {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index, false);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\n/**\n * Mark a service dependency as optional.\n */\nexport function optional<T>(serviceIdentifier: ServiceIdentifier<T>) {\n\n\treturn function (target: Function, key: string, index: number) {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@optional-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(serviceIdentifier, target, index, true);\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { connect as connectNet, Client } from 'vs/base/parts/ipc/node/ipc.net';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { IChannel, IServerChannel } from 'vs/base/parts/ipc/node/ipc';\nimport { Event } from 'vs/base/common/event';\n\nexport const ID = 'driverService';\nexport const IDriver = createDecorator<IDriver>(ID);\n\n// !! Do not remove the following START and END markers, they are parsed by the smoketest build\n\n//*START\nexport interface IElement {\n\ttagName: string;\n\tclassName: string;\n\ttextContent: string;\n\tattributes: { [name: string]: string; };\n\tchildren: IElement[];\n\ttop: number;\n\tleft: number;\n}\n\nexport interface IDriver {\n\t_serviceBrand: any;\n\n\tgetWindowIds(): Promise<number[]>;\n\tcapturePage(windowId: number): Promise<string>;\n\treloadWindow(windowId: number): Promise<void>;\n\texitApplication(): Promise<void>;\n\tdispatchKeybinding(windowId: number, keybinding: string): Promise<void>;\n\tclick(windowId: number, selector: string, xoffset?: number | undefined, yoffset?: number | undefined): Promise<void>;\n\tdoubleClick(windowId: number, selector: string): Promise<void>;\n\tsetValue(windowId: number, selector: string, text: string): Promise<void>;\n\tgetTitle(windowId: number): Promise<string>;\n\tisActiveElement(windowId: number, selector: string): Promise<boolean>;\n\tgetElements(windowId: number, selector: string, recursive?: boolean): Promise<IElement[]>;\n\ttypeInEditor(windowId: number, selector: string, text: string): Promise<void>;\n\tgetTerminalBuffer(windowId: number, selector: string): Promise<string[]>;\n\twriteInTerminal(windowId: number, selector: string, text: string): Promise<void>;\n}\n//*END\n\nexport class DriverChannel implements IServerChannel {\n\n\tconstructor(private driver: IDriver) { }\n\n\tlisten<T>(_, event: string): Event<T> {\n\t\tthrow new Error('No event found');\n\t}\n\n\tcall(_, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'getWindowIds': return this.driver.getWindowIds();\n\t\t\tcase 'capturePage': return this.driver.capturePage(arg);\n\t\t\tcase 'reloadWindow': return this.driver.reloadWindow(arg);\n\t\t\tcase 'exitApplication': return this.driver.exitApplication();\n\t\t\tcase 'dispatchKeybinding': return this.driver.dispatchKeybinding(arg[0], arg[1]);\n\t\t\tcase 'click': return this.driver.click(arg[0], arg[1], arg[2], arg[3]);\n\t\t\tcase 'doubleClick': return this.driver.doubleClick(arg[0], arg[1]);\n\t\t\tcase 'setValue': return this.driver.setValue(arg[0], arg[1], arg[2]);\n\t\t\tcase 'getTitle': return this.driver.getTitle(arg[0]);\n\t\t\tcase 'isActiveElement': return this.driver.isActiveElement(arg[0], arg[1]);\n\t\t\tcase 'getElements': return this.driver.getElements(arg[0], arg[1], arg[2]);\n\t\t\tcase 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1], arg[2]);\n\t\t\tcase 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg[0], arg[1]);\n\t\t\tcase 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1], arg[2]);\n\t\t}\n\n\t\tthrow new Error(`Call not found: ${command}`);\n\t}\n}\n\nexport class DriverChannelClient implements IDriver {\n\n\t_serviceBrand: any;\n\n\tconstructor(private channel: IChannel) { }\n\n\tgetWindowIds(): Promise<number[]> {\n\t\treturn this.channel.call('getWindowIds');\n\t}\n\n\tcapturePage(windowId: number): Promise<string> {\n\t\treturn this.channel.call('capturePage', windowId);\n\t}\n\n\treloadWindow(windowId: number): Promise<void> {\n\t\treturn this.channel.call('reloadWindow', windowId);\n\t}\n\n\texitApplication(): Promise<void> {\n\t\treturn this.channel.call('exitApplication');\n\t}\n\n\tdispatchKeybinding(windowId: number, keybinding: string): Promise<void> {\n\t\treturn this.channel.call('dispatchKeybinding', [windowId, keybinding]);\n\t}\n\n\tclick(windowId: number, selector: string, xoffset: number | undefined, yoffset: number | undefined): Promise<void> {\n\t\treturn this.channel.call('click', [windowId, selector, xoffset, yoffset]);\n\t}\n\n\tdoubleClick(windowId: number, selector: string): Promise<void> {\n\t\treturn this.channel.call('doubleClick', [windowId, selector]);\n\t}\n\n\tsetValue(windowId: number, selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('setValue', [windowId, selector, text]);\n\t}\n\n\tgetTitle(windowId: number): Promise<string> {\n\t\treturn this.channel.call('getTitle', [windowId]);\n\t}\n\n\tisActiveElement(windowId: number, selector: string): Promise<boolean> {\n\t\treturn this.channel.call('isActiveElement', [windowId, selector]);\n\t}\n\n\tgetElements(windowId: number, selector: string, recursive: boolean): Promise<IElement[]> {\n\t\treturn this.channel.call('getElements', [windowId, selector, recursive]);\n\t}\n\n\ttypeInEditor(windowId: number, selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('typeInEditor', [windowId, selector, text]);\n\t}\n\n\tgetTerminalBuffer(windowId: number, selector: string): Promise<string[]> {\n\t\treturn this.channel.call('getTerminalBuffer', [windowId, selector]);\n\t}\n\n\twriteInTerminal(windowId: number, selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('writeInTerminal', [windowId, selector, text]);\n\t}\n}\n\nexport interface IDriverOptions {\n\tverbose: boolean;\n}\n\nexport interface IWindowDriverRegistry {\n\tregisterWindowDriver(windowId: number): Promise<IDriverOptions>;\n\treloadWindowDriver(windowId: number): Promise<void>;\n}\n\nexport class WindowDriverRegistryChannel implements IServerChannel {\n\n\tconstructor(private registry: IWindowDriverRegistry) { }\n\n\tlisten<T>(_, event: string): Event<T> {\n\t\tthrow new Error(`Event not found: ${event}`);\n\t}\n\n\tcall(_, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'registerWindowDriver': return this.registry.registerWindowDriver(arg);\n\t\t\tcase 'reloadWindowDriver': return this.registry.reloadWindowDriver(arg);\n\t\t}\n\n\t\tthrow new Error(`Call not found: ${command}`);\n\t}\n}\n\nexport class WindowDriverRegistryChannelClient implements IWindowDriverRegistry {\n\n\t_serviceBrand: any;\n\n\tconstructor(private channel: IChannel) { }\n\n\tregisterWindowDriver(windowId: number): Promise<IDriverOptions> {\n\t\treturn this.channel.call('registerWindowDriver', windowId);\n\t}\n\n\treloadWindowDriver(windowId: number): Promise<void> {\n\t\treturn this.channel.call('reloadWindowDriver', windowId);\n\t}\n}\n\nexport interface IWindowDriver {\n\tclick(selector: string, xoffset?: number | undefined, yoffset?: number | undefined): Promise<void>;\n\tdoubleClick(selector: string): Promise<void>;\n\tsetValue(selector: string, text: string): Promise<void>;\n\tgetTitle(): Promise<string>;\n\tisActiveElement(selector: string): Promise<boolean>;\n\tgetElements(selector: string, recursive: boolean): Promise<IElement[]>;\n\ttypeInEditor(selector: string, text: string): Promise<void>;\n\tgetTerminalBuffer(selector: string): Promise<string[]>;\n\twriteInTerminal(selector: string, text: string): Promise<void>;\n}\n\nexport class WindowDriverChannel implements IServerChannel {\n\n\tconstructor(private driver: IWindowDriver) { }\n\n\tlisten<T>(_, event: string): Event<T> {\n\t\tthrow new Error(`No event found: ${event}`);\n\t}\n\n\tcall(_, command: string, arg?: any): Promise<any> {\n\t\tswitch (command) {\n\t\t\tcase 'click': return this.driver.click(arg[0], arg[1], arg[2]);\n\t\t\tcase 'doubleClick': return this.driver.doubleClick(arg);\n\t\t\tcase 'setValue': return this.driver.setValue(arg[0], arg[1]);\n\t\t\tcase 'getTitle': return this.driver.getTitle();\n\t\t\tcase 'isActiveElement': return this.driver.isActiveElement(arg);\n\t\t\tcase 'getElements': return this.driver.getElements(arg[0], arg[1]);\n\t\t\tcase 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1]);\n\t\t\tcase 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg);\n\t\t\tcase 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1]);\n\t\t}\n\n\t\tthrow new Error(`Call not found: ${command}`);\n\t}\n}\n\nexport class WindowDriverChannelClient implements IWindowDriver {\n\n\t_serviceBrand: any;\n\n\tconstructor(private channel: IChannel) { }\n\n\tclick(selector: string, xoffset?: number, yoffset?: number): Promise<void> {\n\t\treturn this.channel.call('click', [selector, xoffset, yoffset]);\n\t}\n\n\tdoubleClick(selector: string): Promise<void> {\n\t\treturn this.channel.call('doubleClick', selector);\n\t}\n\n\tsetValue(selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('setValue', [selector, text]);\n\t}\n\n\tgetTitle(): Promise<string> {\n\t\treturn this.channel.call('getTitle');\n\t}\n\n\tisActiveElement(selector: string): Promise<boolean> {\n\t\treturn this.channel.call('isActiveElement', selector);\n\t}\n\n\tgetElements(selector: string, recursive: boolean): Promise<IElement[]> {\n\t\treturn this.channel.call('getElements', [selector, recursive]);\n\t}\n\n\ttypeInEditor(selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('typeInEditor', [selector, text]);\n\t}\n\n\tgetTerminalBuffer(selector: string): Promise<string[]> {\n\t\treturn this.channel.call('getTerminalBuffer', selector);\n\t}\n\n\twriteInTerminal(selector: string, text: string): Promise<void> {\n\t\treturn this.channel.call('writeInTerminal', [selector, text]);\n\t}\n}\n\nexport async function connect(handle: string): Promise<{ client: Client, driver: IDriver }> {\n\tconst client = await connectNet(handle, 'driverClient');\n\tconst channel = client.getChannel('driver');\n\tconst driver = new DriverChannelClient(channel);\n\treturn { client, driver };\n}\n"]}