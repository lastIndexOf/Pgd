{"version":3,"sources":["vs/base/node/languagePacks.js"],"names":["factory","nodeRequire","path","fs","perf","exists","file","Promise","c","mkdir","dir","e","err","code","rimraf","location","lstat","stats","then","stat","isDirectory","isSymbolicLink","readdir","files","children","all","map","child","join","rmdir","undefined","unlink","mkdirp","parent","dirname","readFile","resolve","reject","data","writeFile","content","getNLSConfiguration","commit","userDataPath","metaDataFile","locale","availableLanguages","pseudo","process","env","initialLocale","mark","defaultResult","configs","configFile","getLanguagePackConfigurations","config","index","lastIndexOf","substring","console","error","resolveLanguagePackLocale","packConfig","mainPack","hash","translations","fileExists","packId","cacheRoot","coreLocation","translationsConfigFile","corruptedFile","result","*","_languagePackId","_translationsConfigFile","_cacheRoot","_resolvedLanguagePackCoreLocation","_corruptedFile","corrupted","toDelete","d","Date","utimes","touch","catch","values","metadata","JSON","parse","packData","contents","bundles","Object","keys","writes","bundle","modules","target","create","module","defaultMessages","messages","targetStrings","i","length","elem","translatedMessage","key","push","replace","stringify","define","require","__$__nodeRequire","exports","Error"],"mappings":"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","file":"languagePacks.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n//@ts-check\n\n/**\n * @param {NodeRequire} nodeRequire\n * @param {typeof import('path')} path\n * @param {typeof import('fs')} fs\n * @param {typeof import('../common/performance')} perf\n */\nfunction factory(nodeRequire, path, fs, perf) {\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<boolean>}\n\t */\n\tfunction exists(file) {\n\t\treturn new Promise(c => fs.exists(file, c));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction touch(file) {\n\t\treturn new Promise((c, e) => { const d = new Date(); fs.utimes(file, d, d, err => err ? e(err) : c()); });\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<object>}\n\t */\n\tfunction lstat(file) {\n\t\treturn new Promise((c, e) => fs.lstat(file, (err, stats) => err ? e(err) : c(stats)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string[]>}\n\t */\n\tfunction readdir(dir) {\n\t\treturn new Promise((c, e) => fs.readdir(dir, (err, files) => err ? e(err) : c(files)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string>}\n\t */\n\tfunction mkdir(dir) {\n\t\treturn new Promise((c, e) => fs.mkdir(dir, err => (err && err.code !== 'EEXIST') ? e(err) : c(dir)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<void>}\n\t */\n\tfunction rmdir(dir) {\n\t\treturn new Promise((c, e) => fs.rmdir(dir, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction unlink(file) {\n\t\treturn new Promise((c, e) => fs.unlink(file, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} location\n\t * @returns {Promise<void>}\n\t */\n\tfunction rimraf(location) {\n\t\treturn lstat(location).then(stat => {\n\t\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\t\treturn readdir(location)\n\t\t\t\t\t.then(children => Promise.all(children.map(child => rimraf(path.join(location, child)))))\n\t\t\t\t\t.then(() => rmdir(location));\n\t\t\t} else {\n\t\t\t\treturn unlink(location);\n\t\t\t}\n\t\t}, err => {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tthrow err;\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string>}\n\t */\n\tfunction mkdirp(dir) {\n\t\treturn mkdir(dir).then(null, err => {\n\t\t\tif (err && err.code === 'ENOENT') {\n\t\t\t\tconst parent = path.dirname(dir);\n\n\t\t\t\tif (parent !== dir) { // if not arrived at root\n\t\t\t\t\treturn mkdirp(parent).then(() => mkdir(dir));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t});\n\t}\n\n\tfunction readFile(file) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.readFile(file, 'utf8', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @param {string} content\n\t * @returns {Promise<void>}\n\t */\n\tfunction writeFile(file, content) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.writeFile(file, content, 'utf8', function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\n\t/**\n\t * @param {string} userDataPath\n\t * @returns {object}\n\t */\n\tfunction getLanguagePackConfigurations(userDataPath) {\n\t\tconst configFile = path.join(userDataPath, 'languagepacks.json');\n\t\ttry {\n\t\t\treturn nodeRequire(configFile);\n\t\t} catch (err) {\n\t\t\t// Do nothing. If we can't read the file we have no\n\t\t\t// language pack config.\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {object} config\n\t * @param {string} locale\n\t */\n\tfunction resolveLanguagePackLocale(config, locale) {\n\t\ttry {\n\t\t\twhile (locale) {\n\t\t\t\tif (config[locale]) {\n\t\t\t\t\treturn locale;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error('Resolving language pack configuration failed.', err);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {string} commit\n\t * @param {string} userDataPath\n\t * @param {string} metaDataFile\n\t * @param {string} locale\n\t */\n\tfunction getNLSConfiguration(commit, userDataPath, metaDataFile, locale) {\n\t\tif (locale === 'pseudo') {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {}, pseudo: true });\n\t\t}\n\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\t// We have a built version so we have extracted nls file. Try to find\n\t\t// the right file to use.\n\n\t\t// Check if we have an English or English US locale. If so fall to default since that is our\n\t\t// English translation (we don't ship *.nls.en.json files)\n\t\tif (locale && (locale === 'en' || locale === 'en-us')) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\tconst initialLocale = locale;\n\n\t\tperf.mark('nlsGeneration:start');\n\n\t\tconst defaultResult = function (locale) {\n\t\t\tperf.mark('nlsGeneration:end');\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t};\n\t\ttry {\n\t\t\tif (!commit) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst configs = getLanguagePackConfigurations(userDataPath);\n\t\t\tif (!configs) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tlocale = resolveLanguagePackLocale(configs, locale);\n\t\t\tif (!locale) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst packConfig = configs[locale];\n\t\t\tlet mainPack;\n\t\t\tif (!packConfig || typeof packConfig.hash !== 'string' || !packConfig.translations || typeof (mainPack = packConfig.translations['vscode']) !== 'string') {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\treturn exists(mainPack).then(fileExists => {\n\t\t\t\tif (!fileExists) {\n\t\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t\t}\n\t\t\t\tconst packId = packConfig.hash + '.' + locale;\n\t\t\t\tconst cacheRoot = path.join(userDataPath, 'clp', packId);\n\t\t\t\tconst coreLocation = path.join(cacheRoot, commit);\n\t\t\t\tconst translationsConfigFile = path.join(cacheRoot, 'tcf.json');\n\t\t\t\tconst corruptedFile = path.join(cacheRoot, 'corrupted.info');\n\t\t\t\tconst result = {\n\t\t\t\t\tlocale: initialLocale,\n\t\t\t\t\tavailableLanguages: { '*': locale },\n\t\t\t\t\t_languagePackId: packId,\n\t\t\t\t\t_translationsConfigFile: translationsConfigFile,\n\t\t\t\t\t_cacheRoot: cacheRoot,\n\t\t\t\t\t_resolvedLanguagePackCoreLocation: coreLocation,\n\t\t\t\t\t_corruptedFile: corruptedFile\n\t\t\t\t};\n\t\t\t\treturn exists(corruptedFile).then(corrupted => {\n\t\t\t\t\t// The nls cache directory is corrupted.\n\t\t\t\t\tlet toDelete;\n\t\t\t\t\tif (corrupted) {\n\t\t\t\t\t\ttoDelete = rimraf(cacheRoot);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoDelete = Promise.resolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t\treturn toDelete.then(() => {\n\t\t\t\t\t\treturn exists(coreLocation).then(fileExists => {\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\t// We don't wait for this. No big harm if we can't touch\n\t\t\t\t\t\t\t\ttouch(coreLocation).catch(() => { });\n\t\t\t\t\t\t\t\tperf.mark('nlsGeneration:end');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn mkdirp(coreLocation).then(() => {\n\t\t\t\t\t\t\t\treturn Promise.all([readFile(metaDataFile), readFile(mainPack)]);\n\t\t\t\t\t\t\t}).then(values => {\n\t\t\t\t\t\t\t\tconst metadata = JSON.parse(values[0]);\n\t\t\t\t\t\t\t\tconst packData = JSON.parse(values[1]).contents;\n\t\t\t\t\t\t\t\tconst bundles = Object.keys(metadata.bundles);\n\t\t\t\t\t\t\t\tconst writes = [];\n\t\t\t\t\t\t\t\tfor (let bundle of bundles) {\n\t\t\t\t\t\t\t\t\tconst modules = metadata.bundles[bundle];\n\t\t\t\t\t\t\t\t\tconst target = Object.create(null);\n\t\t\t\t\t\t\t\t\tfor (let module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst keys = metadata.keys[module];\n\t\t\t\t\t\t\t\t\t\tconst defaultMessages = metadata.messages[module];\n\t\t\t\t\t\t\t\t\t\tconst translations = packData[module];\n\t\t\t\t\t\t\t\t\t\tlet targetStrings;\n\t\t\t\t\t\t\t\t\t\tif (translations) {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = [];\n\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst elem = keys[i];\n\t\t\t\t\t\t\t\t\t\t\t\tconst key = typeof elem === 'string' ? elem : elem.key;\n\t\t\t\t\t\t\t\t\t\t\t\tlet translatedMessage = translations[key];\n\t\t\t\t\t\t\t\t\t\t\t\tif (translatedMessage === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttranslatedMessage = defaultMessages[i];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\ttargetStrings.push(translatedMessage);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = defaultMessages;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttarget[module] = targetStrings;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twrites.push(writeFile(path.join(coreLocation, bundle.replace(/\\//g, '!') + '.nls.json'), JSON.stringify(target)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrites.push(writeFile(translationsConfigFile, JSON.stringify(packConfig.translations)));\n\t\t\t\t\t\t\t\treturn Promise.all(writes);\n\t\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\t\tperf.mark('nlsGeneration:end');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}).catch(err => {\n\t\t\t\t\t\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\t\t\t\t\t\treturn defaultResult(locale);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\treturn defaultResult(locale);\n\t\t}\n\t}\n\n\treturn {\n\t\tgetNLSConfiguration\n\t};\n}\n\n\nif (typeof define === 'function') {\n\t// amd\n\tdefine(['path', 'fs', 'vs/base/common/performance'], function (path, fs, perf) { return factory(require.__$__nodeRequire, path, fs, perf); });\n} else if (typeof module === 'object' && typeof module.exports === 'object') {\n\tconst path = require('path');\n\tconst fs = require('fs');\n\tconst perf = require('../common/performance');\n\tmodule.exports = factory(require, path, fs, perf);\n} else {\n\tthrow new Error('Unknown context');\n}"]}